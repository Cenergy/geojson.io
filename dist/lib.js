(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./dist/d3.js":
/*!********************!*\
  !*** ./dist/d3.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n!function () {\n  var d3 = {\n    version: \"3.4.11\"\n  }; // semver\n\n  d3.entries = function (map) {\n    var entries = [];\n\n    for (var key in map) {\n      entries.push({\n        key: key,\n        value: map[key]\n      });\n    }\n\n    return entries;\n  };\n\n  function d3_class(ctor, properties) {\n    try {\n      for (var key in properties) {\n        Object.defineProperty(ctor.prototype, key, {\n          value: properties[key],\n          enumerable: false\n        });\n      }\n    } catch (e) {\n      ctor.prototype = properties;\n    }\n  }\n\n  d3.map = function (object) {\n    var map = new d3_Map();\n    if (object instanceof d3_Map) object.forEach(function (key, value) {\n      map.set(key, value);\n    });else for (var key in object) {\n      map.set(key, object[key]);\n    }\n    return map;\n  };\n\n  function d3_Map() {}\n\n  d3_class(d3_Map, {\n    has: d3_map_has,\n    get: function get(key) {\n      return this[d3_map_prefix + key];\n    },\n    set: function set(key, value) {\n      return this[d3_map_prefix + key] = value;\n    },\n    remove: d3_map_remove,\n    keys: d3_map_keys,\n    values: function values() {\n      var values = [];\n      this.forEach(function (key, value) {\n        values.push(value);\n      });\n      return values;\n    },\n    entries: function entries() {\n      var entries = [];\n      this.forEach(function (key, value) {\n        entries.push({\n          key: key,\n          value: value\n        });\n      });\n      return entries;\n    },\n    size: d3_map_size,\n    empty: d3_map_empty,\n    forEach: function forEach(f) {\n      for (var key in this) {\n        if (key.charCodeAt(0) === d3_map_prefixCode) f.call(this, key.substring(1), this[key]);\n      }\n    }\n  });\n  var d3_map_prefix = \"\\0\",\n      // prevent collision with built-ins\n  d3_map_prefixCode = d3_map_prefix.charCodeAt(0);\n\n  function d3_map_has(key) {\n    return d3_map_prefix + key in this;\n  }\n\n  function d3_map_remove(key) {\n    key = d3_map_prefix + key;\n    return key in this && delete this[key];\n  }\n\n  function d3_map_keys() {\n    var keys = [];\n    this.forEach(function (key) {\n      keys.push(key);\n    });\n    return keys;\n  }\n\n  function d3_map_size() {\n    var size = 0;\n\n    for (var key in this) {\n      if (key.charCodeAt(0) === d3_map_prefixCode) ++size;\n    }\n\n    return size;\n  }\n\n  function d3_map_empty() {\n    for (var key in this) {\n      if (key.charCodeAt(0) === d3_map_prefixCode) return false;\n    }\n\n    return true;\n  }\n\n  d3.set = function (array) {\n    var set = new d3_Set();\n    if (array) for (var i = 0, n = array.length; i < n; ++i) {\n      set.add(array[i]);\n    }\n    return set;\n  };\n\n  function d3_Set() {}\n\n  d3_class(d3_Set, {\n    has: d3_map_has,\n    add: function add(value) {\n      this[d3_map_prefix + value] = true;\n      return value;\n    },\n    remove: function remove(value) {\n      value = d3_map_prefix + value;\n      return value in this && delete this[value];\n    },\n    values: d3_map_keys,\n    size: d3_map_size,\n    empty: d3_map_empty,\n    forEach: function forEach(f) {\n      for (var value in this) {\n        if (value.charCodeAt(0) === d3_map_prefixCode) f.call(this, value.substring(1));\n      }\n    }\n  });\n\n  d3.pairs = function (array) {\n    var i = 0,\n        n = array.length - 1,\n        p0,\n        p1 = array[0],\n        pairs = new Array(n < 0 ? 0 : n);\n\n    while (i < n) {\n      pairs[i] = [p0 = p1, p1 = array[++i]];\n    }\n\n    return pairs;\n  };\n\n  var abs = Math.abs;\n\n  d3.range = function (start, stop, step) {\n    if (arguments.length < 3) {\n      step = 1;\n\n      if (arguments.length < 2) {\n        stop = start;\n        start = 0;\n      }\n    }\n\n    if ((stop - start) / step === Infinity) throw new Error(\"infinite range\");\n    var range = [],\n        k = d3_range_integerScale(abs(step)),\n        i = -1,\n        j;\n    start *= k, stop *= k, step *= k;\n    if (step < 0) while ((j = start + step * ++i) > stop) {\n      range.push(j / k);\n    } else while ((j = start + step * ++i) < stop) {\n      range.push(j / k);\n    }\n    return range;\n  };\n\n  function d3_range_integerScale(x) {\n    var k = 1;\n\n    while (x * k % 1) {\n      k *= 10;\n    }\n\n    return k;\n  }\n\n  var d3_arraySlice = [].slice,\n      d3_array = function d3_array(list) {\n    return d3_arraySlice.call(list);\n  }; // conversion for NodeLists\n\n\n  var d3_document = document,\n      d3_documentElement = d3_document.documentElement,\n      d3_window = window; // Redefine d3_array if the browser doesn’t support slice-based conversion.\n\n  try {\n    d3_array(d3_documentElement.childNodes)[0].nodeType;\n  } catch (e) {\n    d3_array = function d3_array(list) {\n      var i = list.length,\n          array = new Array(i);\n\n      while (i--) {\n        array[i] = list[i];\n      }\n\n      return array;\n    };\n  } // Copies a variable number of methods from source to target.\n\n\n  d3.rebind = function (target, source) {\n    var i = 1,\n        n = arguments.length,\n        method;\n\n    while (++i < n) {\n      target[method = arguments[i]] = d3_rebind(target, source, source[method]);\n    }\n\n    return target;\n  }; // Method is assumed to be a standard D3 getter-setter:\n  // If passed with no arguments, gets the value.\n  // If passed with arguments, sets the value and returns the target.\n\n\n  function d3_rebind(target, source, method) {\n    return function () {\n      var value = method.apply(source, arguments);\n      return value === source ? target : value;\n    };\n  }\n\n  function d3_vendorSymbol(object, name) {\n    if (name in object) return name;\n    name = name.charAt(0).toUpperCase() + name.substring(1);\n\n    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {\n      var prefixName = d3_vendorPrefixes[i] + name;\n      if (prefixName in object) return prefixName;\n    }\n  }\n\n  var d3_vendorPrefixes = [\"webkit\", \"ms\", \"moz\", \"Moz\", \"o\", \"O\"];\n\n  function d3_noop() {}\n\n  d3.dispatch = function () {\n    var dispatch = new d3_dispatch(),\n        i = -1,\n        n = arguments.length;\n\n    while (++i < n) {\n      dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n    }\n\n    return dispatch;\n  };\n\n  function d3_dispatch() {}\n\n  d3_dispatch.prototype.on = function (type, listener) {\n    var i = type.indexOf(\".\"),\n        name = \"\"; // Extract optional namespace, e.g., \"click.foo\"\n\n    if (i >= 0) {\n      name = type.substring(i + 1);\n      type = type.substring(0, i);\n    }\n\n    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);\n\n    if (arguments.length === 2) {\n      if (listener == null) for (type in this) {\n        if (this.hasOwnProperty(type)) this[type].on(name, null);\n      }\n      return this;\n    }\n  };\n\n  function d3_dispatch_event(dispatch) {\n    var listeners = [],\n        listenerByName = new d3_Map();\n\n    function event() {\n      var z = listeners,\n          // defensive reference\n      i = -1,\n          n = z.length,\n          l;\n\n      while (++i < n) {\n        if (l = z[i].on) l.apply(this, arguments);\n      }\n\n      return dispatch;\n    }\n\n    event.on = function (name, listener) {\n      var l = listenerByName.get(name),\n          i; // return the current listener, if any\n\n      if (arguments.length < 2) return l && l.on; // remove the old listener, if any (with copy-on-write)\n\n      if (l) {\n        l.on = null;\n        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));\n        listenerByName.remove(name);\n      } // add the new listener, if any\n\n\n      if (listener) listeners.push(listenerByName.set(name, {\n        on: listener\n      }));\n      return dispatch;\n    };\n\n    return event;\n  }\n\n  d3.event = null;\n\n  function d3_eventPreventDefault() {\n    d3.event.preventDefault();\n  }\n\n  function d3_eventSource() {\n    var e = d3.event,\n        s;\n\n    while (s = e.sourceEvent) {\n      e = s;\n    }\n\n    return e;\n  } // Like d3.dispatch, but for custom events abstracting native UI events. These\n  // events have a target component (such as a brush), a target element (such as\n  // the svg:g element containing the brush) and the standard arguments `d` (the\n  // target element's data) and `i` (the selection index of the target element).\n\n\n  function d3_eventDispatch(target) {\n    var dispatch = new d3_dispatch(),\n        i = 0,\n        n = arguments.length;\n\n    while (++i < n) {\n      dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n    } // Creates a dispatch context for the specified `thiz` (typically, the target\n    // DOM element that received the source event) and `argumentz` (typically, the\n    // data `d` and index `i` of the target element). The returned function can be\n    // used to dispatch an event to any registered listeners; the function takes a\n    // single argument as input, being the event to dispatch. The event must have\n    // a \"type\" attribute which corresponds to a type registered in the\n    // constructor. This context will automatically populate the \"sourceEvent\" and\n    // \"target\" attributes of the event, as well as setting the `d3.event` global\n    // for the duration of the notification.\n\n\n    dispatch.of = function (thiz, argumentz) {\n      return function (e1) {\n        try {\n          var e0 = e1.sourceEvent = d3.event;\n          e1.target = target;\n          d3.event = e1;\n          dispatch[e1.type].apply(thiz, argumentz);\n        } finally {\n          d3.event = e0;\n        }\n      };\n    };\n\n    return dispatch;\n  }\n\n  d3.requote = function (s) {\n    return s.replace(d3_requote_re, \"\\\\$&\");\n  };\n\n  var d3_requote_re = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n  var d3_subclass = {}.__proto__ ? // Until ECMAScript supports array subclassing, prototype injection works well.\n  function (object, prototype) {\n    object.__proto__ = prototype;\n  } : // And if your browser doesn't support __proto__, we'll use direct extension.\n  function (object, prototype) {\n    for (var property in prototype) {\n      object[property] = prototype[property];\n    }\n  };\n\n  function d3_selection(groups) {\n    d3_subclass(groups, d3_selectionPrototype);\n    return groups;\n  }\n\n  var d3_select = function d3_select(s, n) {\n    return n.querySelector(s);\n  },\n      d3_selectAll = function d3_selectAll(s, n) {\n    return n.querySelectorAll(s);\n  },\n      d3_selectMatcher = d3_documentElement.matches || d3_documentElement[d3_vendorSymbol(d3_documentElement, \"matchesSelector\")],\n      d3_selectMatches = function d3_selectMatches(n, s) {\n    return d3_selectMatcher.call(n, s);\n  }; // Prefer Sizzle, if available.\n\n\n  if (typeof Sizzle === \"function\") {\n    d3_select = function d3_select(s, n) {\n      return Sizzle(s, n)[0] || null;\n    };\n\n    d3_selectAll = Sizzle;\n    d3_selectMatches = Sizzle.matchesSelector;\n  }\n\n  d3.selection = function () {\n    return d3_selectionRoot;\n  };\n\n  var d3_selectionPrototype = d3.selection.prototype = [];\n\n  d3_selectionPrototype.select = function (selector) {\n    var subgroups = [],\n        subgroup,\n        subnode,\n        group,\n        node;\n    selector = d3_selection_selector(selector);\n\n    for (var j = -1, m = this.length; ++j < m;) {\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = (group = this[j]).parentNode;\n\n      for (var i = -1, n = group.length; ++i < n;) {\n        if (node = group[i]) {\n          subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n          if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n\n    return d3_selection(subgroups);\n  };\n\n  function d3_selection_selector(selector) {\n    return typeof selector === \"function\" ? selector : function () {\n      return d3_select(selector, this);\n    };\n  }\n\n  d3_selectionPrototype.selectAll = function (selector) {\n    var subgroups = [],\n        subgroup,\n        node;\n    selector = d3_selection_selectorAll(selector);\n\n    for (var j = -1, m = this.length; ++j < m;) {\n      for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n        if (node = group[i]) {\n          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n          subgroup.parentNode = node;\n        }\n      }\n    }\n\n    return d3_selection(subgroups);\n  };\n\n  function d3_selection_selectorAll(selector) {\n    return typeof selector === \"function\" ? selector : function () {\n      return d3_selectAll(selector, this);\n    };\n  }\n\n  var d3_nsPrefix = {\n    svg: \"http://www.w3.org/2000/svg\",\n    xhtml: \"http://www.w3.org/1999/xhtml\",\n    xlink: \"http://www.w3.org/1999/xlink\",\n    xml: \"http://www.w3.org/XML/1998/namespace\",\n    xmlns: \"http://www.w3.org/2000/xmlns/\"\n  };\n  d3.ns = {\n    prefix: d3_nsPrefix,\n    qualify: function qualify(name) {\n      var i = name.indexOf(\":\"),\n          prefix = name;\n\n      if (i >= 0) {\n        prefix = name.substring(0, i);\n        name = name.substring(i + 1);\n      }\n\n      return d3_nsPrefix.hasOwnProperty(prefix) ? {\n        space: d3_nsPrefix[prefix],\n        local: name\n      } : name;\n    }\n  };\n\n  d3_selectionPrototype.attr = function (name, value) {\n    if (arguments.length < 2) {\n      // For attr(string), return the attribute value for the first node.\n      if (typeof name === \"string\") {\n        var node = this.node();\n        name = d3.ns.qualify(name);\n        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);\n      } // For attr(object), the object specifies the names and values of the\n      // attributes to set or remove. The values may be functions that are\n      // evaluated for each element.\n\n\n      for (value in name) {\n        this.each(d3_selection_attr(value, name[value]));\n      }\n\n      return this;\n    }\n\n    return this.each(d3_selection_attr(name, value));\n  };\n\n  function d3_selection_attr(name, value) {\n    name = d3.ns.qualify(name); // For attr(string, null), remove the attribute with the specified name.\n\n    function attrNull() {\n      this.removeAttribute(name);\n    }\n\n    function attrNullNS() {\n      this.removeAttributeNS(name.space, name.local);\n    } // For attr(string, string), set the attribute with the specified name.\n\n\n    function attrConstant() {\n      this.setAttribute(name, value);\n    }\n\n    function attrConstantNS() {\n      this.setAttributeNS(name.space, name.local, value);\n    } // For attr(string, function), evaluate the function for each element, and set\n    // or remove the attribute as appropriate.\n\n\n    function attrFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.removeAttribute(name);else this.setAttribute(name, x);\n    }\n\n    function attrFunctionNS() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.removeAttributeNS(name.space, name.local);else this.setAttributeNS(name.space, name.local, x);\n    }\n\n    return value == null ? name.local ? attrNullNS : attrNull : typeof value === \"function\" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;\n  }\n\n  function d3_collapse(s) {\n    return s.trim().replace(/\\s+/g, \" \");\n  }\n\n  d3_selectionPrototype.classed = function (name, value) {\n    if (arguments.length < 2) {\n      // For classed(string), return true only if the first node has the specified\n      // class or classes. Note that even if the browser supports DOMTokenList, it\n      // probably doesn't support it on SVG elements (which can be animated).\n      if (typeof name === \"string\") {\n        var node = this.node(),\n            n = (name = d3_selection_classes(name)).length,\n            i = -1;\n\n        if (value = node.classList) {\n          while (++i < n) {\n            if (!value.contains(name[i])) return false;\n          }\n        } else {\n          value = node.getAttribute(\"class\");\n\n          while (++i < n) {\n            if (!d3_selection_classedRe(name[i]).test(value)) return false;\n          }\n        }\n\n        return true;\n      } // For classed(object), the object specifies the names of classes to add or\n      // remove. The values may be functions that are evaluated for each element.\n\n\n      for (value in name) {\n        this.each(d3_selection_classed(value, name[value]));\n      }\n\n      return this;\n    } // Otherwise, both a name and a value are specified, and are handled as below.\n\n\n    return this.each(d3_selection_classed(name, value));\n  };\n\n  function d3_selection_classedRe(name) {\n    return new RegExp(\"(?:^|\\\\s+)\" + d3.requote(name) + \"(?:\\\\s+|$)\", \"g\");\n  }\n\n  function d3_selection_classes(name) {\n    return (name + \"\").trim().split(/^|\\s+/);\n  } // Multiple class names are allowed (e.g., \"foo bar\").\n\n\n  function d3_selection_classed(name, value) {\n    name = d3_selection_classes(name).map(d3_selection_classedName);\n    var n = name.length;\n\n    function classedConstant() {\n      var i = -1;\n\n      while (++i < n) {\n        name[i](this, value);\n      }\n    } // When the value is a function, the function is still evaluated only once per\n    // element even if there are multiple class names.\n\n\n    function classedFunction() {\n      var i = -1,\n          x = value.apply(this, arguments);\n\n      while (++i < n) {\n        name[i](this, x);\n      }\n    }\n\n    return typeof value === \"function\" ? classedFunction : classedConstant;\n  }\n\n  function d3_selection_classedName(name) {\n    var re = d3_selection_classedRe(name);\n    return function (node, value) {\n      if (c = node.classList) return value ? c.add(name) : c.remove(name);\n      var c = node.getAttribute(\"class\") || \"\";\n\n      if (value) {\n        re.lastIndex = 0;\n        if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n      } else {\n        node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n      }\n    };\n  }\n\n  d3_selectionPrototype.style = function (name, value, priority) {\n    var n = arguments.length;\n\n    if (n < 3) {\n      // For style(object) or style(object, string), the object specifies the\n      // names and values of the attributes to set or remove. The values may be\n      // functions that are evaluated for each element. The optional string\n      // specifies the priority.\n      if (typeof name !== \"string\") {\n        if (n < 2) value = \"\";\n\n        for (priority in name) {\n          this.each(d3_selection_style(priority, name[priority], value));\n        }\n\n        return this;\n      } // For style(string), return the computed style value for the first node.\n\n\n      if (n < 2) return d3_window.getComputedStyle(this.node(), null).getPropertyValue(name); // For style(string, string) or style(string, function), use the default\n      // priority. The priority is ignored for style(string, null).\n\n      priority = \"\";\n    } // Otherwise, a name, value and priority are specified, and handled as below.\n\n\n    return this.each(d3_selection_style(name, value, priority));\n  };\n\n  function d3_selection_style(name, value, priority) {\n    // For style(name, null) or style(name, null, priority), remove the style\n    // property with the specified name. The priority is ignored.\n    function styleNull() {\n      this.style.removeProperty(name);\n    } // For style(name, string) or style(name, string, priority), set the style\n    // property with the specified name, using the specified priority.\n\n\n    function styleConstant() {\n      this.style.setProperty(name, value, priority);\n    } // For style(name, function) or style(name, function, priority), evaluate the\n    // function for each element, and set or remove the style property as\n    // appropriate. When setting, use the specified priority.\n\n\n    function styleFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.style.removeProperty(name);else this.style.setProperty(name, x, priority);\n    }\n\n    return value == null ? styleNull : typeof value === \"function\" ? styleFunction : styleConstant;\n  }\n\n  d3_selectionPrototype.property = function (name, value) {\n    if (arguments.length < 2) {\n      // For property(string), return the property value for the first node.\n      if (typeof name === \"string\") return this.node()[name]; // For property(object), the object specifies the names and values of the\n      // properties to set or remove. The values may be functions that are\n      // evaluated for each element.\n\n      for (value in name) {\n        this.each(d3_selection_property(value, name[value]));\n      }\n\n      return this;\n    } // Otherwise, both a name and a value are specified, and are handled as below.\n\n\n    return this.each(d3_selection_property(name, value));\n  };\n\n  function d3_selection_property(name, value) {\n    // For property(name, null), remove the property with the specified name.\n    function propertyNull() {\n      delete this[name];\n    } // For property(name, string), set the property with the specified name.\n\n\n    function propertyConstant() {\n      this[name] = value;\n    } // For property(name, function), evaluate the function for each element, and\n    // set or remove the property as appropriate.\n\n\n    function propertyFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) delete this[name];else this[name] = x;\n    }\n\n    return value == null ? propertyNull : typeof value === \"function\" ? propertyFunction : propertyConstant;\n  }\n\n  d3_selectionPrototype.text = function (value) {\n    return arguments.length ? this.each(typeof value === \"function\" ? function () {\n      var v = value.apply(this, arguments);\n      this.textContent = v == null ? \"\" : v;\n    } : value == null ? function () {\n      this.textContent = \"\";\n    } : function () {\n      this.textContent = value;\n    }) : this.node().textContent;\n  };\n\n  d3_selectionPrototype.html = function (value) {\n    return arguments.length ? this.each(typeof value === \"function\" ? function () {\n      var v = value.apply(this, arguments);\n      this.innerHTML = v == null ? \"\" : v;\n    } : value == null ? function () {\n      this.innerHTML = \"\";\n    } : function () {\n      this.innerHTML = value;\n    }) : this.node().innerHTML;\n  };\n\n  d3_selectionPrototype.append = function (name) {\n    name = d3_selection_creator(name);\n    return this.select(function () {\n      return this.appendChild(name.apply(this, arguments));\n    });\n  };\n\n  function d3_selection_creator(name) {\n    return typeof name === \"function\" ? name : (name = d3.ns.qualify(name)).local ? function () {\n      return this.ownerDocument.createElementNS(name.space, name.local);\n    } : function () {\n      return this.ownerDocument.createElementNS(this.namespaceURI, name);\n    };\n  }\n\n  d3_selectionPrototype.insert = function (name, before) {\n    name = d3_selection_creator(name);\n    before = d3_selection_selector(before);\n    return this.select(function () {\n      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n    });\n  }; // TODO remove(selector)?\n  // TODO remove(node)?\n  // TODO remove(function)?\n\n\n  d3_selectionPrototype.remove = function () {\n    return this.each(function () {\n      var parent = this.parentNode;\n      if (parent) parent.removeChild(this);\n    });\n  };\n\n  d3_selectionPrototype.data = function (value, key) {\n    var i = -1,\n        n = this.length,\n        group,\n        node; // If no value is specified, return the first value.\n\n    if (!arguments.length) {\n      value = new Array(n = (group = this[0]).length);\n\n      while (++i < n) {\n        if (node = group[i]) {\n          value[i] = node.__data__;\n        }\n      }\n\n      return value;\n    }\n\n    function bind(group, groupData) {\n      var i,\n          n = group.length,\n          m = groupData.length,\n          n0 = Math.min(n, m),\n          updateNodes = new Array(m),\n          enterNodes = new Array(m),\n          exitNodes = new Array(n),\n          node,\n          nodeData;\n\n      if (key) {\n        var nodeByKeyValue = new d3_Map(),\n            dataByKeyValue = new d3_Map(),\n            keyValues = [],\n            keyValue;\n\n        for (i = -1; ++i < n;) {\n          keyValue = key.call(node = group[i], node.__data__, i);\n\n          if (nodeByKeyValue.has(keyValue)) {\n            exitNodes[i] = node; // duplicate selection key\n          } else {\n            nodeByKeyValue.set(keyValue, node);\n          }\n\n          keyValues.push(keyValue);\n        }\n\n        for (i = -1; ++i < m;) {\n          keyValue = key.call(groupData, nodeData = groupData[i], i);\n\n          if (node = nodeByKeyValue.get(keyValue)) {\n            updateNodes[i] = node;\n            node.__data__ = nodeData;\n          } else if (!dataByKeyValue.has(keyValue)) {\n            // no duplicate data key\n            enterNodes[i] = d3_selection_dataNode(nodeData);\n          }\n\n          dataByKeyValue.set(keyValue, nodeData);\n          nodeByKeyValue.remove(keyValue);\n        }\n\n        for (i = -1; ++i < n;) {\n          if (nodeByKeyValue.has(keyValues[i])) {\n            exitNodes[i] = group[i];\n          }\n        }\n      } else {\n        for (i = -1; ++i < n0;) {\n          node = group[i];\n          nodeData = groupData[i];\n\n          if (node) {\n            node.__data__ = nodeData;\n            updateNodes[i] = node;\n          } else {\n            enterNodes[i] = d3_selection_dataNode(nodeData);\n          }\n        }\n\n        for (; i < m; ++i) {\n          enterNodes[i] = d3_selection_dataNode(groupData[i]);\n        }\n\n        for (; i < n; ++i) {\n          exitNodes[i] = group[i];\n        }\n      }\n\n      enterNodes.update = updateNodes;\n      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;\n      enter.push(enterNodes);\n      update.push(updateNodes);\n      exit.push(exitNodes);\n    }\n\n    var enter = d3_selection_enter([]),\n        update = d3_selection([]),\n        exit = d3_selection([]);\n\n    if (typeof value === \"function\") {\n      while (++i < n) {\n        bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n      }\n    } else {\n      while (++i < n) {\n        bind(group = this[i], value);\n      }\n    }\n\n    update.enter = function () {\n      return enter;\n    };\n\n    update.exit = function () {\n      return exit;\n    };\n\n    return update;\n  };\n\n  function d3_selection_dataNode(data) {\n    return {\n      __data__: data\n    };\n  }\n\n  d3_selectionPrototype.datum = function (value) {\n    return arguments.length ? this.property(\"__data__\", value) : this.property(\"__data__\");\n  };\n\n  d3_selectionPrototype.filter = function (filter) {\n    var subgroups = [],\n        subgroup,\n        group,\n        node;\n    if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = (group = this[j]).parentNode;\n\n      for (var i = 0, n = group.length; i < n; i++) {\n        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n          subgroup.push(node);\n        }\n      }\n    }\n\n    return d3_selection(subgroups);\n  };\n\n  function d3_selection_filter(selector) {\n    return function () {\n      return d3_selectMatches(this, selector);\n    };\n  }\n\n  d3_selectionPrototype.order = function () {\n    for (var j = -1, m = this.length; ++j < m;) {\n      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n        if (node = group[i]) {\n          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n          next = node;\n        }\n      }\n    }\n\n    return this;\n  };\n\n  d3.ascending = d3_ascending;\n\n  function d3_ascending(a, b) {\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n  }\n\n  d3_selectionPrototype.sort = function (comparator) {\n    comparator = d3_selection_sortComparator.apply(this, arguments);\n\n    for (var j = -1, m = this.length; ++j < m;) {\n      this[j].sort(comparator);\n    }\n\n    return this.order();\n  };\n\n  function d3_selection_sortComparator(comparator) {\n    if (!arguments.length) comparator = d3_ascending;\n    return function (a, b) {\n      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n    };\n  }\n\n  d3_selectionPrototype.each = function (callback) {\n    return d3_selection_each(this, function (node, i, j) {\n      callback.call(node, node.__data__, i, j);\n    });\n  };\n\n  function d3_selection_each(groups, callback) {\n    for (var j = 0, m = groups.length; j < m; j++) {\n      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n        if (node = group[i]) callback(node, i, j);\n      }\n    }\n\n    return groups;\n  }\n\n  d3_selectionPrototype.call = function (callback) {\n    var args = d3_array(arguments);\n    callback.apply(args[0] = this, args);\n    return this;\n  };\n\n  d3_selectionPrototype.empty = function () {\n    return !this.node();\n  };\n\n  d3_selectionPrototype.node = function () {\n    for (var j = 0, m = this.length; j < m; j++) {\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        var node = group[i];\n        if (node) return node;\n      }\n    }\n\n    return null;\n  };\n\n  d3_selectionPrototype.size = function () {\n    var n = 0;\n    this.each(function () {\n      ++n;\n    });\n    return n;\n  };\n\n  function d3_selection_enter(selection) {\n    d3_subclass(selection, d3_selection_enterPrototype);\n    return selection;\n  }\n\n  var d3_selection_enterPrototype = [];\n  d3.selection.enter = d3_selection_enter;\n  d3.selection.enter.prototype = d3_selection_enterPrototype;\n  d3_selection_enterPrototype.append = d3_selectionPrototype.append;\n  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\n  d3_selection_enterPrototype.node = d3_selectionPrototype.node;\n  d3_selection_enterPrototype.call = d3_selectionPrototype.call;\n  d3_selection_enterPrototype.size = d3_selectionPrototype.size;\n\n  d3_selection_enterPrototype.select = function (selector) {\n    var subgroups = [],\n        subgroup,\n        subnode,\n        upgroup,\n        group,\n        node;\n\n    for (var j = -1, m = this.length; ++j < m;) {\n      upgroup = (group = this[j]).update;\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = group.parentNode;\n\n      for (var i = -1, n = group.length; ++i < n;) {\n        if (node = group[i]) {\n          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n          subnode.__data__ = node.__data__;\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n\n    return d3_selection(subgroups);\n  };\n\n  d3_selection_enterPrototype.insert = function (name, before) {\n    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n    return d3_selectionPrototype.insert.call(this, name, before);\n  };\n\n  function d3_selection_enterInsertBefore(enter) {\n    var i0, j0;\n    return function (d, i, j) {\n      var group = enter[j].update,\n          n = group.length,\n          node;\n      if (j != j0) j0 = j, i0 = 0;\n      if (i >= i0) i0 = i + 1;\n\n      while (!(node = group[i0]) && ++i0 < n) {\n        ;\n      }\n\n      return node;\n    };\n  } // import \"../transition/transition\";\n\n\n  d3_selectionPrototype.transition = function () {\n    var id = d3_transitionInheritId || ++d3_transitionId,\n        subgroups = [],\n        subgroup,\n        node,\n        transition = d3_transitionInherit || {\n      time: Date.now(),\n      ease: d3_ease_cubicInOut,\n      delay: 0,\n      duration: 250\n    };\n\n    for (var j = -1, m = this.length; ++j < m;) {\n      subgroups.push(subgroup = []);\n\n      for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n        if (node = group[i]) d3_transitionNode(node, i, id, transition);\n        subgroup.push(node);\n      }\n    }\n\n    return d3_transition(subgroups, id);\n  }; // import \"../transition/transition\";\n\n\n  d3_selectionPrototype.interrupt = function () {\n    return this.each(d3_selection_interrupt);\n  };\n\n  function d3_selection_interrupt() {\n    var lock = this.__transition__;\n    if (lock) ++lock.active;\n  } // TODO fast singleton implementation?\n\n\n  d3.select = function (node) {\n    var group = [typeof node === \"string\" ? d3_select(node, d3_document) : node];\n    group.parentNode = d3_documentElement;\n    return d3_selection([group]);\n  };\n\n  d3.selectAll = function (nodes) {\n    var group = d3_array(typeof nodes === \"string\" ? d3_selectAll(nodes, d3_document) : nodes);\n    group.parentNode = d3_documentElement;\n    return d3_selection([group]);\n  };\n\n  var d3_selectionRoot = d3.select(d3_documentElement);\n\n  d3_selectionPrototype.on = function (type, listener, capture) {\n    var n = arguments.length;\n\n    if (n < 3) {\n      // For on(object) or on(object, boolean), the object specifies the event\n      // types and listeners to add or remove. The optional boolean specifies\n      // whether the listener captures events.\n      if (typeof type !== \"string\") {\n        if (n < 2) listener = false;\n\n        for (capture in type) {\n          this.each(d3_selection_on(capture, type[capture], listener));\n        }\n\n        return this;\n      } // For on(string), return the listener for the first node.\n\n\n      if (n < 2) return (n = this.node()[\"__on\" + type]) && n._; // For on(string, function), use the default capture.\n\n      capture = false;\n    } // Otherwise, a type, listener and capture are specified, and handled as below.\n\n\n    return this.each(d3_selection_on(type, listener, capture));\n  };\n\n  function d3_selection_on(type, listener, capture) {\n    var name = \"__on\" + type,\n        i = type.indexOf(\".\"),\n        wrap = d3_selection_onListener;\n    if (i > 0) type = type.substring(0, i);\n    var filter = d3_selection_onFilters.get(type);\n    if (filter) type = filter, wrap = d3_selection_onFilter;\n\n    function onRemove() {\n      var l = this[name];\n\n      if (l) {\n        this.removeEventListener(type, l, l.$);\n        delete this[name];\n      }\n    }\n\n    function onAdd() {\n      var l = wrap(listener, d3_array(arguments));\n      onRemove.call(this);\n      this.addEventListener(type, this[name] = l, l.$ = capture);\n      l._ = listener;\n    }\n\n    function removeAll() {\n      var re = new RegExp(\"^__on([^.]+)\" + d3.requote(type) + \"$\"),\n          match;\n\n      for (var name in this) {\n        if (match = name.match(re)) {\n          var l = this[name];\n          this.removeEventListener(match[1], l, l.$);\n          delete this[name];\n        }\n      }\n    }\n\n    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;\n  }\n\n  var d3_selection_onFilters = d3.map({\n    mouseenter: \"mouseover\",\n    mouseleave: \"mouseout\"\n  });\n  d3_selection_onFilters.forEach(function (k) {\n    if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n  });\n\n  function d3_selection_onListener(listener, argumentz) {\n    return function (e) {\n      var o = d3.event; // Events can be reentrant (e.g., focus).\n\n      d3.event = e;\n      argumentz[0] = this.__data__;\n\n      try {\n        listener.apply(this, argumentz);\n      } finally {\n        d3.event = o;\n      }\n    };\n  }\n\n  function d3_selection_onFilter(listener, argumentz) {\n    var l = d3_selection_onListener(listener, argumentz);\n    return function (e) {\n      var target = this,\n          related = e.relatedTarget;\n\n      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {\n        l.call(target, e);\n      }\n    };\n  }\n\n  var d3_event_dragSelect = \"onselectstart\" in d3_document ? null : d3_vendorSymbol(d3_documentElement.style, \"userSelect\"),\n      d3_event_dragId = 0;\n\n  function d3_event_dragSuppress() {\n    var name = \".dragsuppress-\" + ++d3_event_dragId,\n        click = \"click\" + name,\n        w = d3.select(d3_window).on(\"touchmove\" + name, d3_eventPreventDefault).on(\"dragstart\" + name, d3_eventPreventDefault).on(\"selectstart\" + name, d3_eventPreventDefault);\n\n    if (d3_event_dragSelect) {\n      var style = d3_documentElement.style,\n          select = style[d3_event_dragSelect];\n      style[d3_event_dragSelect] = \"none\";\n    }\n\n    return function (suppressClick) {\n      w.on(name, null);\n      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;\n\n      if (suppressClick) {\n        // suppress the next click, but only if it’s immediate\n        var off = function off() {\n          w.on(click, null);\n        };\n\n        w.on(click, function () {\n          d3_eventPreventDefault();\n          off();\n        }, true);\n        setTimeout(off, 0);\n      }\n    };\n  }\n\n  d3.mouse = function (container) {\n    return d3_mousePoint(container, d3_eventSource());\n  }; // https://bugs.webkit.org/show_bug.cgi?id=44083\n\n\n  var d3_mouse_bug44083 = /WebKit/.test(d3_window.navigator.userAgent) ? -1 : 0;\n\n  function d3_mousePoint(container, e) {\n    if (e.changedTouches) e = e.changedTouches[0];\n    var svg = container.ownerSVGElement || container;\n\n    if (svg.createSVGPoint) {\n      var point = svg.createSVGPoint();\n\n      if (d3_mouse_bug44083 < 0 && (d3_window.scrollX || d3_window.scrollY)) {\n        svg = d3.select(\"body\").append(\"svg\").style({\n          position: \"absolute\",\n          top: 0,\n          left: 0,\n          margin: 0,\n          padding: 0,\n          border: \"none\"\n        }, \"important\");\n        var ctm = svg[0][0].getScreenCTM();\n        d3_mouse_bug44083 = !(ctm.f || ctm.e);\n        svg.remove();\n      }\n\n      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY;else point.x = e.clientX, point.y = e.clientY;\n      point = point.matrixTransform(container.getScreenCTM().inverse());\n      return [point.x, point.y];\n    }\n\n    var rect = container.getBoundingClientRect();\n    return [e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop];\n  }\n\n  ;\n\n  d3.touches = function (container, touches) {\n    if (arguments.length < 2) touches = d3_eventSource().touches;\n    return touches ? d3_array(touches).map(function (touch) {\n      var point = d3_mousePoint(container, touch);\n      point.identifier = touch.identifier;\n      return point;\n    }) : [];\n  };\n\n  d3.behavior = {};\n\n  d3.behavior.drag = function () {\n    var event = d3_eventDispatch(drag, \"drag\", \"dragstart\", \"dragend\"),\n        origin = null,\n        mousedown = dragstart(d3_noop, d3.mouse, d3_behavior_dragMouseSubject, \"mousemove\", \"mouseup\"),\n        touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_behavior_dragTouchSubject, \"touchmove\", \"touchend\");\n\n    function drag() {\n      this.on(\"mousedown.drag\", mousedown).on(\"touchstart.drag\", touchstart);\n    }\n\n    function dragstart(id, position, subject, move, end) {\n      return function () {\n        var that = this,\n            target = d3.event.target,\n            parent = that.parentNode,\n            dispatch = event.of(that, arguments),\n            dragged = 0,\n            dragId = id(),\n            dragName = \".drag\" + (dragId == null ? \"\" : \"-\" + dragId),\n            dragOffset,\n            dragSubject = d3.select(subject()).on(move + dragName, moved).on(end + dragName, ended),\n            dragRestore = d3_event_dragSuppress(),\n            position0 = position(parent, dragId);\n\n        if (origin) {\n          dragOffset = origin.apply(that, arguments);\n          dragOffset = [dragOffset.x - position0[0], dragOffset.y - position0[1]];\n        } else {\n          dragOffset = [0, 0];\n        }\n\n        dispatch({\n          type: \"dragstart\"\n        });\n\n        function moved() {\n          var position1 = position(parent, dragId),\n              dx,\n              dy;\n          if (!position1) return; // this touch didn’t move\n\n          dx = position1[0] - position0[0];\n          dy = position1[1] - position0[1];\n          dragged |= dx | dy;\n          position0 = position1;\n          dispatch({\n            type: \"drag\",\n            x: position1[0] + dragOffset[0],\n            y: position1[1] + dragOffset[1],\n            dx: dx,\n            dy: dy\n          });\n        }\n\n        function ended() {\n          if (!position(parent, dragId)) return; // this touch didn’t end\n\n          dragSubject.on(move + dragName, null).on(end + dragName, null);\n          dragRestore(dragged && d3.event.target === target);\n          dispatch({\n            type: \"dragend\"\n          });\n        }\n      };\n    }\n\n    drag.origin = function (x) {\n      if (!arguments.length) return origin;\n      origin = x;\n      return drag;\n    };\n\n    return d3.rebind(drag, event, \"on\");\n  }; // While it is possible to receive a touchstart event with more than one changed\n  // touch, the event is only shared by touches on the same target; for new\n  // touches targetting different elements, multiple touchstart events are\n  // received even when the touches start simultaneously. Since multiple touches\n  // cannot move the same target to different locations concurrently without\n  // tearing the fabric of spacetime, we allow the first touch to win.\n\n\n  function d3_behavior_dragTouchId() {\n    return d3.event.changedTouches[0].identifier;\n  }\n\n  function d3_behavior_dragTouchSubject() {\n    return d3.event.target;\n  }\n\n  function d3_behavior_dragMouseSubject() {\n    return d3_window;\n  }\n\n  function d3_functor(v) {\n    return typeof v === \"function\" ? v : function () {\n      return v;\n    };\n  }\n\n  d3.functor = d3_functor;\n\n  function d3_true() {\n    return true;\n  }\n\n  var d3_timer_queueHead,\n      d3_timer_queueTail,\n      d3_timer_interval,\n      // is an interval (or frame) active?\n  d3_timer_timeout,\n      // is a timeout active?\n  d3_timer_active,\n      // active timer object\n  d3_timer_frame = d3_window[d3_vendorSymbol(d3_window, \"requestAnimationFrame\")] || function (callback) {\n    setTimeout(callback, 17);\n  }; // The timer will continue to fire until callback returns true.\n\n\n  d3.timer = function (callback, delay, then) {\n    var n = arguments.length;\n    if (n < 2) delay = 0;\n    if (n < 3) then = Date.now(); // Add the callback to the tail of the queue.\n\n    var time = then + delay,\n        timer = {\n      c: callback,\n      t: time,\n      f: false,\n      n: null\n    };\n    if (d3_timer_queueTail) d3_timer_queueTail.n = timer;else d3_timer_queueHead = timer;\n    d3_timer_queueTail = timer; // Start animatin'!\n\n    if (!d3_timer_interval) {\n      d3_timer_timeout = clearTimeout(d3_timer_timeout);\n      d3_timer_interval = 1;\n      d3_timer_frame(d3_timer_step);\n    }\n  };\n\n  function d3_timer_step() {\n    var now = d3_timer_mark(),\n        delay = d3_timer_sweep() - now;\n\n    if (delay > 24) {\n      if (isFinite(delay)) {\n        clearTimeout(d3_timer_timeout);\n        d3_timer_timeout = setTimeout(d3_timer_step, delay);\n      }\n\n      d3_timer_interval = 0;\n    } else {\n      d3_timer_interval = 1;\n      d3_timer_frame(d3_timer_step);\n    }\n  }\n\n  d3.timer.flush = function () {\n    d3_timer_mark();\n    d3_timer_sweep();\n  };\n\n  function d3_timer_mark() {\n    var now = Date.now();\n    d3_timer_active = d3_timer_queueHead;\n\n    while (d3_timer_active) {\n      if (now >= d3_timer_active.t) d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t);\n      d3_timer_active = d3_timer_active.n;\n    }\n\n    return now;\n  } // Flush after callbacks to avoid concurrent queue modification.\n  // Returns the time of the earliest active timer, post-sweep.\n\n\n  function d3_timer_sweep() {\n    var t0,\n        t1 = d3_timer_queueHead,\n        time = Infinity;\n\n    while (t1) {\n      if (t1.f) {\n        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;\n      } else {\n        if (t1.t < time) time = t1.t;\n        t1 = (t0 = t1).n;\n      }\n    }\n\n    d3_timer_queueTail = t0;\n    return time;\n  }\n\n  function d3_identity(d) {\n    return d;\n  }\n\n  var π = Math.PI,\n      τ = 2 * π,\n      halfπ = π / 2,\n      ε = 1e-6,\n      ε2 = ε * ε,\n      d3_radians = π / 180,\n      d3_degrees = 180 / π;\n\n  function d3_sgn(x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0;\n  } // Returns the 2D cross product of AB and AC vectors, i.e., the z-component of\n  // the 3D cross product in a quadrant I Cartesian coordinate system (+x is\n  // right, +y is up). Returns a positive value if ABC is counter-clockwise,\n  // negative if clockwise, and zero if the points are collinear.\n\n\n  function d3_cross2d(a, b, c) {\n    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\n  }\n\n  function d3_acos(x) {\n    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);\n  }\n\n  function d3_asin(x) {\n    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);\n  }\n\n  function d3_sinh(x) {\n    return ((x = Math.exp(x)) - 1 / x) / 2;\n  }\n\n  function d3_cosh(x) {\n    return ((x = Math.exp(x)) + 1 / x) / 2;\n  }\n\n  function d3_tanh(x) {\n    return ((x = Math.exp(2 * x)) - 1) / (x + 1);\n  }\n\n  function d3_haversin(x) {\n    return (x = Math.sin(x / 2)) * x;\n  }\n\n  var d3_ease_default = function d3_ease_default() {\n    return d3_identity;\n  };\n\n  var d3_ease = d3.map({\n    linear: d3_ease_default,\n    poly: d3_ease_poly,\n    quad: function quad() {\n      return d3_ease_quad;\n    },\n    cubic: function cubic() {\n      return d3_ease_cubic;\n    },\n    sin: function sin() {\n      return d3_ease_sin;\n    },\n    exp: function exp() {\n      return d3_ease_exp;\n    },\n    circle: function circle() {\n      return d3_ease_circle;\n    },\n    elastic: d3_ease_elastic,\n    back: d3_ease_back,\n    bounce: function bounce() {\n      return d3_ease_bounce;\n    }\n  });\n  var d3_ease_mode = d3.map({\n    \"in\": d3_identity,\n    \"out\": d3_ease_reverse,\n    \"in-out\": d3_ease_reflect,\n    \"out-in\": function outIn(f) {\n      return d3_ease_reflect(d3_ease_reverse(f));\n    }\n  });\n\n  d3.ease = function (name) {\n    var i = name.indexOf(\"-\"),\n        t = i >= 0 ? name.substring(0, i) : name,\n        m = i >= 0 ? name.substring(i + 1) : \"in\";\n    t = d3_ease.get(t) || d3_ease_default;\n    m = d3_ease_mode.get(m) || d3_identity;\n    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));\n  };\n\n  function d3_ease_clamp(f) {\n    return function (t) {\n      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);\n    };\n  }\n\n  function d3_ease_reverse(f) {\n    return function (t) {\n      return 1 - f(1 - t);\n    };\n  }\n\n  function d3_ease_reflect(f) {\n    return function (t) {\n      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));\n    };\n  }\n\n  function d3_ease_quad(t) {\n    return t * t;\n  }\n\n  function d3_ease_cubic(t) {\n    return t * t * t;\n  } // Optimized clamp(reflect(poly(3))).\n\n\n  function d3_ease_cubicInOut(t) {\n    if (t <= 0) return 0;\n    if (t >= 1) return 1;\n    var t2 = t * t,\n        t3 = t2 * t;\n    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);\n  }\n\n  function d3_ease_poly(e) {\n    return function (t) {\n      return Math.pow(t, e);\n    };\n  }\n\n  function d3_ease_sin(t) {\n    return 1 - Math.cos(t * halfπ);\n  }\n\n  function d3_ease_exp(t) {\n    return Math.pow(2, 10 * (t - 1));\n  }\n\n  function d3_ease_circle(t) {\n    return 1 - Math.sqrt(1 - t * t);\n  }\n\n  function d3_ease_elastic(a, p) {\n    var s;\n    if (arguments.length < 2) p = 0.45;\n    if (arguments.length) s = p / τ * Math.asin(1 / a);else a = 1, s = p / 4;\n    return function (t) {\n      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);\n    };\n  }\n\n  function d3_ease_back(s) {\n    if (!s) s = 1.70158;\n    return function (t) {\n      return t * t * ((s + 1) * t - s);\n    };\n  }\n\n  function d3_ease_bounce(t) {\n    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;\n  }\n\n  function d3_transition(groups, id) {\n    d3_subclass(groups, d3_transitionPrototype);\n    groups.id = id; // Note: read-only!\n\n    return groups;\n  }\n\n  var d3_transitionPrototype = [],\n      d3_transitionId = 0,\n      d3_transitionInheritId,\n      d3_transitionInherit;\n  d3_transitionPrototype.call = d3_selectionPrototype.call;\n  d3_transitionPrototype.empty = d3_selectionPrototype.empty;\n  d3_transitionPrototype.node = d3_selectionPrototype.node;\n  d3_transitionPrototype.size = d3_selectionPrototype.size;\n\n  d3.transition = function (selection) {\n    return arguments.length ? d3_transitionInheritId ? selection.transition() : selection : d3_selectionRoot.transition();\n  };\n\n  d3.transition.prototype = d3_transitionPrototype;\n\n  d3_transitionPrototype.select = function (selector) {\n    var id = this.id,\n        subgroups = [],\n        subgroup,\n        subnode,\n        node;\n    selector = d3_selection_selector(selector);\n\n    for (var j = -1, m = this.length; ++j < m;) {\n      subgroups.push(subgroup = []);\n\n      for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {\n          if (\"__data__\" in node) subnode.__data__ = node.__data__;\n          d3_transitionNode(subnode, i, id, node.__transition__[id]);\n          subgroup.push(subnode);\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n\n    return d3_transition(subgroups, id);\n  };\n\n  d3_transitionPrototype.selectAll = function (selector) {\n    var id = this.id,\n        subgroups = [],\n        subgroup,\n        subnodes,\n        node,\n        subnode,\n        transition;\n    selector = d3_selection_selectorAll(selector);\n\n    for (var j = -1, m = this.length; ++j < m;) {\n      for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n        if (node = group[i]) {\n          transition = node.__transition__[id];\n          subnodes = selector.call(node, node.__data__, i, j);\n          subgroups.push(subgroup = []);\n\n          for (var k = -1, o = subnodes.length; ++k < o;) {\n            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, id, transition);\n            subgroup.push(subnode);\n          }\n        }\n      }\n    }\n\n    return d3_transition(subgroups, id);\n  };\n\n  d3_transitionPrototype.filter = function (filter) {\n    var subgroups = [],\n        subgroup,\n        group,\n        node;\n    if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n          subgroup.push(node);\n        }\n      }\n    }\n\n    return d3_transition(subgroups, this.id);\n  };\n\n  d3.color = d3_color;\n\n  function d3_color() {}\n\n  d3_color.prototype.toString = function () {\n    return this.rgb() + \"\";\n  };\n\n  d3.hsl = d3_hsl;\n\n  function d3_hsl(h, s, l) {\n    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse(\"\" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);\n  }\n\n  var d3_hslPrototype = d3_hsl.prototype = new d3_color();\n\n  d3_hslPrototype.brighter = function (k) {\n    k = Math.pow(0.7, arguments.length ? k : 1);\n    return new d3_hsl(this.h, this.s, this.l / k);\n  };\n\n  d3_hslPrototype.darker = function (k) {\n    k = Math.pow(0.7, arguments.length ? k : 1);\n    return new d3_hsl(this.h, this.s, k * this.l);\n  };\n\n  d3_hslPrototype.rgb = function () {\n    return d3_hsl_rgb(this.h, this.s, this.l);\n  };\n\n  function d3_hsl_rgb(h, s, l) {\n    var m1, m2;\n    /* Some simple corrections for h, s and l. */\n\n    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;\n    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;\n    l = l < 0 ? 0 : l > 1 ? 1 : l;\n    /* From FvD 13.37, CSS Color Module Level 3 */\n\n    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;\n    m1 = 2 * l - m2;\n\n    function v(h) {\n      if (h > 360) h -= 360;else if (h < 0) h += 360;\n      if (h < 60) return m1 + (m2 - m1) * h / 60;\n      if (h < 180) return m2;\n      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;\n      return m1;\n    }\n\n    function vv(h) {\n      return Math.round(v(h) * 255);\n    }\n\n    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));\n  }\n\n  d3.hcl = d3_hcl;\n\n  function d3_hcl(h, c, l) {\n    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);\n  }\n\n  var d3_hclPrototype = d3_hcl.prototype = new d3_color();\n\n  d3_hclPrototype.brighter = function (k) {\n    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));\n  };\n\n  d3_hclPrototype.darker = function (k) {\n    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));\n  };\n\n  d3_hclPrototype.rgb = function () {\n    return d3_hcl_lab(this.h, this.c, this.l).rgb();\n  };\n\n  function d3_hcl_lab(h, c, l) {\n    if (isNaN(h)) h = 0;\n    if (isNaN(c)) c = 0;\n    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);\n  }\n\n  d3.lab = d3_lab;\n\n  function d3_lab(l, a, b) {\n    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.l, l.c, l.h) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);\n  } // Corresponds roughly to RGB brighter/darker\n\n\n  var d3_lab_K = 18; // D65 standard referent\n\n  var d3_lab_X = 0.950470,\n      d3_lab_Y = 1,\n      d3_lab_Z = 1.088830;\n  var d3_labPrototype = d3_lab.prototype = new d3_color();\n\n  d3_labPrototype.brighter = function (k) {\n    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\n  };\n\n  d3_labPrototype.darker = function (k) {\n    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\n  };\n\n  d3_labPrototype.rgb = function () {\n    return d3_lab_rgb(this.l, this.a, this.b);\n  };\n\n  function d3_lab_rgb(l, a, b) {\n    var y = (l + 16) / 116,\n        x = y + a / 500,\n        z = y - b / 200;\n    x = d3_lab_xyz(x) * d3_lab_X;\n    y = d3_lab_xyz(y) * d3_lab_Y;\n    z = d3_lab_xyz(z) * d3_lab_Z;\n    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), d3_xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z), d3_xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z));\n  }\n\n  function d3_lab_hcl(l, a, b) {\n    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);\n  }\n\n  function d3_lab_xyz(x) {\n    return x > 0.206893034 ? x * x * x : (x - 4 / 29) / 7.787037;\n  }\n\n  function d3_xyz_lab(x) {\n    return x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;\n  }\n\n  function d3_xyz_rgb(r) {\n    return Math.round(255 * (r <= 0.00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055));\n  }\n\n  d3.rgb = d3_rgb;\n\n  function d3_rgb(r, g, b) {\n    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse(\"\" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);\n  }\n\n  function d3_rgbNumber(value) {\n    return new d3_rgb(value >> 16, value >> 8 & 0xff, value & 0xff);\n  }\n\n  function d3_rgbString(value) {\n    return d3_rgbNumber(value) + \"\";\n  }\n\n  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();\n\n  d3_rgbPrototype.brighter = function (k) {\n    k = Math.pow(0.7, arguments.length ? k : 1);\n    var r = this.r,\n        g = this.g,\n        b = this.b,\n        i = 30;\n    if (!r && !g && !b) return new d3_rgb(i, i, i);\n    if (r && r < i) r = i;\n    if (g && g < i) g = i;\n    if (b && b < i) b = i;\n    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));\n  };\n\n  d3_rgbPrototype.darker = function (k) {\n    k = Math.pow(0.7, arguments.length ? k : 1);\n    return new d3_rgb(k * this.r, k * this.g, k * this.b);\n  };\n\n  d3_rgbPrototype.hsl = function () {\n    return d3_rgb_hsl(this.r, this.g, this.b);\n  };\n\n  d3_rgbPrototype.toString = function () {\n    return \"#\" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);\n  };\n\n  function d3_rgb_hex(v) {\n    return v < 0x10 ? \"0\" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);\n  }\n\n  function d3_rgb_parse(format, rgb, hsl) {\n    var r = 0,\n        // red channel; int in [0, 255]\n    g = 0,\n        // green channel; int in [0, 255]\n    b = 0,\n        // blue channel; int in [0, 255]\n    m1,\n        // CSS color specification match\n    m2,\n        // CSS color specification type (e.g., rgb)\n    color;\n    /* Handle hsl, rgb. */\n\n    m1 = /([a-z]+)\\((.*)\\)/i.exec(format);\n\n    if (m1) {\n      m2 = m1[2].split(\",\");\n\n      switch (m1[1]) {\n        case \"hsl\":\n          {\n            return hsl(parseFloat(m2[0]), // degrees\n            parseFloat(m2[1]) / 100, // percentage\n            parseFloat(m2[2]) / 100 // percentage\n            );\n          }\n\n        case \"rgb\":\n          {\n            return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));\n          }\n      }\n    }\n    /* Named colors. */\n\n\n    if (color = d3_rgb_names.get(format)) return rgb(color.r, color.g, color.b);\n    /* Hexadecimal colors: #rgb and #rrggbb. */\n\n    if (format != null && format.charAt(0) === \"#\" && !isNaN(color = parseInt(format.substring(1), 16))) {\n      if (format.length === 4) {\n        r = (color & 0xf00) >> 4;\n        r = r >> 4 | r;\n        g = color & 0xf0;\n        g = g >> 4 | g;\n        b = color & 0xf;\n        b = b << 4 | b;\n      } else if (format.length === 7) {\n        r = (color & 0xff0000) >> 16;\n        g = (color & 0xff00) >> 8;\n        b = color & 0xff;\n      }\n    }\n\n    return rgb(r, g, b);\n  }\n\n  function d3_rgb_hsl(r, g, b) {\n    var min = Math.min(r /= 255, g /= 255, b /= 255),\n        max = Math.max(r, g, b),\n        d = max - min,\n        h,\n        s,\n        l = (max + min) / 2;\n\n    if (d) {\n      s = l < .5 ? d / (max + min) : d / (2 - max - min);\n      if (r == max) h = (g - b) / d + (g < b ? 6 : 0);else if (g == max) h = (b - r) / d + 2;else h = (r - g) / d + 4;\n      h *= 60;\n    } else {\n      h = NaN;\n      s = l > 0 && l < 1 ? 0 : h;\n    }\n\n    return new d3_hsl(h, s, l);\n  }\n\n  function d3_rgb_lab(r, g, b) {\n    r = d3_rgb_xyz(r);\n    g = d3_rgb_xyz(g);\n    b = d3_rgb_xyz(b);\n    var x = d3_xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / d3_lab_X),\n        y = d3_xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / d3_lab_Y),\n        z = d3_xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / d3_lab_Z);\n    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));\n  }\n\n  function d3_rgb_xyz(r) {\n    return (r /= 255) <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);\n  }\n\n  function d3_rgb_parseNumber(c) {\n    // either integer or percentage\n    var f = parseFloat(c);\n    return c.charAt(c.length - 1) === \"%\" ? Math.round(f * 2.55) : f;\n  }\n\n  var d3_rgb_names = d3.map({\n    aliceblue: 0xf0f8ff,\n    antiquewhite: 0xfaebd7,\n    aqua: 0x00ffff,\n    aquamarine: 0x7fffd4,\n    azure: 0xf0ffff,\n    beige: 0xf5f5dc,\n    bisque: 0xffe4c4,\n    black: 0x000000,\n    blanchedalmond: 0xffebcd,\n    blue: 0x0000ff,\n    blueviolet: 0x8a2be2,\n    brown: 0xa52a2a,\n    burlywood: 0xdeb887,\n    cadetblue: 0x5f9ea0,\n    chartreuse: 0x7fff00,\n    chocolate: 0xd2691e,\n    coral: 0xff7f50,\n    cornflowerblue: 0x6495ed,\n    cornsilk: 0xfff8dc,\n    crimson: 0xdc143c,\n    cyan: 0x00ffff,\n    darkblue: 0x00008b,\n    darkcyan: 0x008b8b,\n    darkgoldenrod: 0xb8860b,\n    darkgray: 0xa9a9a9,\n    darkgreen: 0x006400,\n    darkgrey: 0xa9a9a9,\n    darkkhaki: 0xbdb76b,\n    darkmagenta: 0x8b008b,\n    darkolivegreen: 0x556b2f,\n    darkorange: 0xff8c00,\n    darkorchid: 0x9932cc,\n    darkred: 0x8b0000,\n    darksalmon: 0xe9967a,\n    darkseagreen: 0x8fbc8f,\n    darkslateblue: 0x483d8b,\n    darkslategray: 0x2f4f4f,\n    darkslategrey: 0x2f4f4f,\n    darkturquoise: 0x00ced1,\n    darkviolet: 0x9400d3,\n    deeppink: 0xff1493,\n    deepskyblue: 0x00bfff,\n    dimgray: 0x696969,\n    dimgrey: 0x696969,\n    dodgerblue: 0x1e90ff,\n    firebrick: 0xb22222,\n    floralwhite: 0xfffaf0,\n    forestgreen: 0x228b22,\n    fuchsia: 0xff00ff,\n    gainsboro: 0xdcdcdc,\n    ghostwhite: 0xf8f8ff,\n    gold: 0xffd700,\n    goldenrod: 0xdaa520,\n    gray: 0x808080,\n    green: 0x008000,\n    greenyellow: 0xadff2f,\n    grey: 0x808080,\n    honeydew: 0xf0fff0,\n    hotpink: 0xff69b4,\n    indianred: 0xcd5c5c,\n    indigo: 0x4b0082,\n    ivory: 0xfffff0,\n    khaki: 0xf0e68c,\n    lavender: 0xe6e6fa,\n    lavenderblush: 0xfff0f5,\n    lawngreen: 0x7cfc00,\n    lemonchiffon: 0xfffacd,\n    lightblue: 0xadd8e6,\n    lightcoral: 0xf08080,\n    lightcyan: 0xe0ffff,\n    lightgoldenrodyellow: 0xfafad2,\n    lightgray: 0xd3d3d3,\n    lightgreen: 0x90ee90,\n    lightgrey: 0xd3d3d3,\n    lightpink: 0xffb6c1,\n    lightsalmon: 0xffa07a,\n    lightseagreen: 0x20b2aa,\n    lightskyblue: 0x87cefa,\n    lightslategray: 0x778899,\n    lightslategrey: 0x778899,\n    lightsteelblue: 0xb0c4de,\n    lightyellow: 0xffffe0,\n    lime: 0x00ff00,\n    limegreen: 0x32cd32,\n    linen: 0xfaf0e6,\n    magenta: 0xff00ff,\n    maroon: 0x800000,\n    mediumaquamarine: 0x66cdaa,\n    mediumblue: 0x0000cd,\n    mediumorchid: 0xba55d3,\n    mediumpurple: 0x9370db,\n    mediumseagreen: 0x3cb371,\n    mediumslateblue: 0x7b68ee,\n    mediumspringgreen: 0x00fa9a,\n    mediumturquoise: 0x48d1cc,\n    mediumvioletred: 0xc71585,\n    midnightblue: 0x191970,\n    mintcream: 0xf5fffa,\n    mistyrose: 0xffe4e1,\n    moccasin: 0xffe4b5,\n    navajowhite: 0xffdead,\n    navy: 0x000080,\n    oldlace: 0xfdf5e6,\n    olive: 0x808000,\n    olivedrab: 0x6b8e23,\n    orange: 0xffa500,\n    orangered: 0xff4500,\n    orchid: 0xda70d6,\n    palegoldenrod: 0xeee8aa,\n    palegreen: 0x98fb98,\n    paleturquoise: 0xafeeee,\n    palevioletred: 0xdb7093,\n    papayawhip: 0xffefd5,\n    peachpuff: 0xffdab9,\n    peru: 0xcd853f,\n    pink: 0xffc0cb,\n    plum: 0xdda0dd,\n    powderblue: 0xb0e0e6,\n    purple: 0x800080,\n    red: 0xff0000,\n    rosybrown: 0xbc8f8f,\n    royalblue: 0x4169e1,\n    saddlebrown: 0x8b4513,\n    salmon: 0xfa8072,\n    sandybrown: 0xf4a460,\n    seagreen: 0x2e8b57,\n    seashell: 0xfff5ee,\n    sienna: 0xa0522d,\n    silver: 0xc0c0c0,\n    skyblue: 0x87ceeb,\n    slateblue: 0x6a5acd,\n    slategray: 0x708090,\n    slategrey: 0x708090,\n    snow: 0xfffafa,\n    springgreen: 0x00ff7f,\n    steelblue: 0x4682b4,\n    tan: 0xd2b48c,\n    teal: 0x008080,\n    thistle: 0xd8bfd8,\n    tomato: 0xff6347,\n    turquoise: 0x40e0d0,\n    violet: 0xee82ee,\n    wheat: 0xf5deb3,\n    white: 0xffffff,\n    whitesmoke: 0xf5f5f5,\n    yellow: 0xffff00,\n    yellowgreen: 0x9acd32\n  });\n  d3_rgb_names.forEach(function (key, value) {\n    d3_rgb_names.set(key, d3_rgbNumber(value));\n  });\n  d3.interpolateRgb = d3_interpolateRgb;\n\n  function d3_interpolateRgb(a, b) {\n    a = d3.rgb(a);\n    b = d3.rgb(b);\n    var ar = a.r,\n        ag = a.g,\n        ab = a.b,\n        br = b.r - ar,\n        bg = b.g - ag,\n        bb = b.b - ab;\n    return function (t) {\n      return \"#\" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));\n    };\n  }\n\n  d3.interpolateObject = d3_interpolateObject;\n\n  function d3_interpolateObject(a, b) {\n    var i = {},\n        c = {},\n        k;\n\n    for (k in a) {\n      if (k in b) {\n        i[k] = d3_interpolate(a[k], b[k]);\n      } else {\n        c[k] = a[k];\n      }\n    }\n\n    for (k in b) {\n      if (!(k in a)) {\n        c[k] = b[k];\n      }\n    }\n\n    return function (t) {\n      for (k in i) {\n        c[k] = i[k](t);\n      }\n\n      return c;\n    };\n  }\n\n  d3.interpolateArray = d3_interpolateArray;\n\n  function d3_interpolateArray(a, b) {\n    var x = [],\n        c = [],\n        na = a.length,\n        nb = b.length,\n        n0 = Math.min(a.length, b.length),\n        i;\n\n    for (i = 0; i < n0; ++i) {\n      x.push(d3_interpolate(a[i], b[i]));\n    }\n\n    for (; i < na; ++i) {\n      c[i] = a[i];\n    }\n\n    for (; i < nb; ++i) {\n      c[i] = b[i];\n    }\n\n    return function (t) {\n      for (i = 0; i < n0; ++i) {\n        c[i] = x[i](t);\n      }\n\n      return c;\n    };\n  }\n\n  d3.interpolateNumber = d3_interpolateNumber;\n\n  function d3_interpolateNumber(a, b) {\n    b -= a = +a;\n    return function (t) {\n      return a + b * t;\n    };\n  }\n\n  d3.interpolateString = d3_interpolateString;\n\n  function d3_interpolateString(a, b) {\n    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0,\n        // scan index for next number in b\n    am,\n        // current match in a\n    bm,\n        // current match in b\n    bs,\n        // string preceding current number in b, if any\n    i = -1,\n        // index in s\n    s = [],\n        // string constants and placeholders\n    q = []; // number interpolators\n    // Coerce inputs to strings.\n\n    a = a + \"\", b = b + \"\"; // Interpolate pairs of numbers in a & b.\n\n    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {\n      if ((bs = bm.index) > bi) {\n        // a string precedes the next number in b\n        bs = b.substring(bi, bs);\n        if (s[i]) s[i] += bs; // coalesce with previous string\n        else s[++i] = bs;\n      }\n\n      if ((am = am[0]) === (bm = bm[0])) {\n        // numbers in a & b match\n        if (s[i]) s[i] += bm; // coalesce with previous string\n        else s[++i] = bm;\n      } else {\n        // interpolate non-matching numbers\n        s[++i] = null;\n        q.push({\n          i: i,\n          x: d3_interpolateNumber(am, bm)\n        });\n      }\n\n      bi = d3_interpolate_numberB.lastIndex;\n    } // Add remains of b.\n\n\n    if (bi < b.length) {\n      bs = b.substring(bi);\n      if (s[i]) s[i] += bs; // coalesce with previous string\n      else s[++i] = bs;\n    } // Special optimization for only a single match.\n    // Otherwise, interpolate each of the numbers and rejoin the string.\n\n\n    return s.length < 2 ? q[0] ? (b = q[0].x, function (t) {\n      return b(t) + \"\";\n    }) : function () {\n      return b;\n    } : (b = q.length, function (t) {\n      for (var i = 0, o; i < b; ++i) {\n        s[(o = q[i]).i] = o.x(t);\n      }\n\n      return s.join(\"\");\n    });\n  }\n\n  var d3_interpolate_numberA = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g,\n      d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, \"g\");\n  d3.interpolate = d3_interpolate;\n\n  function d3_interpolate(a, b) {\n    var i = d3.interpolators.length,\n        f;\n\n    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) {\n      ;\n    }\n\n    return f;\n  }\n\n  d3.interpolators = [function (a, b) {\n    var t = _typeof(b);\n\n    return (t === \"string\" ? d3_rgb_names.has(b) || /^(#|rgb\\(|hsl\\()/.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === \"object\" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);\n  }];\n\n  d3.transform = function (string) {\n    var g = d3_document.createElementNS(d3.ns.prefix.svg, \"g\");\n    return (d3.transform = function (string) {\n      if (string != null) {\n        g.setAttribute(\"transform\", string);\n        var t = g.transform.baseVal.consolidate();\n      }\n\n      return new d3_transform(t ? t.matrix : d3_transformIdentity);\n    })(string);\n  }; // Compute x-scale and normalize the first row.\n  // Compute shear and make second row orthogonal to first.\n  // Compute y-scale and normalize the second row.\n  // Finally, compute the rotation.\n\n\n  function d3_transform(m) {\n    var r0 = [m.a, m.b],\n        r1 = [m.c, m.d],\n        kx = d3_transformNormalize(r0),\n        kz = d3_transformDot(r0, r1),\n        ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;\n\n    if (r0[0] * r1[1] < r1[0] * r0[1]) {\n      r0[0] *= -1;\n      r0[1] *= -1;\n      kx *= -1;\n      kz *= -1;\n    }\n\n    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;\n    this.translate = [m.e, m.f];\n    this.scale = [kx, ky];\n    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;\n  }\n\n  ;\n\n  d3_transform.prototype.toString = function () {\n    return \"translate(\" + this.translate + \")rotate(\" + this.rotate + \")skewX(\" + this.skew + \")scale(\" + this.scale + \")\";\n  };\n\n  function d3_transformDot(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n  }\n\n  function d3_transformNormalize(a) {\n    var k = Math.sqrt(d3_transformDot(a, a));\n\n    if (k) {\n      a[0] /= k;\n      a[1] /= k;\n    }\n\n    return k;\n  }\n\n  function d3_transformCombine(a, b, k) {\n    a[0] += k * b[0];\n    a[1] += k * b[1];\n    return a;\n  }\n\n  var d3_transformIdentity = {\n    a: 1,\n    b: 0,\n    c: 0,\n    d: 1,\n    e: 0,\n    f: 0\n  };\n  d3.interpolateTransform = d3_interpolateTransform;\n\n  function d3_interpolateTransform(a, b) {\n    var s = [],\n        // string constants and placeholders\n    q = [],\n        // number interpolators\n    n,\n        A = d3.transform(a),\n        B = d3.transform(b),\n        ta = A.translate,\n        tb = B.translate,\n        ra = A.rotate,\n        rb = B.rotate,\n        wa = A.skew,\n        wb = B.skew,\n        ka = A.scale,\n        kb = B.scale;\n\n    if (ta[0] != tb[0] || ta[1] != tb[1]) {\n      s.push(\"translate(\", null, \",\", null, \")\");\n      q.push({\n        i: 1,\n        x: d3_interpolateNumber(ta[0], tb[0])\n      }, {\n        i: 3,\n        x: d3_interpolateNumber(ta[1], tb[1])\n      });\n    } else if (tb[0] || tb[1]) {\n      s.push(\"translate(\" + tb + \")\");\n    } else {\n      s.push(\"\");\n    }\n\n    if (ra != rb) {\n      if (ra - rb > 180) rb += 360;else if (rb - ra > 180) ra += 360; // shortest path\n\n      q.push({\n        i: s.push(s.pop() + \"rotate(\", null, \")\") - 2,\n        x: d3_interpolateNumber(ra, rb)\n      });\n    } else if (rb) {\n      s.push(s.pop() + \"rotate(\" + rb + \")\");\n    }\n\n    if (wa != wb) {\n      q.push({\n        i: s.push(s.pop() + \"skewX(\", null, \")\") - 2,\n        x: d3_interpolateNumber(wa, wb)\n      });\n    } else if (wb) {\n      s.push(s.pop() + \"skewX(\" + wb + \")\");\n    }\n\n    if (ka[0] != kb[0] || ka[1] != kb[1]) {\n      n = s.push(s.pop() + \"scale(\", null, \",\", null, \")\");\n      q.push({\n        i: n - 4,\n        x: d3_interpolateNumber(ka[0], kb[0])\n      }, {\n        i: n - 2,\n        x: d3_interpolateNumber(ka[1], kb[1])\n      });\n    } else if (kb[0] != 1 || kb[1] != 1) {\n      s.push(s.pop() + \"scale(\" + kb + \")\");\n    }\n\n    n = q.length;\n    return function (t) {\n      var i = -1,\n          o;\n\n      while (++i < n) {\n        s[(o = q[i]).i] = o.x(t);\n      }\n\n      return s.join(\"\");\n    };\n  }\n\n  d3_transitionPrototype.tween = function (name, tween) {\n    var id = this.id;\n    if (arguments.length < 2) return this.node().__transition__[id].tween.get(name);\n    return d3_selection_each(this, tween == null ? function (node) {\n      node.__transition__[id].tween.remove(name);\n    } : function (node) {\n      node.__transition__[id].tween.set(name, tween);\n    });\n  };\n\n  function d3_transition_tween(groups, name, value, tween) {\n    var id = groups.id;\n    return d3_selection_each(groups, typeof value === \"function\" ? function (node, i, j) {\n      node.__transition__[id].tween.set(name, tween(value.call(node, node.__data__, i, j)));\n    } : (value = tween(value), function (node) {\n      node.__transition__[id].tween.set(name, value);\n    }));\n  }\n\n  d3_transitionPrototype.attr = function (nameNS, value) {\n    if (arguments.length < 2) {\n      // For attr(object), the object specifies the names and values of the\n      // attributes to transition. The values may be functions that are\n      // evaluated for each element.\n      for (value in nameNS) {\n        this.attr(value, nameNS[value]);\n      }\n\n      return this;\n    }\n\n    var interpolate = nameNS == \"transform\" ? d3_interpolateTransform : d3_interpolate,\n        name = d3.ns.qualify(nameNS); // For attr(string, null), remove the attribute with the specified name.\n\n    function attrNull() {\n      this.removeAttribute(name);\n    }\n\n    function attrNullNS() {\n      this.removeAttributeNS(name.space, name.local);\n    } // For attr(string, string), set the attribute with the specified name.\n\n\n    function attrTween(b) {\n      return b == null ? attrNull : (b += \"\", function () {\n        var a = this.getAttribute(name),\n            i;\n        return a !== b && (i = interpolate(a, b), function (t) {\n          this.setAttribute(name, i(t));\n        });\n      });\n    }\n\n    function attrTweenNS(b) {\n      return b == null ? attrNullNS : (b += \"\", function () {\n        var a = this.getAttributeNS(name.space, name.local),\n            i;\n        return a !== b && (i = interpolate(a, b), function (t) {\n          this.setAttributeNS(name.space, name.local, i(t));\n        });\n      });\n    }\n\n    return d3_transition_tween(this, \"attr.\" + nameNS, value, name.local ? attrTweenNS : attrTween);\n  };\n\n  d3_transitionPrototype.attrTween = function (nameNS, tween) {\n    var name = d3.ns.qualify(nameNS);\n\n    function attrTween(d, i) {\n      var f = tween.call(this, d, i, this.getAttribute(name));\n      return f && function (t) {\n        this.setAttribute(name, f(t));\n      };\n    }\n\n    function attrTweenNS(d, i) {\n      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));\n      return f && function (t) {\n        this.setAttributeNS(name.space, name.local, f(t));\n      };\n    }\n\n    return this.tween(\"attr.\" + nameNS, name.local ? attrTweenNS : attrTween);\n  };\n\n  d3_transitionPrototype.style = function (name, value, priority) {\n    var n = arguments.length;\n\n    if (n < 3) {\n      // For style(object) or style(object, string), the object specifies the\n      // names and values of the attributes to set or remove. The values may be\n      // functions that are evaluated for each element. The optional string\n      // specifies the priority.\n      if (typeof name !== \"string\") {\n        if (n < 2) value = \"\";\n\n        for (priority in name) {\n          this.style(priority, name[priority], value);\n        }\n\n        return this;\n      } // For style(string, string) or style(string, function), use the default\n      // priority. The priority is ignored for style(string, null).\n\n\n      priority = \"\";\n    } // For style(name, null) or style(name, null, priority), remove the style\n    // property with the specified name. The priority is ignored.\n\n\n    function styleNull() {\n      this.style.removeProperty(name);\n    } // For style(name, string) or style(name, string, priority), set the style\n    // property with the specified name, using the specified priority.\n    // Otherwise, a name, value and priority are specified, and handled as below.\n\n\n    function styleString(b) {\n      return b == null ? styleNull : (b += \"\", function () {\n        var a = d3_window.getComputedStyle(this, null).getPropertyValue(name),\n            i;\n        return a !== b && (i = d3_interpolate(a, b), function (t) {\n          this.style.setProperty(name, i(t), priority);\n        });\n      });\n    }\n\n    return d3_transition_tween(this, \"style.\" + name, value, styleString);\n  };\n\n  d3_transitionPrototype.styleTween = function (name, tween, priority) {\n    if (arguments.length < 3) priority = \"\";\n\n    function styleTween(d, i) {\n      var f = tween.call(this, d, i, d3_window.getComputedStyle(this, null).getPropertyValue(name));\n      return f && function (t) {\n        this.style.setProperty(name, f(t), priority);\n      };\n    }\n\n    return this.tween(\"style.\" + name, styleTween);\n  };\n\n  d3_transitionPrototype.text = function (value) {\n    return d3_transition_tween(this, \"text\", value, d3_transition_text);\n  };\n\n  function d3_transition_text(b) {\n    if (b == null) b = \"\";\n    return function () {\n      this.textContent = b;\n    };\n  }\n\n  d3_transitionPrototype.remove = function () {\n    return this.each(\"end.transition\", function () {\n      var p;\n      if (this.__transition__.count < 2 && (p = this.parentNode)) p.removeChild(this);\n    });\n  };\n\n  d3_transitionPrototype.ease = function (value) {\n    var id = this.id;\n    if (arguments.length < 1) return this.node().__transition__[id].ease;\n    if (typeof value !== \"function\") value = d3.ease.apply(d3, arguments);\n    return d3_selection_each(this, function (node) {\n      node.__transition__[id].ease = value;\n    });\n  };\n\n  d3_transitionPrototype.delay = function (value) {\n    var id = this.id;\n    if (arguments.length < 1) return this.node().__transition__[id].delay;\n    return d3_selection_each(this, typeof value === \"function\" ? function (node, i, j) {\n      node.__transition__[id].delay = +value.call(node, node.__data__, i, j);\n    } : (value = +value, function (node) {\n      node.__transition__[id].delay = value;\n    }));\n  };\n\n  d3_transitionPrototype.duration = function (value) {\n    var id = this.id;\n    if (arguments.length < 1) return this.node().__transition__[id].duration;\n    return d3_selection_each(this, typeof value === \"function\" ? function (node, i, j) {\n      node.__transition__[id].duration = Math.max(1, value.call(node, node.__data__, i, j));\n    } : (value = Math.max(1, value), function (node) {\n      node.__transition__[id].duration = value;\n    }));\n  };\n\n  d3_transitionPrototype.transition = function () {\n    var id0 = this.id,\n        id1 = ++d3_transitionId,\n        subgroups = [],\n        subgroup,\n        group,\n        node,\n        transition;\n\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        if (node = group[i]) {\n          transition = Object.create(node.__transition__[id0]);\n          transition.delay += transition.duration;\n          d3_transitionNode(node, i, id1, transition);\n        }\n\n        subgroup.push(node);\n      }\n    }\n\n    return d3_transition(subgroups, id1);\n  };\n\n  function d3_transitionNode(node, i, id, inherit) {\n    var lock = node.__transition__ || (node.__transition__ = {\n      active: 0,\n      count: 0\n    }),\n        transition = lock[id];\n\n    if (!transition) {\n      var time = inherit.time;\n      transition = lock[id] = {\n        tween: new d3_Map(),\n        time: time,\n        ease: inherit.ease,\n        delay: inherit.delay,\n        duration: inherit.duration\n      };\n      ++lock.count;\n      d3.timer(function (elapsed) {\n        var d = node.__data__,\n            ease = transition.ease,\n            delay = transition.delay,\n            duration = transition.duration,\n            timer = d3_timer_active,\n            tweened = [];\n        timer.t = delay + time;\n        if (delay <= elapsed) return start(elapsed - delay);\n        timer.c = start;\n\n        function start(elapsed) {\n          if (lock.active > id) return stop();\n          lock.active = id;\n          transition.event && transition.event.start.call(node, d, i);\n          transition.tween.forEach(function (key, value) {\n            if (value = value.call(node, d, i)) {\n              tweened.push(value);\n            }\n          });\n          d3.timer(function () {\n            // defer to end of current frame\n            timer.c = tick(elapsed || 1) ? d3_true : tick;\n            return 1;\n          }, 0, time);\n        }\n\n        function tick(elapsed) {\n          if (lock.active !== id) return stop();\n          var t = elapsed / duration,\n              e = ease(t),\n              n = tweened.length;\n\n          while (n > 0) {\n            tweened[--n].call(node, e);\n          }\n\n          if (t >= 1) {\n            transition.event && transition.event.end.call(node, d, i);\n            return stop();\n          }\n        }\n\n        function stop() {\n          if (--lock.count) delete lock[id];else delete node.__transition__;\n          return 1;\n        }\n      }, 0, time);\n    }\n  }\n\n  d3_transitionPrototype.each = function (type, listener) {\n    var id = this.id;\n\n    if (arguments.length < 2) {\n      var inherit = d3_transitionInherit,\n          inheritId = d3_transitionInheritId;\n      d3_transitionInheritId = id;\n      d3_selection_each(this, function (node, i, j) {\n        d3_transitionInherit = node.__transition__[id];\n        type.call(node, node.__data__, i, j);\n      });\n      d3_transitionInherit = inherit;\n      d3_transitionInheritId = inheritId;\n    } else {\n      d3_selection_each(this, function (node) {\n        var transition = node.__transition__[id];\n        (transition.event || (transition.event = d3.dispatch(\"start\", \"end\"))).on(type, listener);\n      });\n    }\n\n    return this;\n  };\n\n  d3.xhr = d3_xhrType(d3_identity);\n\n  function d3_xhrType(response) {\n    return function (url, mimeType, callback) {\n      if (arguments.length === 2 && typeof mimeType === \"function\") callback = mimeType, mimeType = null;\n      return d3_xhr(url, mimeType, response, callback);\n    };\n  }\n\n  function d3_xhr(url, mimeType, response, callback) {\n    var xhr = {},\n        dispatch = d3.dispatch(\"beforesend\", \"progress\", \"load\", \"error\"),\n        headers = {},\n        request = new XMLHttpRequest(),\n        responseType = null; // If IE does not support CORS, use XDomainRequest.\n\n    if (d3_window.XDomainRequest && !(\"withCredentials\" in request) && /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest();\n    \"onload\" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function () {\n      request.readyState > 3 && respond();\n    };\n\n    function respond() {\n      var status = request.status,\n          result;\n\n      if (!status && request.responseText || status >= 200 && status < 300 || status === 304) {\n        try {\n          result = response.call(xhr, request);\n        } catch (e) {\n          dispatch.error.call(xhr, e);\n          return;\n        }\n\n        dispatch.load.call(xhr, result);\n      } else {\n        dispatch.error.call(xhr, request);\n      }\n    }\n\n    request.onprogress = function (event) {\n      var o = d3.event;\n      d3.event = event;\n\n      try {\n        dispatch.progress.call(xhr, request);\n      } finally {\n        d3.event = o;\n      }\n    };\n\n    xhr.header = function (name, value) {\n      name = (name + \"\").toLowerCase();\n      if (arguments.length < 2) return headers[name];\n      if (value == null) delete headers[name];else headers[name] = value + \"\";\n      return xhr;\n    }; // If mimeType is non-null and no Accept header is set, a default is used.\n\n\n    xhr.mimeType = function (value) {\n      if (!arguments.length) return mimeType;\n      mimeType = value == null ? null : value + \"\";\n      return xhr;\n    }; // Specifies what type the response value should take;\n    // for instance, arraybuffer, blob, document, or text.\n\n\n    xhr.responseType = function (value) {\n      if (!arguments.length) return responseType;\n      responseType = value;\n      return xhr;\n    }; // Specify how to convert the response content to a specific type;\n    // changes the callback value on \"load\" events.\n\n\n    xhr.response = function (value) {\n      response = value;\n      return xhr;\n    }; // Convenience methods.\n\n\n    [\"get\", \"post\"].forEach(function (method) {\n      xhr[method] = function () {\n        return xhr.send.apply(xhr, [method].concat(d3_array(arguments)));\n      };\n    }); // If callback is non-null, it will be used for error and load events.\n\n    xhr.send = function (method, data, callback) {\n      if (arguments.length === 2 && typeof data === \"function\") callback = data, data = null;\n      request.open(method, url, true);\n      if (mimeType != null && !(\"accept\" in headers)) headers[\"accept\"] = mimeType + \",*/*\";\n      if (request.setRequestHeader) for (var name in headers) {\n        request.setRequestHeader(name, headers[name]);\n      }\n      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);\n      if (responseType != null) request.responseType = responseType;\n      if (callback != null) xhr.on(\"error\", callback).on(\"load\", function (request) {\n        callback(null, request);\n      });\n      dispatch.beforesend.call(xhr, request);\n      request.send(data == null ? null : data);\n      return xhr;\n    };\n\n    xhr.abort = function () {\n      request.abort();\n      return xhr;\n    };\n\n    d3.rebind(xhr, dispatch, \"on\");\n    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));\n  }\n\n  ;\n\n  function d3_xhr_fixCallback(callback) {\n    return callback.length === 1 ? function (error, request) {\n      callback(error == null ? request : null);\n    } : callback;\n  }\n\n  d3.json = function (url, callback) {\n    return d3_xhr(url, \"application/json\", d3_json, callback);\n  };\n\n  function d3_json(request) {\n    return JSON.parse(request.responseText);\n  }\n\n  var d3_time = d3.time = {},\n      d3_date = Date;\n\n  function d3_date_utc() {\n    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);\n  }\n\n  d3_date_utc.prototype = {\n    getDate: function getDate() {\n      return this._.getUTCDate();\n    },\n    getDay: function getDay() {\n      return this._.getUTCDay();\n    },\n    getFullYear: function getFullYear() {\n      return this._.getUTCFullYear();\n    },\n    getHours: function getHours() {\n      return this._.getUTCHours();\n    },\n    getMilliseconds: function getMilliseconds() {\n      return this._.getUTCMilliseconds();\n    },\n    getMinutes: function getMinutes() {\n      return this._.getUTCMinutes();\n    },\n    getMonth: function getMonth() {\n      return this._.getUTCMonth();\n    },\n    getSeconds: function getSeconds() {\n      return this._.getUTCSeconds();\n    },\n    getTime: function getTime() {\n      return this._.getTime();\n    },\n    getTimezoneOffset: function getTimezoneOffset() {\n      return 0;\n    },\n    valueOf: function valueOf() {\n      return this._.valueOf();\n    },\n    setDate: function setDate() {\n      d3_time_prototype.setUTCDate.apply(this._, arguments);\n    },\n    setDay: function setDay() {\n      d3_time_prototype.setUTCDay.apply(this._, arguments);\n    },\n    setFullYear: function setFullYear() {\n      d3_time_prototype.setUTCFullYear.apply(this._, arguments);\n    },\n    setHours: function setHours() {\n      d3_time_prototype.setUTCHours.apply(this._, arguments);\n    },\n    setMilliseconds: function setMilliseconds() {\n      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);\n    },\n    setMinutes: function setMinutes() {\n      d3_time_prototype.setUTCMinutes.apply(this._, arguments);\n    },\n    setMonth: function setMonth() {\n      d3_time_prototype.setUTCMonth.apply(this._, arguments);\n    },\n    setSeconds: function setSeconds() {\n      d3_time_prototype.setUTCSeconds.apply(this._, arguments);\n    },\n    setTime: function setTime() {\n      d3_time_prototype.setTime.apply(this._, arguments);\n    }\n  };\n  var d3_time_prototype = Date.prototype;\n\n  function d3_format_precision(x, p) {\n    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);\n  }\n\n  d3.round = function (x, n) {\n    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);\n  };\n\n  var d3_formatPrefixes = [\"y\", \"z\", \"a\", \"f\", \"p\", \"n\", \"µ\", \"m\", \"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\"].map(d3_formatPrefix);\n\n  d3.formatPrefix = function (value, precision) {\n    var i = 0;\n\n    if (value) {\n      if (value < 0) value *= -1;\n      if (precision) value = d3.round(value, d3_format_precision(value, precision));\n      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\n      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));\n    }\n\n    return d3_formatPrefixes[8 + i / 3];\n  };\n\n  function d3_formatPrefix(d, i) {\n    var k = Math.pow(10, abs(8 - i) * 3);\n    return {\n      scale: i > 8 ? function (d) {\n        return d / k;\n      } : function (d) {\n        return d * k;\n      },\n      symbol: d\n    };\n  }\n\n  function d3_locale_numberFormat(locale) {\n    var locale_decimal = locale.decimal,\n        locale_thousands = locale.thousands,\n        locale_grouping = locale.grouping,\n        locale_currency = locale.currency,\n        formatGroup = locale_grouping ? function (value) {\n      var i = value.length,\n          t = [],\n          j = 0,\n          g = locale_grouping[0];\n\n      while (i > 0 && g > 0) {\n        t.push(value.substring(i -= g, i + g));\n        g = locale_grouping[j = (j + 1) % locale_grouping.length];\n      }\n\n      return t.reverse().join(locale_thousands);\n    } : d3_identity;\n    return function (specifier) {\n      var match = d3_format_re.exec(specifier),\n          fill = match[1] || \" \",\n          align = match[2] || \">\",\n          sign = match[3] || \"\",\n          symbol = match[4] || \"\",\n          zfill = match[5],\n          width = +match[6],\n          comma = match[7],\n          precision = match[8],\n          type = match[9],\n          scale = 1,\n          prefix = \"\",\n          suffix = \"\",\n          integer = false;\n      if (precision) precision = +precision.substring(1);\n\n      if (zfill || fill === \"0\" && align === \"=\") {\n        zfill = fill = \"0\";\n        align = \"=\";\n        if (comma) width -= Math.floor((width - 1) / 4);\n      }\n\n      switch (type) {\n        case \"n\":\n          comma = true;\n          type = \"g\";\n          break;\n\n        case \"%\":\n          scale = 100;\n          suffix = \"%\";\n          type = \"f\";\n          break;\n\n        case \"p\":\n          scale = 100;\n          suffix = \"%\";\n          type = \"r\";\n          break;\n\n        case \"b\":\n        case \"o\":\n        case \"x\":\n        case \"X\":\n          if (symbol === \"#\") prefix = \"0\" + type.toLowerCase();\n\n        case \"c\":\n        case \"d\":\n          integer = true;\n          precision = 0;\n          break;\n\n        case \"s\":\n          scale = -1;\n          type = \"r\";\n          break;\n      }\n\n      if (symbol === \"$\") prefix = locale_currency[0], suffix = locale_currency[1]; // If no precision is specified for r, fallback to general notation.\n\n      if (type == \"r\" && !precision) type = \"g\"; // Ensure that the requested precision is in the supported range.\n\n      if (precision != null) {\n        if (type == \"g\") precision = Math.max(1, Math.min(21, precision));else if (type == \"e\" || type == \"f\") precision = Math.max(0, Math.min(20, precision));\n      }\n\n      type = d3_format_types.get(type) || d3_format_typeDefault;\n      var zcomma = zfill && comma;\n      return function (value) {\n        var fullSuffix = suffix; // Return the empty string for floats formatted as ints.\n\n        if (integer && value % 1) return \"\"; // Convert negative to positive, and record the sign prefix.\n\n        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, \"-\") : sign; // Apply the scale, computing it from the value's exponent for si format.\n        // Preserve the existing suffix, if any, such as the currency symbol.\n\n        if (scale < 0) {\n          var unit = d3.formatPrefix(value, precision);\n          value = unit.scale(value);\n          fullSuffix = unit.symbol + suffix;\n        } else {\n          value *= scale;\n        } // Convert to the desired precision.\n\n\n        value = type(value, precision); // Break the value into the integer part (before) and decimal part (after).\n\n        var i = value.lastIndexOf(\".\"),\n            before = i < 0 ? value : value.substring(0, i),\n            after = i < 0 ? \"\" : locale_decimal + value.substring(i + 1); // If the fill character is not \"0\", grouping is applied before padding.\n\n        if (!zfill && comma) before = formatGroup(before);\n        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length),\n            padding = length < width ? new Array(length = width - length + 1).join(fill) : \"\"; // If the fill character is \"0\", grouping is applied after padding.\n\n        if (zcomma) before = formatGroup(padding + before); // Apply prefix.\n\n        negative += prefix; // Rejoin integer and decimal parts.\n\n        value = before + after;\n        return (align === \"<\" ? negative + value + padding : align === \">\" ? padding + negative + value : align === \"^\" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;\n      };\n    };\n  } // [[fill]align][sign][symbol][0][width][,][.precision][type]\n\n\n  var d3_format_re = /(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?/i;\n  var d3_format_types = d3.map({\n    b: function b(x) {\n      return x.toString(2);\n    },\n    c: function c(x) {\n      return String.fromCharCode(x);\n    },\n    o: function o(x) {\n      return x.toString(8);\n    },\n    x: function x(_x) {\n      return _x.toString(16);\n    },\n    X: function X(x) {\n      return x.toString(16).toUpperCase();\n    },\n    g: function g(x, p) {\n      return x.toPrecision(p);\n    },\n    e: function e(x, p) {\n      return x.toExponential(p);\n    },\n    f: function f(x, p) {\n      return x.toFixed(p);\n    },\n    r: function r(x, p) {\n      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));\n    }\n  });\n\n  function d3_format_typeDefault(x) {\n    return x + \"\";\n  }\n\n  function d3_time_interval(local, step, number) {\n    function round(date) {\n      var d0 = local(date),\n          d1 = offset(d0, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    }\n\n    function ceil(date) {\n      step(date = local(new d3_date(date - 1)), 1);\n      return date;\n    }\n\n    function offset(date, k) {\n      step(date = new d3_date(+date), k);\n      return date;\n    }\n\n    function range(t0, t1, dt) {\n      var time = ceil(t0),\n          times = [];\n\n      if (dt > 1) {\n        while (time < t1) {\n          if (!(number(time) % dt)) times.push(new Date(+time));\n          step(time, 1);\n        }\n      } else {\n        while (time < t1) {\n          times.push(new Date(+time)), step(time, 1);\n        }\n      }\n\n      return times;\n    }\n\n    function range_utc(t0, t1, dt) {\n      try {\n        d3_date = d3_date_utc;\n        var utc = new d3_date_utc();\n        utc._ = t0;\n        return range(utc, t1, dt);\n      } finally {\n        d3_date = Date;\n      }\n    }\n\n    local.floor = local;\n    local.round = round;\n    local.ceil = ceil;\n    local.offset = offset;\n    local.range = range;\n    var utc = local.utc = d3_time_interval_utc(local);\n    utc.floor = utc;\n    utc.round = d3_time_interval_utc(round);\n    utc.ceil = d3_time_interval_utc(ceil);\n    utc.offset = d3_time_interval_utc(offset);\n    utc.range = range_utc;\n    return local;\n  }\n\n  function d3_time_interval_utc(method) {\n    return function (date, k) {\n      try {\n        d3_date = d3_date_utc;\n        var utc = new d3_date_utc();\n        utc._ = date;\n        return method(utc, k)._;\n      } finally {\n        d3_date = Date;\n      }\n    };\n  }\n\n  d3_time.year = d3_time_interval(function (date) {\n    date = d3_time.day(date);\n    date.setMonth(0, 1);\n    return date;\n  }, function (date, offset) {\n    date.setFullYear(date.getFullYear() + offset);\n  }, function (date) {\n    return date.getFullYear();\n  });\n  d3_time.years = d3_time.year.range;\n  d3_time.years.utc = d3_time.year.utc.range;\n  d3_time.day = d3_time_interval(function (date) {\n    var day = new d3_date(2000, 0);\n    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n    return day;\n  }, function (date, offset) {\n    date.setDate(date.getDate() + offset);\n  }, function (date) {\n    return date.getDate() - 1;\n  });\n  d3_time.days = d3_time.day.range;\n  d3_time.days.utc = d3_time.day.utc.range;\n\n  d3_time.dayOfYear = function (date) {\n    var year = d3_time.year(date);\n    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);\n  };\n\n  [\"sunday\", \"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\"].forEach(function (day, i) {\n    i = 7 - i;\n    var interval = d3_time[day] = d3_time_interval(function (date) {\n      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);\n      return date;\n    }, function (date, offset) {\n      date.setDate(date.getDate() + Math.floor(offset) * 7);\n    }, function (date) {\n      var day = d3_time.year(date).getDay();\n      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);\n    });\n    d3_time[day + \"s\"] = interval.range;\n    d3_time[day + \"s\"].utc = interval.utc.range;\n\n    d3_time[day + \"OfYear\"] = function (date) {\n      var day = d3_time.year(date).getDay();\n      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);\n    };\n  });\n  d3_time.week = d3_time.sunday;\n  d3_time.weeks = d3_time.sunday.range;\n  d3_time.weeks.utc = d3_time.sunday.utc.range;\n  d3_time.weekOfYear = d3_time.sundayOfYear;\n\n  function d3_locale_timeFormat(locale) {\n    var locale_dateTime = locale.dateTime,\n        locale_date = locale.date,\n        locale_time = locale.time,\n        locale_periods = locale.periods,\n        locale_days = locale.days,\n        locale_shortDays = locale.shortDays,\n        locale_months = locale.months,\n        locale_shortMonths = locale.shortMonths;\n\n    function d3_time_format(template) {\n      var n = template.length;\n\n      function format(date) {\n        var string = [],\n            i = -1,\n            j = 0,\n            c,\n            p,\n            f;\n\n        while (++i < n) {\n          if (template.charCodeAt(i) === 37) {\n            string.push(template.substring(j, i));\n            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);\n            if (f = d3_time_formats[c]) c = f(date, p == null ? c === \"e\" ? \" \" : \"0\" : p);\n            string.push(c);\n            j = i + 1;\n          }\n        }\n\n        string.push(template.substring(j, i));\n        return string.join(\"\");\n      }\n\n      format.parse = function (string) {\n        var d = {\n          y: 1900,\n          m: 0,\n          d: 1,\n          H: 0,\n          M: 0,\n          S: 0,\n          L: 0,\n          Z: null\n        },\n            i = d3_time_parse(d, template, string, 0);\n        if (i != string.length) return null; // The am-pm flag is 0 for AM, and 1 for PM.\n\n        if (\"p\" in d) d.H = d.H % 12 + d.p * 12; // If a time zone is specified, it is always relative to UTC;\n        // we need to use d3_date_utc if we aren’t already.\n\n        var localZ = d.Z != null && d3_date !== d3_date_utc,\n            date = new (localZ ? d3_date_utc : d3_date)(); // Set year, month, date.\n\n        if (\"j\" in d) date.setFullYear(d.y, 0, d.j);else if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n          date.setFullYear(d.y, 0, 1);\n          date.setFullYear(d.y, 0, \"W\" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);\n        } else date.setFullYear(d.y, d.m, d.d); // Set hours, minutes, seconds and milliseconds.\n\n        date.setHours(d.H + Math.floor(d.Z / 100), d.M + d.Z % 100, d.S, d.L);\n        return localZ ? date._ : date;\n      };\n\n      format.toString = function () {\n        return template;\n      };\n\n      return format;\n    }\n\n    function d3_time_parse(date, template, string, j) {\n      var c,\n          p,\n          t,\n          i = 0,\n          n = template.length,\n          m = string.length;\n\n      while (i < n) {\n        if (j >= m) return -1;\n        c = template.charCodeAt(i++);\n\n        if (c === 37) {\n          t = template.charAt(i++);\n          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];\n          if (!p || (j = p(date, string, j)) < 0) return -1;\n        } else if (c != string.charCodeAt(j++)) {\n          return -1;\n        }\n      }\n\n      return j;\n    }\n\n    d3_time_format.utc = function (template) {\n      var local = d3_time_format(template);\n\n      function format(date) {\n        try {\n          d3_date = d3_date_utc;\n          var utc = new d3_date();\n          utc._ = date;\n          return local(utc);\n        } finally {\n          d3_date = Date;\n        }\n      }\n\n      format.parse = function (string) {\n        try {\n          d3_date = d3_date_utc;\n          var date = local.parse(string);\n          return date && date._;\n        } finally {\n          d3_date = Date;\n        }\n      };\n\n      format.toString = local.toString;\n      return format;\n    };\n\n    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;\n    var d3_time_periodLookup = d3.map(),\n        d3_time_dayRe = d3_time_formatRe(locale_days),\n        d3_time_dayLookup = d3_time_formatLookup(locale_days),\n        d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays),\n        d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays),\n        d3_time_monthRe = d3_time_formatRe(locale_months),\n        d3_time_monthLookup = d3_time_formatLookup(locale_months),\n        d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths),\n        d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);\n    locale_periods.forEach(function (p, i) {\n      d3_time_periodLookup.set(p.toLowerCase(), i);\n    });\n    var d3_time_formats = {\n      a: function a(d) {\n        return locale_shortDays[d.getDay()];\n      },\n      A: function A(d) {\n        return locale_days[d.getDay()];\n      },\n      b: function b(d) {\n        return locale_shortMonths[d.getMonth()];\n      },\n      B: function B(d) {\n        return locale_months[d.getMonth()];\n      },\n      c: d3_time_format(locale_dateTime),\n      d: function d(_d, p) {\n        return d3_time_formatPad(_d.getDate(), p, 2);\n      },\n      e: function e(d, p) {\n        return d3_time_formatPad(d.getDate(), p, 2);\n      },\n      H: function H(d, p) {\n        return d3_time_formatPad(d.getHours(), p, 2);\n      },\n      I: function I(d, p) {\n        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);\n      },\n      j: function j(d, p) {\n        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);\n      },\n      L: function L(d, p) {\n        return d3_time_formatPad(d.getMilliseconds(), p, 3);\n      },\n      m: function m(d, p) {\n        return d3_time_formatPad(d.getMonth() + 1, p, 2);\n      },\n      M: function M(d, p) {\n        return d3_time_formatPad(d.getMinutes(), p, 2);\n      },\n      p: function p(d) {\n        return locale_periods[+(d.getHours() >= 12)];\n      },\n      S: function S(d, p) {\n        return d3_time_formatPad(d.getSeconds(), p, 2);\n      },\n      U: function U(d, p) {\n        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);\n      },\n      w: function w(d) {\n        return d.getDay();\n      },\n      W: function W(d, p) {\n        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);\n      },\n      x: d3_time_format(locale_date),\n      X: d3_time_format(locale_time),\n      y: function y(d, p) {\n        return d3_time_formatPad(d.getFullYear() % 100, p, 2);\n      },\n      Y: function Y(d, p) {\n        return d3_time_formatPad(d.getFullYear() % 10000, p, 4);\n      },\n      Z: d3_time_zone,\n      \"%\": function _() {\n        return \"%\";\n      }\n    };\n    var d3_time_parsers = {\n      a: d3_time_parseWeekdayAbbrev,\n      A: d3_time_parseWeekday,\n      b: d3_time_parseMonthAbbrev,\n      B: d3_time_parseMonth,\n      c: d3_time_parseLocaleFull,\n      d: d3_time_parseDay,\n      e: d3_time_parseDay,\n      H: d3_time_parseHour24,\n      I: d3_time_parseHour24,\n      j: d3_time_parseDayOfYear,\n      L: d3_time_parseMilliseconds,\n      m: d3_time_parseMonthNumber,\n      M: d3_time_parseMinutes,\n      p: d3_time_parseAmPm,\n      S: d3_time_parseSeconds,\n      U: d3_time_parseWeekNumberSunday,\n      w: d3_time_parseWeekdayNumber,\n      W: d3_time_parseWeekNumberMonday,\n      x: d3_time_parseLocaleDate,\n      X: d3_time_parseLocaleTime,\n      y: d3_time_parseYear,\n      Y: d3_time_parseFullYear,\n      Z: d3_time_parseZone,\n      \"%\": d3_time_parseLiteralPercent\n    };\n\n    function d3_time_parseWeekdayAbbrev(date, string, i) {\n      d3_time_dayAbbrevRe.lastIndex = 0;\n      var n = d3_time_dayAbbrevRe.exec(string.substring(i));\n      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function d3_time_parseWeekday(date, string, i) {\n      d3_time_dayRe.lastIndex = 0;\n      var n = d3_time_dayRe.exec(string.substring(i));\n      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function d3_time_parseMonthAbbrev(date, string, i) {\n      d3_time_monthAbbrevRe.lastIndex = 0;\n      var n = d3_time_monthAbbrevRe.exec(string.substring(i));\n      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function d3_time_parseMonth(date, string, i) {\n      d3_time_monthRe.lastIndex = 0;\n      var n = d3_time_monthRe.exec(string.substring(i));\n      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function d3_time_parseLocaleFull(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);\n    }\n\n    function d3_time_parseLocaleDate(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);\n    }\n\n    function d3_time_parseLocaleTime(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);\n    }\n\n    function d3_time_parseAmPm(date, string, i) {\n      var n = d3_time_periodLookup.get(string.substring(i, i += 2).toLowerCase());\n      return n == null ? -1 : (date.p = n, i);\n    }\n\n    return d3_time_format;\n  }\n\n  var d3_time_formatPads = {\n    \"-\": \"\",\n    \"_\": \" \",\n    \"0\": \"0\"\n  },\n      d3_time_numberRe = /^\\s*\\d+/,\n      // note: ignores next directive\n  d3_time_percentRe = /^%/;\n\n  function d3_time_formatPad(value, fill, width) {\n    var sign = value < 0 ? \"-\" : \"\",\n        string = (sign ? -value : value) + \"\",\n        length = string.length;\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n  }\n\n  function d3_time_formatRe(names) {\n    return new RegExp(\"^(?:\" + names.map(d3.requote).join(\"|\") + \")\", \"i\");\n  }\n\n  function d3_time_formatLookup(names) {\n    var map = new d3_Map(),\n        i = -1,\n        n = names.length;\n\n    while (++i < n) {\n      map.set(names[i].toLowerCase(), i);\n    }\n\n    return map;\n  }\n\n  function d3_time_parseWeekdayNumber(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.substring(i, i + 1));\n    return n ? (date.w = +n[0], i + n[0].length) : -1;\n  }\n\n  function d3_time_parseWeekNumberSunday(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.substring(i));\n    return n ? (date.U = +n[0], i + n[0].length) : -1;\n  }\n\n  function d3_time_parseWeekNumberMonday(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.substring(i));\n    return n ? (date.W = +n[0], i + n[0].length) : -1;\n  }\n\n  function d3_time_parseFullYear(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.substring(i, i + 4));\n    return n ? (date.y = +n[0], i + n[0].length) : -1;\n  }\n\n  function d3_time_parseYear(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;\n  }\n\n  function d3_time_parseZone(date, string, i) {\n    return /^[+-]\\d{4}$/.test(string = string.substring(i, i + 5)) ? (date.Z = -string, i + 5 // sign differs from getTimezoneOffset!\n    ) : -1;\n  }\n\n  function d3_time_expandYear(d) {\n    return d + (d > 68 ? 1900 : 2000);\n  }\n\n  function d3_time_parseMonthNumber(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;\n  }\n\n  function d3_time_parseDay(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n    return n ? (date.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function d3_time_parseDayOfYear(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.substring(i, i + 3));\n    return n ? (date.j = +n[0], i + n[0].length) : -1;\n  } // Note: we don't validate that the hour is in the range [0,23] or [1,12].\n\n\n  function d3_time_parseHour24(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n    return n ? (date.H = +n[0], i + n[0].length) : -1;\n  }\n\n  function d3_time_parseMinutes(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n    return n ? (date.M = +n[0], i + n[0].length) : -1;\n  }\n\n  function d3_time_parseSeconds(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n    return n ? (date.S = +n[0], i + n[0].length) : -1;\n  }\n\n  function d3_time_parseMilliseconds(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.substring(i, i + 3));\n    return n ? (date.L = +n[0], i + n[0].length) : -1;\n  } // TODO table of time zone offset names?\n\n\n  function d3_time_zone(d) {\n    var z = d.getTimezoneOffset(),\n        zs = z > 0 ? \"-\" : \"+\",\n        zh = ~~(abs(z) / 60),\n        zm = abs(z) % 60;\n    return zs + d3_time_formatPad(zh, \"0\", 2) + d3_time_formatPad(zm, \"0\", 2);\n  }\n\n  function d3_time_parseLiteralPercent(date, string, i) {\n    d3_time_percentRe.lastIndex = 0;\n    var n = d3_time_percentRe.exec(string.substring(i, i + 1));\n    return n ? i + n[0].length : -1;\n  }\n\n  function d3_time_formatMulti(formats) {\n    var n = formats.length,\n        i = -1;\n\n    while (++i < n) {\n      formats[i][0] = this(formats[i][0]);\n    }\n\n    return function (date) {\n      var i = 0,\n          f = formats[i];\n\n      while (!f[1](date)) {\n        f = formats[++i];\n      }\n\n      return f[0](date);\n    };\n  }\n\n  d3.locale = function (locale) {\n    return {\n      numberFormat: d3_locale_numberFormat(locale),\n      timeFormat: d3_locale_timeFormat(locale)\n    };\n  };\n\n  var d3_locale_enUS = d3.locale({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"$\", \"\"],\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%m/%d/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  });\n  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;\n  d3.text = d3_xhrType(function (request) {\n    return request.responseText;\n  });\n  d3.geo = {};\n\n  d3.merge = function (arrays) {\n    var n = arrays.length,\n        m,\n        i = -1,\n        j = 0,\n        merged,\n        array;\n\n    while (++i < n) {\n      j += arrays[i].length;\n    }\n\n    merged = new Array(j);\n\n    while (--n >= 0) {\n      array = arrays[n];\n      m = array.length;\n\n      while (--m >= 0) {\n        merged[--j] = array[m];\n      }\n    }\n\n    return merged;\n  };\n\n  function d3_geo_spherical(cartesian) {\n    return [Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2])];\n  }\n\n  function d3_geo_sphericalEqual(a, b) {\n    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;\n  } // General spherical polygon clipping algorithm: takes a polygon, cuts it into\n  // visible line segments and rejoins the segments by interpolating along the\n  // clip edge.\n\n\n  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {\n    var subject = [],\n        clip = [];\n    segments.forEach(function (segment) {\n      if ((n = segment.length - 1) <= 0) return;\n      var n,\n          p0 = segment[0],\n          p1 = segment[n]; // If the first and last points of a segment are coincident, then treat as\n      // a closed ring.\n      // TODO if all rings are closed, then the winding order of the exterior\n      // ring should be checked.\n\n      if (d3_geo_sphericalEqual(p0, p1)) {\n        listener.lineStart();\n\n        for (var i = 0; i < n; ++i) {\n          listener.point((p0 = segment[i])[0], p0[1]);\n        }\n\n        listener.lineEnd();\n        return;\n      }\n\n      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true),\n          b = new d3_geo_clipPolygonIntersection(p0, null, a, false);\n      a.o = b;\n      subject.push(a);\n      clip.push(b);\n      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);\n      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);\n      a.o = b;\n      subject.push(a);\n      clip.push(b);\n    });\n    clip.sort(compare);\n    d3_geo_clipPolygonLinkCircular(subject);\n    d3_geo_clipPolygonLinkCircular(clip);\n    if (!subject.length) return;\n\n    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {\n      clip[i].e = entry = !entry;\n    }\n\n    var start = subject[0],\n        points,\n        point;\n\n    while (1) {\n      // Find first unvisited intersection.\n      var current = start,\n          isSubject = true;\n\n      while (current.v) {\n        if ((current = current.n) === start) return;\n      }\n\n      points = current.z;\n      listener.lineStart();\n\n      do {\n        current.v = current.o.v = true;\n\n        if (current.e) {\n          if (isSubject) {\n            for (var i = 0, n = points.length; i < n; ++i) {\n              listener.point((point = points[i])[0], point[1]);\n            }\n          } else {\n            interpolate(current.x, current.n.x, 1, listener);\n          }\n\n          current = current.n;\n        } else {\n          if (isSubject) {\n            points = current.p.z;\n\n            for (var i = points.length - 1; i >= 0; --i) {\n              listener.point((point = points[i])[0], point[1]);\n            }\n          } else {\n            interpolate(current.x, current.p.x, -1, listener);\n          }\n\n          current = current.p;\n        }\n\n        current = current.o;\n        points = current.z;\n        isSubject = !isSubject;\n      } while (!current.v);\n\n      listener.lineEnd();\n    }\n  }\n\n  function d3_geo_clipPolygonLinkCircular(array) {\n    if (!(n = array.length)) return;\n    var n,\n        i = 0,\n        a = array[0],\n        b;\n\n    while (++i < n) {\n      a.n = b = array[i];\n      b.p = a;\n      a = b;\n    }\n\n    a.n = b = array[0];\n    b.p = a;\n  }\n\n  function d3_geo_clipPolygonIntersection(point, points, other, entry) {\n    this.x = point;\n    this.z = points;\n    this.o = other; // another intersection\n\n    this.e = entry; // is an entry?\n\n    this.v = false; // visited\n\n    this.n = this.p = null; // next & previous\n  }\n\n  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {\n    return function (rotate, listener) {\n      var line = clipLine(listener),\n          rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);\n      var clip = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function polygonStart() {\n          clip.point = pointRing;\n          clip.lineStart = ringStart;\n          clip.lineEnd = ringEnd;\n          segments = [];\n          polygon = [];\n        },\n        polygonEnd: function polygonEnd() {\n          clip.point = point;\n          clip.lineStart = lineStart;\n          clip.lineEnd = lineEnd;\n          segments = d3.merge(segments);\n          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);\n\n          if (segments.length) {\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);\n          } else if (clipStartInside) {\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n            listener.lineStart();\n            interpolate(null, null, 1, listener);\n            listener.lineEnd();\n          }\n\n          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;\n          segments = polygon = null;\n        },\n        sphere: function sphere() {\n          listener.polygonStart();\n          listener.lineStart();\n          interpolate(null, null, 1, listener);\n          listener.lineEnd();\n          listener.polygonEnd();\n        }\n      };\n\n      function point(λ, φ) {\n        var point = rotate(λ, φ);\n        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);\n      }\n\n      function pointLine(λ, φ) {\n        var point = rotate(λ, φ);\n        line.point(point[0], point[1]);\n      }\n\n      function lineStart() {\n        clip.point = pointLine;\n        line.lineStart();\n      }\n\n      function lineEnd() {\n        clip.point = point;\n        line.lineEnd();\n      }\n\n      var segments;\n      var buffer = d3_geo_clipBufferListener(),\n          ringListener = clipLine(buffer),\n          polygonStarted = false,\n          polygon,\n          ring;\n\n      function pointRing(λ, φ) {\n        ring.push([λ, φ]);\n        var point = rotate(λ, φ);\n        ringListener.point(point[0], point[1]);\n      }\n\n      function ringStart() {\n        ringListener.lineStart();\n        ring = [];\n      }\n\n      function ringEnd() {\n        pointRing(ring[0][0], ring[0][1]);\n        ringListener.lineEnd();\n        var clean = ringListener.clean(),\n            ringSegments = buffer.buffer(),\n            segment,\n            n = ringSegments.length;\n        ring.pop();\n        polygon.push(ring);\n        ring = null;\n        if (!n) return; // No intersections.\n\n        if (clean & 1) {\n          segment = ringSegments[0];\n          var n = segment.length - 1,\n              i = -1,\n              point;\n\n          if (n > 0) {\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n            listener.lineStart();\n\n            while (++i < n) {\n              listener.point((point = segment[i])[0], point[1]);\n            }\n\n            listener.lineEnd();\n          }\n\n          return;\n        } // Rejoin connected segments.\n        // TODO reuse bufferListener.rejoin()?\n\n\n        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));\n      }\n\n      return clip;\n    };\n  }\n\n  function d3_geo_clipSegmentLength1(segment) {\n    return segment.length > 1;\n  }\n\n  function d3_geo_clipBufferListener() {\n    var lines = [],\n        line;\n    return {\n      lineStart: function lineStart() {\n        lines.push(line = []);\n      },\n      point: function point(λ, φ) {\n        line.push([λ, φ]);\n      },\n      lineEnd: d3_noop,\n      buffer: function buffer() {\n        var buffer = lines;\n        lines = [];\n        line = null;\n        return buffer;\n      },\n      rejoin: function rejoin() {\n        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n      }\n    };\n  } // Intersection points are sorted along the clip edge. For both antimeridian\n  // cutting and circle clipping, the same comparison is used.\n\n\n  function d3_geo_clipSort(a, b) {\n    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);\n  } // Adds floating point numbers with twice the normal precision.\n  // Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and\n  // Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)\n  // 305–363 (1997).\n  // Code adapted from GeographicLib by Charles F. F. Karney,\n  // http://geographiclib.sourceforge.net/\n  // See lib/geographiclib/LICENSE for details.\n\n\n  function d3_adder() {}\n\n  d3_adder.prototype = {\n    s: 0,\n    // rounded value\n    t: 0,\n    // exact error\n    add: function add(y) {\n      d3_adderSum(y, this.t, d3_adderTemp);\n      d3_adderSum(d3_adderTemp.s, this.s, this);\n      if (this.s) this.t += d3_adderTemp.t;else this.s = d3_adderTemp.t;\n    },\n    reset: function reset() {\n      this.s = this.t = 0;\n    },\n    valueOf: function valueOf() {\n      return this.s;\n    }\n  };\n  var d3_adderTemp = new d3_adder();\n\n  function d3_adderSum(a, b, o) {\n    var x = o.s = a + b,\n        // a + b\n    bv = x - a,\n        av = x - bv; // b_virtual & a_virtual\n\n    o.t = a - av + (b - bv); // a_roundoff + b_roundoff\n  }\n\n  d3.geo.stream = function (object, listener) {\n    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {\n      d3_geo_streamObjectType[object.type](object, listener);\n    } else {\n      d3_geo_streamGeometry(object, listener);\n    }\n  };\n\n  function d3_geo_streamGeometry(geometry, listener) {\n    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {\n      d3_geo_streamGeometryType[geometry.type](geometry, listener);\n    }\n  }\n\n  var d3_geo_streamObjectType = {\n    Feature: function Feature(feature, listener) {\n      d3_geo_streamGeometry(feature.geometry, listener);\n    },\n    FeatureCollection: function FeatureCollection(object, listener) {\n      var features = object.features,\n          i = -1,\n          n = features.length;\n\n      while (++i < n) {\n        d3_geo_streamGeometry(features[i].geometry, listener);\n      }\n    }\n  };\n  var d3_geo_streamGeometryType = {\n    Sphere: function Sphere(object, listener) {\n      listener.sphere();\n    },\n    Point: function Point(object, listener) {\n      object = object.coordinates;\n      listener.point(object[0], object[1], object[2]);\n    },\n    MultiPoint: function MultiPoint(object, listener) {\n      var coordinates = object.coordinates,\n          i = -1,\n          n = coordinates.length;\n\n      while (++i < n) {\n        object = coordinates[i], listener.point(object[0], object[1], object[2]);\n      }\n    },\n    LineString: function LineString(object, listener) {\n      d3_geo_streamLine(object.coordinates, listener, 0);\n    },\n    MultiLineString: function MultiLineString(object, listener) {\n      var coordinates = object.coordinates,\n          i = -1,\n          n = coordinates.length;\n\n      while (++i < n) {\n        d3_geo_streamLine(coordinates[i], listener, 0);\n      }\n    },\n    Polygon: function Polygon(object, listener) {\n      d3_geo_streamPolygon(object.coordinates, listener);\n    },\n    MultiPolygon: function MultiPolygon(object, listener) {\n      var coordinates = object.coordinates,\n          i = -1,\n          n = coordinates.length;\n\n      while (++i < n) {\n        d3_geo_streamPolygon(coordinates[i], listener);\n      }\n    },\n    GeometryCollection: function GeometryCollection(object, listener) {\n      var geometries = object.geometries,\n          i = -1,\n          n = geometries.length;\n\n      while (++i < n) {\n        d3_geo_streamGeometry(geometries[i], listener);\n      }\n    }\n  };\n\n  function d3_geo_streamLine(coordinates, listener, closed) {\n    var i = -1,\n        n = coordinates.length - closed,\n        coordinate;\n    listener.lineStart();\n\n    while (++i < n) {\n      coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);\n    }\n\n    listener.lineEnd();\n  }\n\n  function d3_geo_streamPolygon(coordinates, listener) {\n    var i = -1,\n        n = coordinates.length;\n    listener.polygonStart();\n\n    while (++i < n) {\n      d3_geo_streamLine(coordinates[i], listener, 1);\n    }\n\n    listener.polygonEnd();\n  }\n\n  d3.geo.area = function (object) {\n    d3_geo_areaSum = 0;\n    d3.geo.stream(object, d3_geo_area);\n    return d3_geo_areaSum;\n  };\n\n  var d3_geo_areaSum,\n      d3_geo_areaRingSum = new d3_adder();\n  var d3_geo_area = {\n    sphere: function sphere() {\n      d3_geo_areaSum += 4 * π;\n    },\n    point: d3_noop,\n    lineStart: d3_noop,\n    lineEnd: d3_noop,\n    // Only count area for polygon rings.\n    polygonStart: function polygonStart() {\n      d3_geo_areaRingSum.reset();\n      d3_geo_area.lineStart = d3_geo_areaRingStart;\n    },\n    polygonEnd: function polygonEnd() {\n      var area = 2 * d3_geo_areaRingSum;\n      d3_geo_areaSum += area < 0 ? 4 * π + area : area;\n      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;\n    }\n  };\n\n  function d3_geo_areaRingStart() {\n    var λ00, φ00, λ0, cosφ0, sinφ0; // start point and previous point\n    // For the first point, …\n\n    d3_geo_area.point = function (λ, φ) {\n      d3_geo_area.point = nextPoint;\n      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), sinφ0 = Math.sin(φ);\n    }; // For subsequent points, …\n\n\n    function nextPoint(λ, φ) {\n      λ *= d3_radians;\n      φ = φ * d3_radians / 2 + π / 4; // half the angular distance from south pole\n      // Spherical excess E for a spherical triangle with vertices: south pole,\n      // previous point, current point.  Uses a formula derived from Cagnoli’s\n      // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n\n      var dλ = λ - λ0,\n          sdλ = dλ >= 0 ? 1 : -1,\n          adλ = sdλ * dλ,\n          cosφ = Math.cos(φ),\n          sinφ = Math.sin(φ),\n          k = sinφ0 * sinφ,\n          u = cosφ0 * cosφ + k * Math.cos(adλ),\n          v = k * sdλ * Math.sin(adλ);\n      d3_geo_areaRingSum.add(Math.atan2(v, u)); // Advance the previous points.\n\n      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;\n    } // For the last point, return to the start.\n\n\n    d3_geo_area.lineEnd = function () {\n      nextPoint(λ00, φ00);\n    };\n  } // TODO\n  // cross and scale return new vectors,\n  // whereas add and normalize operate in-place\n\n\n  function d3_geo_cartesian(spherical) {\n    var λ = spherical[0],\n        φ = spherical[1],\n        cosφ = Math.cos(φ);\n    return [cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ)];\n  }\n\n  function d3_geo_cartesianDot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n  }\n\n  function d3_geo_cartesianCross(a, b) {\n    return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n  }\n\n  function d3_geo_cartesianAdd(a, b) {\n    a[0] += b[0];\n    a[1] += b[1];\n    a[2] += b[2];\n  }\n\n  function d3_geo_cartesianScale(vector, k) {\n    return [vector[0] * k, vector[1] * k, vector[2] * k];\n  }\n\n  function d3_geo_cartesianNormalize(d) {\n    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n    d[0] /= l;\n    d[1] /= l;\n    d[2] /= l;\n  }\n\n  function d3_geo_pointInPolygon(point, polygon) {\n    var meridian = point[0],\n        parallel = point[1],\n        meridianNormal = [Math.sin(meridian), -Math.cos(meridian), 0],\n        polarAngle = 0,\n        winding = 0;\n    d3_geo_areaRingSum.reset();\n\n    for (var i = 0, n = polygon.length; i < n; ++i) {\n      var ring = polygon[i],\n          m = ring.length;\n      if (!m) continue;\n      var point0 = ring[0],\n          λ0 = point0[0],\n          φ0 = point0[1] / 2 + π / 4,\n          sinφ0 = Math.sin(φ0),\n          cosφ0 = Math.cos(φ0),\n          j = 1;\n\n      while (true) {\n        if (j === m) j = 0;\n        point = ring[j];\n        var λ = point[0],\n            φ = point[1] / 2 + π / 4,\n            sinφ = Math.sin(φ),\n            cosφ = Math.cos(φ),\n            dλ = λ - λ0,\n            sdλ = dλ >= 0 ? 1 : -1,\n            adλ = sdλ * dλ,\n            antimeridian = adλ > π,\n            k = sinφ0 * sinφ;\n        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));\n        polarAngle += antimeridian ? dλ + sdλ * τ : dλ; // Are the longitudes either side of the point's meridian, and are the\n        // latitudes smaller than the parallel?\n\n        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {\n          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));\n          d3_geo_cartesianNormalize(arc);\n          var intersection = d3_geo_cartesianCross(meridianNormal, arc);\n          d3_geo_cartesianNormalize(intersection);\n          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);\n\n          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {\n            winding += antimeridian ^ dλ >= 0 ? 1 : -1;\n          }\n        }\n\n        if (!j++) break;\n        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;\n      }\n    } // First, determine whether the South pole is inside or outside:\n    //\n    // It is inside if:\n    // * the polygon winds around it in a clockwise direction.\n    // * the polygon does not (cumulatively) wind around it, but has a negative\n    //   (counter-clockwise) area.\n    //\n    // Second, count the (signed) number of times a segment crosses a meridian\n    // from the point to the South pole.  If it is zero, then the point is the\n    // same side as the South pole.\n\n\n    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < 0) ^ winding & 1;\n  }\n\n  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [-π, -π / 2]); // Takes a line and cuts into visible segments. Return values:\n  //   0: there were intersections or the line was empty.\n  //   1: no intersections.\n  //   2: there were intersections, and the first and last segments should be\n  //      rejoined.\n\n  function d3_geo_clipAntimeridianLine(listener) {\n    var λ0 = NaN,\n        φ0 = NaN,\n        sλ0 = NaN,\n        _clean; // no intersections\n\n\n    return {\n      lineStart: function lineStart() {\n        listener.lineStart();\n        _clean = 1;\n      },\n      point: function point(λ1, φ1) {\n        var sλ1 = λ1 > 0 ? π : -π,\n            dλ = abs(λ1 - λ0);\n\n        if (abs(dλ - π) < ε) {\n          // line crosses a pole\n          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);\n          listener.point(sλ0, φ0);\n          listener.lineEnd();\n          listener.lineStart();\n          listener.point(sλ1, φ0);\n          listener.point(λ1, φ0);\n          _clean = 0;\n        } else if (sλ0 !== sλ1 && dλ >= π) {\n          // line crosses antimeridian\n          // handle degeneracies\n          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;\n          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;\n          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);\n          listener.point(sλ0, φ0);\n          listener.lineEnd();\n          listener.lineStart();\n          listener.point(sλ1, φ0);\n          _clean = 0;\n        }\n\n        listener.point(λ0 = λ1, φ0 = φ1);\n        sλ0 = sλ1;\n      },\n      lineEnd: function lineEnd() {\n        listener.lineEnd();\n        λ0 = φ0 = NaN;\n      },\n      // if there are intersections, we always rejoin the first and last segments.\n      clean: function clean() {\n        return 2 - _clean;\n      }\n    };\n  }\n\n  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {\n    var cosφ0,\n        cosφ1,\n        sinλ0_λ1 = Math.sin(λ0 - λ1);\n    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;\n  }\n\n  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {\n    var φ;\n\n    if (from == null) {\n      φ = direction * halfπ;\n      listener.point(-π, φ);\n      listener.point(0, φ);\n      listener.point(π, φ);\n      listener.point(π, 0);\n      listener.point(π, -φ);\n      listener.point(0, -φ);\n      listener.point(-π, -φ);\n      listener.point(-π, 0);\n      listener.point(-π, φ);\n    } else if (abs(from[0] - to[0]) > ε) {\n      var s = from[0] < to[0] ? π : -π;\n      φ = direction * s / 2;\n      listener.point(-s, φ);\n      listener.point(0, φ);\n      listener.point(s, φ);\n    } else {\n      listener.point(to[0], to[1]);\n    }\n  }\n\n  function d3_geo_equirectangular(λ, φ) {\n    return [λ, φ];\n  }\n\n  (d3.geo.equirectangular = function () {\n    return d3_geo_projection(d3_geo_equirectangular);\n  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;\n\n  d3.geo.rotation = function (rotate) {\n    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);\n\n    function forward(coordinates) {\n      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);\n      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;\n    }\n\n    forward.invert = function (coordinates) {\n      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);\n      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;\n    };\n\n    return forward;\n  };\n\n  function d3_geo_identityRotation(λ, φ) {\n    return [λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ];\n  }\n\n  d3_geo_identityRotation.invert = d3_geo_equirectangular; // Note: |δλ| must be < 2π\n\n  function d3_geo_rotation(δλ, δφ, δγ) {\n    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;\n  }\n\n  function d3_geo_forwardRotationλ(δλ) {\n    return function (λ, φ) {\n      return λ += δλ, [λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ];\n    };\n  }\n\n  function d3_geo_rotationλ(δλ) {\n    var rotation = d3_geo_forwardRotationλ(δλ);\n    rotation.invert = d3_geo_forwardRotationλ(-δλ);\n    return rotation;\n  }\n\n  function d3_geo_rotationφγ(δφ, δγ) {\n    var cosδφ = Math.cos(δφ),\n        sinδφ = Math.sin(δφ),\n        cosδγ = Math.cos(δγ),\n        sinδγ = Math.sin(δγ);\n\n    function rotation(λ, φ) {\n      var cosφ = Math.cos(φ),\n          x = Math.cos(λ) * cosφ,\n          y = Math.sin(λ) * cosφ,\n          z = Math.sin(φ),\n          k = z * cosδφ + x * sinδφ;\n      return [Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ)];\n    }\n\n    rotation.invert = function (λ, φ) {\n      var cosφ = Math.cos(φ),\n          x = Math.cos(λ) * cosφ,\n          y = Math.sin(λ) * cosφ,\n          z = Math.sin(φ),\n          k = z * cosδγ - y * sinδγ;\n      return [Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ)];\n    };\n\n    return rotation;\n  }\n\n  d3.geo.circle = function () {\n    var origin = [0, 0],\n        angle,\n        precision = 6,\n        interpolate;\n\n    function circle() {\n      var center = typeof origin === \"function\" ? origin.apply(this, arguments) : origin,\n          rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert,\n          ring = [];\n      interpolate(null, null, 1, {\n        point: function point(x, y) {\n          ring.push(x = rotate(x, y));\n          x[0] *= d3_degrees, x[1] *= d3_degrees;\n        }\n      });\n      return {\n        type: \"Polygon\",\n        coordinates: [ring]\n      };\n    }\n\n    circle.origin = function (x) {\n      if (!arguments.length) return origin;\n      origin = x;\n      return circle;\n    };\n\n    circle.angle = function (x) {\n      if (!arguments.length) return angle;\n      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);\n      return circle;\n    };\n\n    circle.precision = function (_) {\n      if (!arguments.length) return precision;\n      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);\n      return circle;\n    };\n\n    return circle.angle(90);\n  }; // Interpolates along a circle centered at [0°, 0°], with a given radius and\n  // precision.\n\n\n  function d3_geo_circleInterpolate(radius, precision) {\n    var cr = Math.cos(radius),\n        sr = Math.sin(radius);\n    return function (from, to, direction, listener) {\n      var step = direction * precision;\n\n      if (from != null) {\n        from = d3_geo_circleAngle(cr, from);\n        to = d3_geo_circleAngle(cr, to);\n        if (direction > 0 ? from < to : from > to) from += direction * τ;\n      } else {\n        from = radius + direction * τ;\n        to = radius - .5 * step;\n      }\n\n      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {\n        listener.point((point = d3_geo_spherical([cr, -sr * Math.cos(t), -sr * Math.sin(t)]))[0], point[1]);\n      }\n    };\n  } // Signed angle of a cartesian point relative to [cr, 0, 0].\n\n\n  function d3_geo_circleAngle(cr, point) {\n    var a = d3_geo_cartesian(point);\n    a[0] -= cr;\n    d3_geo_cartesianNormalize(a);\n    var angle = d3_acos(-a[1]);\n    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);\n  } // Clip features against a small circle centered at [0°, 0°].\n\n\n  function d3_geo_clipCircle(radius) {\n    var cr = Math.cos(radius),\n        smallRadius = cr > 0,\n        notHemisphere = abs(cr) > ε,\n        // TODO optimise for this common case\n    interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);\n    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-π, radius - π]);\n\n    function visible(λ, φ) {\n      return Math.cos(λ) * Math.cos(φ) > cr;\n    } // Takes a line and cuts into visible segments. Return values used for\n    // polygon clipping:\n    //   0: there were intersections or the line was empty.\n    //   1: no intersections.\n    //   2: there were intersections, and the first and last segments should be\n    //      rejoined.\n\n\n    function clipLine(listener) {\n      var point0, // previous point\n      c0, // code for previous point\n      v0, // visibility of previous point\n      v00, // visibility of first point\n      _clean2; // no intersections\n\n\n      return {\n        lineStart: function lineStart() {\n          v00 = v0 = false;\n          _clean2 = 1;\n        },\n        point: function point(λ, φ) {\n          var point1 = [λ, φ],\n              point2,\n              v = visible(λ, φ),\n              c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;\n          if (!point0 && (v00 = v0 = v)) listener.lineStart(); // Handle degeneracies.\n          // TODO ignore if not clipping polygons.\n\n          if (v !== v0) {\n            point2 = intersect(point0, point1);\n\n            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {\n              point1[0] += ε;\n              point1[1] += ε;\n              v = visible(point1[0], point1[1]);\n            }\n          }\n\n          if (v !== v0) {\n            _clean2 = 0;\n\n            if (v) {\n              // outside going in\n              listener.lineStart();\n              point2 = intersect(point1, point0);\n              listener.point(point2[0], point2[1]);\n            } else {\n              // inside going out\n              point2 = intersect(point0, point1);\n              listener.point(point2[0], point2[1]);\n              listener.lineEnd();\n            }\n\n            point0 = point2;\n          } else if (notHemisphere && point0 && smallRadius ^ v) {\n            var t; // If the codes for two points are different, or are both zero,\n            // and there this segment intersects with the small circle.\n\n            if (!(c & c0) && (t = intersect(point1, point0, true))) {\n              _clean2 = 0;\n\n              if (smallRadius) {\n                listener.lineStart();\n                listener.point(t[0][0], t[0][1]);\n                listener.point(t[1][0], t[1][1]);\n                listener.lineEnd();\n              } else {\n                listener.point(t[1][0], t[1][1]);\n                listener.lineEnd();\n                listener.lineStart();\n                listener.point(t[0][0], t[0][1]);\n              }\n            }\n          }\n\n          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {\n            listener.point(point1[0], point1[1]);\n          }\n\n          point0 = point1, v0 = v, c0 = c;\n        },\n        lineEnd: function lineEnd() {\n          if (v0) listener.lineEnd();\n          point0 = null;\n        },\n        // Rejoin first and last segments if there were intersections and the first\n        // and last points were visible.\n        clean: function clean() {\n          return _clean2 | (v00 && v0) << 1;\n        }\n      };\n    } // Intersects the great circle between a and b with the clip circle.\n\n\n    function intersect(a, b, two) {\n      var pa = d3_geo_cartesian(a),\n          pb = d3_geo_cartesian(b); // We have two planes, n1.p = d1 and n2.p = d2.\n      // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).\n\n      var n1 = [1, 0, 0],\n          // normal\n      n2 = d3_geo_cartesianCross(pa, pb),\n          n2n2 = d3_geo_cartesianDot(n2, n2),\n          n1n2 = n2[0],\n          // d3_geo_cartesianDot(n1, n2),\n      determinant = n2n2 - n1n2 * n1n2; // Two polar points.\n\n      if (!determinant) return !two && a;\n      var c1 = cr * n2n2 / determinant,\n          c2 = -cr * n1n2 / determinant,\n          n1xn2 = d3_geo_cartesianCross(n1, n2),\n          A = d3_geo_cartesianScale(n1, c1),\n          B = d3_geo_cartesianScale(n2, c2);\n      d3_geo_cartesianAdd(A, B); // Solve |p(t)|^2 = 1.\n\n      var u = n1xn2,\n          w = d3_geo_cartesianDot(A, u),\n          uu = d3_geo_cartesianDot(u, u),\n          t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);\n      if (t2 < 0) return;\n      var t = Math.sqrt(t2),\n          q = d3_geo_cartesianScale(u, (-w - t) / uu);\n      d3_geo_cartesianAdd(q, A);\n      q = d3_geo_spherical(q);\n      if (!two) return q; // Two intersection points.\n\n      var λ0 = a[0],\n          λ1 = b[0],\n          φ0 = a[1],\n          φ1 = b[1],\n          z;\n      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;\n      var δλ = λ1 - λ0,\n          polar = abs(δλ - π) < ε,\n          meridian = polar || δλ < ε;\n      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z; // Check that the first point is between a and b.\n\n      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {\n        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);\n        d3_geo_cartesianAdd(q1, A);\n        return [q, d3_geo_spherical(q1)];\n      }\n    } // Generates a 4-bit vector representing the location of a point relative to\n    // the small circle's bounding box.\n\n\n    function code(λ, φ) {\n      var r = smallRadius ? radius : π - radius,\n          code = 0;\n      if (λ < -r) code |= 1; // left\n      else if (λ > r) code |= 2; // right\n\n      if (φ < -r) code |= 4; // below\n      else if (φ > r) code |= 8; // above\n\n      return code;\n    }\n  } // Liang–Barsky line clipping.\n\n\n  function d3_geom_clipLine(x0, y0, x1, y1) {\n    return function (line) {\n      var a = line.a,\n          b = line.b,\n          ax = a.x,\n          ay = a.y,\n          bx = b.x,\n          by = b.y,\n          t0 = 0,\n          t1 = 1,\n          dx = bx - ax,\n          dy = by - ay,\n          r;\n      r = x0 - ax;\n      if (!dx && r > 0) return;\n      r /= dx;\n\n      if (dx < 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      } else if (dx > 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      }\n\n      r = x1 - ax;\n      if (!dx && r < 0) return;\n      r /= dx;\n\n      if (dx < 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      } else if (dx > 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      }\n\n      r = y0 - ay;\n      if (!dy && r > 0) return;\n      r /= dy;\n\n      if (dy < 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      } else if (dy > 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      }\n\n      r = y1 - ay;\n      if (!dy && r < 0) return;\n      r /= dy;\n\n      if (dy < 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      } else if (dy > 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      }\n\n      if (t0 > 0) line.a = {\n        x: ax + t0 * dx,\n        y: ay + t0 * dy\n      };\n      if (t1 < 1) line.b = {\n        x: ax + t1 * dx,\n        y: ay + t1 * dy\n      };\n      return line;\n    };\n  }\n\n  var d3_geo_clipExtentMAX = 1e9;\n\n  d3.geo.clipExtent = function () {\n    var x0,\n        y0,\n        x1,\n        y1,\n        _stream,\n        clip,\n        clipExtent = {\n      stream: function stream(output) {\n        if (_stream) _stream.valid = false;\n        _stream = clip(output);\n        _stream.valid = true; // allow caching by d3.geo.path\n\n        return _stream;\n      },\n      extent: function extent(_) {\n        if (!arguments.length) return [[x0, y0], [x1, y1]];\n        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);\n        if (_stream) _stream.valid = false, _stream = null;\n        return clipExtent;\n      }\n    };\n\n    return clipExtent.extent([[0, 0], [960, 500]]);\n  };\n\n  function d3_geo_clipExtent(x0, y0, x1, y1) {\n    return function (listener) {\n      var listener_ = listener,\n          bufferListener = d3_geo_clipBufferListener(),\n          clipLine = d3_geom_clipLine(x0, y0, x1, y1),\n          segments,\n          polygon,\n          ring;\n      var clip = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function polygonStart() {\n          listener = bufferListener;\n          segments = [];\n          polygon = [];\n          clean = true;\n        },\n        polygonEnd: function polygonEnd() {\n          listener = listener_;\n          segments = d3.merge(segments);\n          var clipStartInside = insidePolygon([x0, y1]),\n              inside = clean && clipStartInside,\n              visible = segments.length;\n\n          if (inside || visible) {\n            listener.polygonStart();\n\n            if (inside) {\n              listener.lineStart();\n              interpolate(null, null, 1, listener);\n              listener.lineEnd();\n            }\n\n            if (visible) {\n              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);\n            }\n\n            listener.polygonEnd();\n          }\n\n          segments = polygon = ring = null;\n        }\n      };\n\n      function insidePolygon(p) {\n        var wn = 0,\n            // the winding number counter\n        n = polygon.length,\n            y = p[1];\n\n        for (var i = 0; i < n; ++i) {\n          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {\n            b = v[j];\n\n            if (a[1] <= y) {\n              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;\n            } else {\n              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;\n            }\n\n            a = b;\n          }\n        }\n\n        return wn !== 0;\n      }\n\n      function interpolate(from, to, direction, listener) {\n        var a = 0,\n            a1 = 0;\n\n        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {\n          do {\n            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n          } while ((a = (a + direction + 4) % 4) !== a1);\n        } else {\n          listener.point(to[0], to[1]);\n        }\n      }\n\n      function pointVisible(x, y) {\n        return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n      }\n\n      function point(x, y) {\n        if (pointVisible(x, y)) listener.point(x, y);\n      }\n\n      var x__, y__, v__, // first point\n      x_, y_, v_, // previous point\n      first, clean;\n\n      function lineStart() {\n        clip.point = linePoint;\n        if (polygon) polygon.push(ring = []);\n        first = true;\n        v_ = false;\n        x_ = y_ = NaN;\n      }\n\n      function lineEnd() {\n        // TODO rather than special-case polygons, simply handle them separately.\n        // Ideally, coincident intersection points should be jittered to avoid\n        // clipping issues.\n        if (segments) {\n          linePoint(x__, y__);\n          if (v__ && v_) bufferListener.rejoin();\n          segments.push(bufferListener.buffer());\n        }\n\n        clip.point = point;\n        if (v_) listener.lineEnd();\n      }\n\n      function linePoint(x, y) {\n        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));\n        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));\n        var v = pointVisible(x, y);\n        if (polygon) ring.push([x, y]);\n\n        if (first) {\n          x__ = x, y__ = y, v__ = v;\n          first = false;\n\n          if (v) {\n            listener.lineStart();\n            listener.point(x, y);\n          }\n        } else {\n          if (v && v_) listener.point(x, y);else {\n            var l = {\n              a: {\n                x: x_,\n                y: y_\n              },\n              b: {\n                x: x,\n                y: y\n              }\n            };\n\n            if (clipLine(l)) {\n              if (!v_) {\n                listener.lineStart();\n                listener.point(l.a.x, l.a.y);\n              }\n\n              listener.point(l.b.x, l.b.y);\n              if (!v) listener.lineEnd();\n              clean = false;\n            } else if (v) {\n              listener.lineStart();\n              listener.point(x, y);\n              clean = false;\n            }\n          }\n        }\n\n        x_ = x, y_ = y, v_ = v;\n      }\n\n      return clip;\n    };\n\n    function corner(p, direction) {\n      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2; // abs(p[1] - y1) < ε\n    }\n\n    function compare(a, b) {\n      return comparePoints(a.x, b.x);\n    }\n\n    function comparePoints(a, b) {\n      var ca = corner(a, 1),\n          cb = corner(b, 1);\n      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];\n    }\n  }\n\n  function d3_geo_compose(a, b) {\n    function compose(x, y) {\n      return x = a(x, y), b(x[0], x[1]);\n    }\n\n    if (a.invert && b.invert) compose.invert = function (x, y) {\n      return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n    };\n    return compose;\n  }\n\n  function d3_geo_conic(projectAt) {\n    var φ0 = 0,\n        φ1 = π / 3,\n        m = d3_geo_projectionMutator(projectAt),\n        p = m(φ0, φ1);\n\n    p.parallels = function (_) {\n      if (!arguments.length) return [φ0 / π * 180, φ1 / π * 180];\n      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);\n    };\n\n    return p;\n  }\n\n  function d3_geo_conicEqualArea(φ0, φ1) {\n    var sinφ0 = Math.sin(φ0),\n        n = (sinφ0 + Math.sin(φ1)) / 2,\n        C = 1 + sinφ0 * (2 * n - sinφ0),\n        ρ0 = Math.sqrt(C) / n;\n\n    function forward(λ, φ) {\n      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;\n      return [ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ)];\n    }\n\n    forward.invert = function (x, y) {\n      var ρ0_y = ρ0 - y;\n      return [Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n))];\n    };\n\n    return forward;\n  }\n\n  (d3.geo.conicEqualArea = function () {\n    return d3_geo_conic(d3_geo_conicEqualArea);\n  }).raw = d3_geo_conicEqualArea; // ESRI:102003\n\n  d3.geo.albers = function () {\n    return d3.geo.conicEqualArea().rotate([96, 0]).center([-.6, 38.7]).parallels([29.5, 45.5]).scale(1070);\n  }; // A composite projection for the United States, configured by default for\n  // 960×500. Also works quite well at 960×600 with scale 1285. The set of\n  // standard parallels for each region comes from USGS, which is published here:\n  // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers\n\n\n  d3.geo.albersUsa = function () {\n    var lower48 = d3.geo.albers(); // EPSG:3338\n\n    var alaska = d3.geo.conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]); // ESRI:102007\n\n    var hawaii = d3.geo.conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]);\n\n    var _point,\n        pointStream = {\n      point: function point(x, y) {\n        _point = [x, y];\n      }\n    },\n        lower48Point,\n        alaskaPoint,\n        hawaiiPoint;\n\n    function albersUsa(coordinates) {\n      var x = coordinates[0],\n          y = coordinates[1];\n      _point = null;\n      (lower48Point(x, y), _point) || (alaskaPoint(x, y), _point) || hawaiiPoint(x, y);\n      return _point;\n    }\n\n    albersUsa.invert = function (coordinates) {\n      var k = lower48.scale(),\n          t = lower48.translate(),\n          x = (coordinates[0] - t[0]) / k,\n          y = (coordinates[1] - t[1]) / k;\n      return (y >= .120 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);\n    }; // A naïve multi-projection stream.\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n\n\n    albersUsa.stream = function (stream) {\n      var lower48Stream = lower48.stream(stream),\n          alaskaStream = alaska.stream(stream),\n          hawaiiStream = hawaii.stream(stream);\n      return {\n        point: function point(x, y) {\n          lower48Stream.point(x, y);\n          alaskaStream.point(x, y);\n          hawaiiStream.point(x, y);\n        },\n        sphere: function sphere() {\n          lower48Stream.sphere();\n          alaskaStream.sphere();\n          hawaiiStream.sphere();\n        },\n        lineStart: function lineStart() {\n          lower48Stream.lineStart();\n          alaskaStream.lineStart();\n          hawaiiStream.lineStart();\n        },\n        lineEnd: function lineEnd() {\n          lower48Stream.lineEnd();\n          alaskaStream.lineEnd();\n          hawaiiStream.lineEnd();\n        },\n        polygonStart: function polygonStart() {\n          lower48Stream.polygonStart();\n          alaskaStream.polygonStart();\n          hawaiiStream.polygonStart();\n        },\n        polygonEnd: function polygonEnd() {\n          lower48Stream.polygonEnd();\n          alaskaStream.polygonEnd();\n          hawaiiStream.polygonEnd();\n        }\n      };\n    };\n\n    albersUsa.precision = function (_) {\n      if (!arguments.length) return lower48.precision();\n      lower48.precision(_);\n      alaska.precision(_);\n      hawaii.precision(_);\n      return albersUsa;\n    };\n\n    albersUsa.scale = function (_) {\n      if (!arguments.length) return lower48.scale();\n      lower48.scale(_);\n      alaska.scale(_ * .35);\n      hawaii.scale(_);\n      return albersUsa.translate(lower48.translate());\n    };\n\n    albersUsa.translate = function (_) {\n      if (!arguments.length) return lower48.translate();\n      var k = lower48.scale(),\n          x = +_[0],\n          y = +_[1];\n      lower48Point = lower48.translate(_).clipExtent([[x - .455 * k, y - .238 * k], [x + .455 * k, y + .238 * k]]).stream(pointStream).point;\n      alaskaPoint = alaska.translate([x - .307 * k, y + .201 * k]).clipExtent([[x - .425 * k + ε, y + .120 * k + ε], [x - .214 * k - ε, y + .234 * k - ε]]).stream(pointStream).point;\n      hawaiiPoint = hawaii.translate([x - .205 * k, y + .212 * k]).clipExtent([[x - .214 * k + ε, y + .166 * k + ε], [x - .115 * k - ε, y + .234 * k - ε]]).stream(pointStream).point;\n      return albersUsa;\n    };\n\n    return albersUsa.scale(1070);\n  };\n\n  d3.geo.bounds = function () {\n    var λ0, φ0, λ1, φ1, // bounds\n    λ_, // previous λ-coordinate\n    λ__, φ__, // first point\n    p0, // previous 3D point\n    dλSum, ranges, range;\n    var bound = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function polygonStart() {\n        bound.point = ringPoint;\n        bound.lineStart = ringStart;\n        bound.lineEnd = ringEnd;\n        dλSum = 0;\n        d3_geo_area.polygonStart();\n      },\n      polygonEnd: function polygonEnd() {\n        d3_geo_area.polygonEnd();\n        bound.point = point;\n        bound.lineStart = lineStart;\n        bound.lineEnd = lineEnd;\n        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90);else if (dλSum > ε) φ1 = 90;else if (dλSum < -ε) φ0 = -90;\n        range[0] = λ0, range[1] = λ1;\n      }\n    };\n\n    function point(λ, φ) {\n      ranges.push(range = [λ0 = λ, λ1 = λ]);\n      if (φ < φ0) φ0 = φ;\n      if (φ > φ1) φ1 = φ;\n    }\n\n    function linePoint(λ, φ) {\n      var p = d3_geo_cartesian([λ * d3_radians, φ * d3_radians]);\n\n      if (p0) {\n        var normal = d3_geo_cartesianCross(p0, p),\n            equatorial = [normal[1], -normal[0], 0],\n            inflection = d3_geo_cartesianCross(equatorial, normal);\n        d3_geo_cartesianNormalize(inflection);\n        inflection = d3_geo_spherical(inflection);\n        var dλ = λ - λ_,\n            s = dλ > 0 ? 1 : -1,\n            λi = inflection[0] * d3_degrees * s,\n            antimeridian = abs(dλ) > 180;\n\n        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {\n          var φi = inflection[1] * d3_degrees;\n          if (φi > φ1) φ1 = φi;\n        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {\n          var φi = -inflection[1] * d3_degrees;\n          if (φi < φ0) φ0 = φi;\n        } else {\n          if (φ < φ0) φ0 = φ;\n          if (φ > φ1) φ1 = φ;\n        }\n\n        if (antimeridian) {\n          if (λ < λ_) {\n            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;\n          } else {\n            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;\n          }\n        } else {\n          if (λ1 >= λ0) {\n            if (λ < λ0) λ0 = λ;\n            if (λ > λ1) λ1 = λ;\n          } else {\n            if (λ > λ_) {\n              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;\n            } else {\n              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;\n            }\n          }\n        }\n      } else {\n        point(λ, φ);\n      }\n\n      p0 = p, λ_ = λ;\n    }\n\n    function lineStart() {\n      bound.point = linePoint;\n    }\n\n    function lineEnd() {\n      range[0] = λ0, range[1] = λ1;\n      bound.point = point;\n      p0 = null;\n    }\n\n    function ringPoint(λ, φ) {\n      if (p0) {\n        var dλ = λ - λ_;\n        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;\n      } else λ__ = λ, φ__ = φ;\n\n      d3_geo_area.point(λ, φ);\n      linePoint(λ, φ);\n    }\n\n    function ringStart() {\n      d3_geo_area.lineStart();\n    }\n\n    function ringEnd() {\n      ringPoint(λ__, φ__);\n      d3_geo_area.lineEnd();\n      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);\n      range[0] = λ0, range[1] = λ1;\n      p0 = null;\n    } // Finds the left-right distance between two longitudes.\n    // This is almost the same as (λ1 - λ0 + 360°) % 360°, except that we want\n    // the distance between ±180° to be 360°.\n\n\n    function angle(λ0, λ1) {\n      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;\n    }\n\n    function compareRanges(a, b) {\n      return a[0] - b[0];\n    }\n\n    function withinRange(x, range) {\n      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n    }\n\n    return function (feature) {\n      φ1 = λ1 = -(λ0 = φ0 = Infinity);\n      ranges = [];\n      d3.geo.stream(feature, bound);\n      var n = ranges.length;\n\n      if (n) {\n        // First, sort ranges by their minimum longitudes.\n        ranges.sort(compareRanges); // Then, merge any ranges that overlap.\n\n        for (var i = 1, a = ranges[0], b, merged = [a]; i < n; ++i) {\n          b = ranges[i];\n\n          if (withinRange(b[0], a) || withinRange(b[1], a)) {\n            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n          } else {\n            merged.push(a = b);\n          }\n        } // Finally, find the largest gap between the merged ranges.\n        // The final bounding box will be the inverse of this gap.\n\n\n        var best = -Infinity,\n            dλ;\n\n        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {\n          b = merged[i];\n          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];\n        }\n      }\n\n      ranges = range = null;\n      return λ0 === Infinity || φ0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[λ0, φ0], [λ1, φ1]];\n    };\n  }();\n\n  d3.geo.centroid = function (object) {\n    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;\n    d3.geo.stream(object, d3_geo_centroid);\n    var x = d3_geo_centroidX2,\n        y = d3_geo_centroidY2,\n        z = d3_geo_centroidZ2,\n        m = x * x + y * y + z * z; // If the area-weighted centroid is undefined, fall back to length-weighted centroid.\n\n    if (m < ε2) {\n      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1; // If the feature has zero length, fall back to arithmetic mean of point vectors.\n\n      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;\n      m = x * x + y * y + z * z; // If the feature still has an undefined centroid, then return.\n\n      if (m < ε2) return [NaN, NaN];\n    }\n\n    return [Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees];\n  };\n\n  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;\n  var d3_geo_centroid = {\n    sphere: d3_noop,\n    point: d3_geo_centroidPoint,\n    lineStart: d3_geo_centroidLineStart,\n    lineEnd: d3_geo_centroidLineEnd,\n    polygonStart: function polygonStart() {\n      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;\n    },\n    polygonEnd: function polygonEnd() {\n      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;\n    }\n  }; // Arithmetic mean of Cartesian vectors.\n\n  function d3_geo_centroidPoint(λ, φ) {\n    λ *= d3_radians;\n    var cosφ = Math.cos(φ *= d3_radians);\n    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));\n  }\n\n  function d3_geo_centroidPointXYZ(x, y, z) {\n    ++d3_geo_centroidW0;\n    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;\n    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;\n    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;\n  }\n\n  function d3_geo_centroidLineStart() {\n    var x0, y0, z0; // previous point\n\n    d3_geo_centroid.point = function (λ, φ) {\n      λ *= d3_radians;\n      var cosφ = Math.cos(φ *= d3_radians);\n      x0 = cosφ * Math.cos(λ);\n      y0 = cosφ * Math.sin(λ);\n      z0 = Math.sin(φ);\n      d3_geo_centroid.point = nextPoint;\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    };\n\n    function nextPoint(λ, φ) {\n      λ *= d3_radians;\n      var cosφ = Math.cos(φ *= d3_radians),\n          x = cosφ * Math.cos(λ),\n          y = cosφ * Math.sin(λ),\n          z = Math.sin(φ),\n          w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n      d3_geo_centroidW1 += w;\n      d3_geo_centroidX1 += w * (x0 + (x0 = x));\n      d3_geo_centroidY1 += w * (y0 + (y0 = y));\n      d3_geo_centroidZ1 += w * (z0 + (z0 = z));\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    }\n  }\n\n  function d3_geo_centroidLineEnd() {\n    d3_geo_centroid.point = d3_geo_centroidPoint;\n  } // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,\n  // J. Applied Mechanics 42, 239 (1975).\n\n\n  function d3_geo_centroidRingStart() {\n    var λ00, φ00, // first point\n    x0, y0, z0; // previous point\n\n    d3_geo_centroid.point = function (λ, φ) {\n      λ00 = λ, φ00 = φ;\n      d3_geo_centroid.point = nextPoint;\n      λ *= d3_radians;\n      var cosφ = Math.cos(φ *= d3_radians);\n      x0 = cosφ * Math.cos(λ);\n      y0 = cosφ * Math.sin(λ);\n      z0 = Math.sin(φ);\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    };\n\n    d3_geo_centroid.lineEnd = function () {\n      nextPoint(λ00, φ00);\n      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;\n      d3_geo_centroid.point = d3_geo_centroidPoint;\n    };\n\n    function nextPoint(λ, φ) {\n      λ *= d3_radians;\n      var cosφ = Math.cos(φ *= d3_radians),\n          x = cosφ * Math.cos(λ),\n          y = cosφ * Math.sin(λ),\n          z = Math.sin(φ),\n          cx = y0 * z - z0 * y,\n          cy = z0 * x - x0 * z,\n          cz = x0 * y - y0 * x,\n          m = Math.sqrt(cx * cx + cy * cy + cz * cz),\n          u = x0 * x + y0 * y + z0 * z,\n          v = m && -d3_acos(u) / m,\n          // area weight\n      w = Math.atan2(m, u); // line weight\n\n      d3_geo_centroidX2 += v * cx;\n      d3_geo_centroidY2 += v * cy;\n      d3_geo_centroidZ2 += v * cz;\n      d3_geo_centroidW1 += w;\n      d3_geo_centroidX1 += w * (x0 + (x0 = x));\n      d3_geo_centroidY1 += w * (y0 + (y0 = y));\n      d3_geo_centroidZ1 += w * (z0 + (z0 = z));\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    }\n  } // TODO Unify this code with d3.geom.polygon area?\n\n\n  var d3_geo_pathAreaSum,\n      d3_geo_pathAreaPolygon,\n      d3_geo_pathArea = {\n    point: d3_noop,\n    lineStart: d3_noop,\n    lineEnd: d3_noop,\n    // Only count area for polygon rings.\n    polygonStart: function polygonStart() {\n      d3_geo_pathAreaPolygon = 0;\n      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;\n    },\n    polygonEnd: function polygonEnd() {\n      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;\n      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);\n    }\n  };\n\n  function d3_geo_pathAreaRingStart() {\n    var x00, y00, x0, y0; // For the first point, …\n\n    d3_geo_pathArea.point = function (x, y) {\n      d3_geo_pathArea.point = nextPoint;\n      x00 = x0 = x, y00 = y0 = y;\n    }; // For subsequent points, …\n\n\n    function nextPoint(x, y) {\n      d3_geo_pathAreaPolygon += y0 * x - x0 * y;\n      x0 = x, y0 = y;\n    } // For the last point, return to the start.\n\n\n    d3_geo_pathArea.lineEnd = function () {\n      nextPoint(x00, y00);\n    };\n  }\n\n  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;\n  var d3_geo_pathBounds = {\n    point: d3_geo_pathBoundsPoint,\n    lineStart: d3_noop,\n    lineEnd: d3_noop,\n    polygonStart: d3_noop,\n    polygonEnd: d3_noop\n  };\n\n  function d3_geo_pathBoundsPoint(x, y) {\n    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;\n    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;\n    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;\n    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;\n  }\n\n  function d3_geo_pathBuffer() {\n    var pointCircle = d3_geo_pathBufferCircle(4.5),\n        buffer = [];\n    var stream = {\n      point: point,\n      // While inside a line, override point to moveTo then lineTo.\n      lineStart: function lineStart() {\n        stream.point = pointLineStart;\n      },\n      lineEnd: lineEnd,\n      // While inside a polygon, override lineEnd to closePath.\n      polygonStart: function polygonStart() {\n        stream.lineEnd = lineEndPolygon;\n      },\n      polygonEnd: function polygonEnd() {\n        stream.lineEnd = lineEnd;\n        stream.point = point;\n      },\n      pointRadius: function pointRadius(_) {\n        pointCircle = d3_geo_pathBufferCircle(_);\n        return stream;\n      },\n      result: function result() {\n        if (buffer.length) {\n          var result = buffer.join(\"\");\n          buffer = [];\n          return result;\n        }\n      }\n    };\n\n    function point(x, y) {\n      buffer.push(\"M\", x, \",\", y, pointCircle);\n    }\n\n    function pointLineStart(x, y) {\n      buffer.push(\"M\", x, \",\", y);\n      stream.point = pointLine;\n    }\n\n    function pointLine(x, y) {\n      buffer.push(\"L\", x, \",\", y);\n    }\n\n    function lineEnd() {\n      stream.point = point;\n    }\n\n    function lineEndPolygon() {\n      buffer.push(\"Z\");\n    }\n\n    return stream;\n  }\n\n  function d3_geo_pathBufferCircle(radius) {\n    return \"m0,\" + radius + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + 2 * radius + \"z\";\n  } // TODO Unify this code with d3.geom.polygon centroid?\n  // TODO Enforce positive area for exterior, negative area for interior?\n\n\n  var d3_geo_pathCentroid = {\n    point: d3_geo_pathCentroidPoint,\n    // For lines, weight by length.\n    lineStart: d3_geo_pathCentroidLineStart,\n    lineEnd: d3_geo_pathCentroidLineEnd,\n    // For polygons, weight by area.\n    polygonStart: function polygonStart() {\n      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;\n    },\n    polygonEnd: function polygonEnd() {\n      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\n      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;\n      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;\n    }\n  };\n\n  function d3_geo_pathCentroidPoint(x, y) {\n    d3_geo_centroidX0 += x;\n    d3_geo_centroidY0 += y;\n    ++d3_geo_centroidZ0;\n  }\n\n  function d3_geo_pathCentroidLineStart() {\n    var x0, y0;\n\n    d3_geo_pathCentroid.point = function (x, y) {\n      d3_geo_pathCentroid.point = nextPoint;\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n    };\n\n    function nextPoint(x, y) {\n      var dx = x - x0,\n          dy = y - y0,\n          z = Math.sqrt(dx * dx + dy * dy);\n      d3_geo_centroidX1 += z * (x0 + x) / 2;\n      d3_geo_centroidY1 += z * (y0 + y) / 2;\n      d3_geo_centroidZ1 += z;\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n    }\n  }\n\n  function d3_geo_pathCentroidLineEnd() {\n    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\n  }\n\n  function d3_geo_pathCentroidRingStart() {\n    var x00, y00, x0, y0; // For the first point, …\n\n    d3_geo_pathCentroid.point = function (x, y) {\n      d3_geo_pathCentroid.point = nextPoint;\n      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);\n    }; // For subsequent points, …\n\n\n    function nextPoint(x, y) {\n      var dx = x - x0,\n          dy = y - y0,\n          z = Math.sqrt(dx * dx + dy * dy);\n      d3_geo_centroidX1 += z * (x0 + x) / 2;\n      d3_geo_centroidY1 += z * (y0 + y) / 2;\n      d3_geo_centroidZ1 += z;\n      z = y0 * x - x0 * y;\n      d3_geo_centroidX2 += z * (x0 + x);\n      d3_geo_centroidY2 += z * (y0 + y);\n      d3_geo_centroidZ2 += z * 3;\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n    } // For the last point, return to the start.\n\n\n    d3_geo_pathCentroid.lineEnd = function () {\n      nextPoint(x00, y00);\n    };\n  }\n\n  function d3_geo_pathContext(context) {\n    var _pointRadius = 4.5;\n    var stream = {\n      point: point,\n      // While inside a line, override point to moveTo then lineTo.\n      lineStart: function lineStart() {\n        stream.point = pointLineStart;\n      },\n      lineEnd: lineEnd,\n      // While inside a polygon, override lineEnd to closePath.\n      polygonStart: function polygonStart() {\n        stream.lineEnd = lineEndPolygon;\n      },\n      polygonEnd: function polygonEnd() {\n        stream.lineEnd = lineEnd;\n        stream.point = point;\n      },\n      pointRadius: function pointRadius(_) {\n        _pointRadius = _;\n        return stream;\n      },\n      result: d3_noop\n    };\n\n    function point(x, y) {\n      context.moveTo(x, y);\n      context.arc(x, y, _pointRadius, 0, τ);\n    }\n\n    function pointLineStart(x, y) {\n      context.moveTo(x, y);\n      stream.point = pointLine;\n    }\n\n    function pointLine(x, y) {\n      context.lineTo(x, y);\n    }\n\n    function lineEnd() {\n      stream.point = point;\n    }\n\n    function lineEndPolygon() {\n      context.closePath();\n    }\n\n    return stream;\n  }\n\n  function d3_geo_resample(project) {\n    var δ2 = .5,\n        // precision, px²\n    cosMinDistance = Math.cos(30 * d3_radians),\n        // cos(minimum angular distance)\n    maxDepth = 16;\n\n    function resample(stream) {\n      return (maxDepth ? resampleRecursive : resampleNone)(stream);\n    }\n\n    function resampleNone(stream) {\n      return d3_geo_transformPoint(stream, function (x, y) {\n        x = project(x, y);\n        stream.point(x[0], x[1]);\n      });\n    }\n\n    function resampleRecursive(stream) {\n      var λ00, φ00, x00, y00, a00, b00, c00, // first point\n      λ0, x0, y0, a0, b0, c0; // previous point\n\n      var resample = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function polygonStart() {\n          stream.polygonStart();\n          resample.lineStart = ringStart;\n        },\n        polygonEnd: function polygonEnd() {\n          stream.polygonEnd();\n          resample.lineStart = lineStart;\n        }\n      };\n\n      function point(x, y) {\n        x = project(x, y);\n        stream.point(x[0], x[1]);\n      }\n\n      function lineStart() {\n        x0 = NaN;\n        resample.point = linePoint;\n        stream.lineStart();\n      }\n\n      function linePoint(λ, φ) {\n        var c = d3_geo_cartesian([λ, φ]),\n            p = project(λ, φ);\n        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n        stream.point(x0, y0);\n      }\n\n      function lineEnd() {\n        resample.point = point;\n        stream.lineEnd();\n      }\n\n      function ringStart() {\n        lineStart();\n        resample.point = ringPoint;\n        resample.lineEnd = ringEnd;\n      }\n\n      function ringPoint(λ, φ) {\n        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n        resample.point = linePoint;\n      }\n\n      function ringEnd() {\n        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);\n        resample.lineEnd = lineEnd;\n        lineEnd();\n      }\n\n      return resample;\n    }\n\n    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {\n      var dx = x1 - x0,\n          dy = y1 - y0,\n          d2 = dx * dx + dy * dy;\n\n      if (d2 > 4 * δ2 && depth--) {\n        var a = a0 + a1,\n            b = b0 + b1,\n            c = c0 + c1,\n            m = Math.sqrt(a * a + b * b + c * c),\n            φ2 = Math.asin(c /= m),\n            λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a),\n            p = project(λ2, φ2),\n            x2 = p[0],\n            y2 = p[1],\n            dx2 = x2 - x0,\n            dy2 = y2 - y0,\n            dz = dy * dx2 - dx * dy2;\n\n        if (dz * dz / d2 > δ2 // perpendicular projected distance\n        || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 // midpoint close to an end\n        || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {\n          // angular distance\n          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);\n          stream.point(x2, y2);\n          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);\n        }\n      }\n    }\n\n    resample.precision = function (_) {\n      if (!arguments.length) return Math.sqrt(δ2);\n      maxDepth = (δ2 = _ * _) > 0 && 16;\n      return resample;\n    };\n\n    return resample;\n  }\n\n  d3.geo.path = function () {\n    var pointRadius = 4.5,\n        projection,\n        context,\n        projectStream,\n        contextStream,\n        cacheStream;\n\n    function path(object) {\n      if (object) {\n        if (typeof pointRadius === \"function\") contextStream.pointRadius(+pointRadius.apply(this, arguments));\n        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);\n        d3.geo.stream(object, cacheStream);\n      }\n\n      return contextStream.result();\n    }\n\n    path.area = function (object) {\n      d3_geo_pathAreaSum = 0;\n      d3.geo.stream(object, projectStream(d3_geo_pathArea));\n      return d3_geo_pathAreaSum;\n    };\n\n    path.centroid = function (object) {\n      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;\n      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));\n      return d3_geo_centroidZ2 ? [d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2] : d3_geo_centroidZ1 ? [d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1] : d3_geo_centroidZ0 ? [d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0] : [NaN, NaN];\n    };\n\n    path.bounds = function (object) {\n      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);\n      d3.geo.stream(object, projectStream(d3_geo_pathBounds));\n      return [[d3_geo_pathBoundsX0, d3_geo_pathBoundsY0], [d3_geo_pathBoundsX1, d3_geo_pathBoundsY1]];\n    };\n\n    path.projection = function (_) {\n      if (!arguments.length) return projection;\n      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;\n      return reset();\n    };\n\n    path.context = function (_) {\n      if (!arguments.length) return context;\n      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);\n      if (typeof pointRadius !== \"function\") contextStream.pointRadius(pointRadius);\n      return reset();\n    };\n\n    path.pointRadius = function (_) {\n      if (!arguments.length) return pointRadius;\n      pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n      return path;\n    };\n\n    function reset() {\n      cacheStream = null;\n      return path;\n    }\n\n    return path.projection(d3.geo.albersUsa()).context(null);\n  };\n\n  function d3_geo_pathProjectStream(project) {\n    var resample = d3_geo_resample(function (x, y) {\n      return project([x * d3_degrees, y * d3_degrees]);\n    });\n    return function (stream) {\n      return d3_geo_projectionRadians(resample(stream));\n    };\n  }\n\n  d3.geo.transform = function (methods) {\n    return {\n      stream: function stream(_stream2) {\n        var transform = new d3_geo_transform(_stream2);\n\n        for (var k in methods) {\n          transform[k] = methods[k];\n        }\n\n        return transform;\n      }\n    };\n  };\n\n  function d3_geo_transform(stream) {\n    this.stream = stream;\n  }\n\n  d3_geo_transform.prototype = {\n    point: function point(x, y) {\n      this.stream.point(x, y);\n    },\n    sphere: function sphere() {\n      this.stream.sphere();\n    },\n    lineStart: function lineStart() {\n      this.stream.lineStart();\n    },\n    lineEnd: function lineEnd() {\n      this.stream.lineEnd();\n    },\n    polygonStart: function polygonStart() {\n      this.stream.polygonStart();\n    },\n    polygonEnd: function polygonEnd() {\n      this.stream.polygonEnd();\n    }\n  };\n\n  function d3_geo_transformPoint(stream, point) {\n    return {\n      point: point,\n      sphere: function sphere() {\n        stream.sphere();\n      },\n      lineStart: function lineStart() {\n        stream.lineStart();\n      },\n      lineEnd: function lineEnd() {\n        stream.lineEnd();\n      },\n      polygonStart: function polygonStart() {\n        stream.polygonStart();\n      },\n      polygonEnd: function polygonEnd() {\n        stream.polygonEnd();\n      }\n    };\n  }\n\n  d3.geo.projection = d3_geo_projection;\n  d3.geo.projectionMutator = d3_geo_projectionMutator;\n\n  function d3_geo_projection(project) {\n    return d3_geo_projectionMutator(function () {\n      return project;\n    })();\n  }\n\n  function d3_geo_projectionMutator(projectAt) {\n    var project,\n        rotate,\n        projectRotate,\n        projectResample = d3_geo_resample(function (x, y) {\n      x = project(x, y);\n      return [x[0] * k + δx, δy - x[1] * k];\n    }),\n        k = 150,\n        // scale\n    x = 480,\n        y = 250,\n        // translate\n    λ = 0,\n        φ = 0,\n        // center\n    δλ = 0,\n        δφ = 0,\n        δγ = 0,\n        // rotate\n    δx,\n        δy,\n        // center\n    preclip = d3_geo_clipAntimeridian,\n        postclip = d3_identity,\n        clipAngle = null,\n        clipExtent = null,\n        stream;\n\n    function projection(point) {\n      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);\n      return [point[0] * k + δx, δy - point[1] * k];\n    }\n\n    function invert(point) {\n      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);\n      return point && [point[0] * d3_degrees, point[1] * d3_degrees];\n    }\n\n    projection.stream = function (output) {\n      if (stream) stream.valid = false;\n      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));\n      stream.valid = true; // allow caching by d3.geo.path\n\n      return stream;\n    };\n\n    projection.clipAngle = function (_) {\n      if (!arguments.length) return clipAngle;\n      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);\n      return invalidate();\n    };\n\n    projection.clipExtent = function (_) {\n      if (!arguments.length) return clipExtent;\n      clipExtent = _;\n      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;\n      return invalidate();\n    };\n\n    projection.scale = function (_) {\n      if (!arguments.length) return k;\n      k = +_;\n      return reset();\n    };\n\n    projection.translate = function (_) {\n      if (!arguments.length) return [x, y];\n      x = +_[0];\n      y = +_[1];\n      return reset();\n    };\n\n    projection.center = function (_) {\n      if (!arguments.length) return [λ * d3_degrees, φ * d3_degrees];\n      λ = _[0] % 360 * d3_radians;\n      φ = _[1] % 360 * d3_radians;\n      return reset();\n    };\n\n    projection.rotate = function (_) {\n      if (!arguments.length) return [δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees];\n      δλ = _[0] % 360 * d3_radians;\n      δφ = _[1] % 360 * d3_radians;\n      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;\n      return reset();\n    };\n\n    d3.rebind(projection, projectResample, \"precision\");\n\n    function reset() {\n      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);\n      var center = project(λ, φ);\n      δx = x - center[0] * k;\n      δy = y + center[1] * k;\n      return invalidate();\n    }\n\n    function invalidate() {\n      if (stream) stream.valid = false, stream = null;\n      return projection;\n    }\n\n    return function () {\n      project = projectAt.apply(this, arguments);\n      projection.invert = project.invert && invert;\n      return reset();\n    };\n  }\n\n  function d3_geo_projectionRadians(stream) {\n    return d3_geo_transformPoint(stream, function (x, y) {\n      stream.point(x * d3_radians, y * d3_radians);\n    });\n  }\n\n  function d3_geo_mercator(λ, φ) {\n    return [λ, Math.log(Math.tan(π / 4 + φ / 2))];\n  }\n\n  d3_geo_mercator.invert = function (x, y) {\n    return [x, 2 * Math.atan(Math.exp(y)) - halfπ];\n  };\n\n  function d3_geo_mercatorProjection(project) {\n    var m = d3_geo_projection(project),\n        scale = m.scale,\n        translate = m.translate,\n        clipExtent = m.clipExtent,\n        clipAuto;\n\n    m.scale = function () {\n      var v = scale.apply(m, arguments);\n      return v === m ? clipAuto ? m.clipExtent(null) : m : v;\n    };\n\n    m.translate = function () {\n      var v = translate.apply(m, arguments);\n      return v === m ? clipAuto ? m.clipExtent(null) : m : v;\n    };\n\n    m.clipExtent = function (_) {\n      var v = clipExtent.apply(m, arguments);\n\n      if (v === m) {\n        if (clipAuto = _ == null) {\n          var k = π * scale(),\n              t = translate();\n          clipExtent([[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]]);\n        }\n      } else if (clipAuto) {\n        v = null;\n      }\n\n      return v;\n    };\n\n    return m.clipExtent(null);\n  }\n\n  (d3.geo.mercator = function () {\n    return d3_geo_mercatorProjection(d3_geo_mercator);\n  }).raw = d3_geo_mercator;\n  if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (d3),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}\n  this.d3 = d3;\n}();\n\n//# sourceURL=webpack:///./dist/d3.js?");

/***/ }),

/***/ "./lib/base64.js":
/*!***********************!*\
  !*** ./lib/base64.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\r\n * $Id: base64.js,v 2.12 2013/05/06 07:54:20 dankogai Exp dankogai $\r\n *\r\n *  Licensed under the MIT license.\r\n *    http://opensource.org/licenses/mit-license\r\n *\r\n *  References:\r\n *    http://en.wikipedia.org/wiki/Base64\r\n */\n(function (global) {\n  'use strict';\n\n  if (global.Base64) return;\n  var version = \"2.1.2\"; // if node.js, we use Buffer\n\n  var buffer;\n\n  if ( true && module.exports) {\n    buffer = __webpack_require__(/*! buffer */ \"./node_modules/_buffer@4.9.2@buffer/index.js\").Buffer;\n  } // constants\n\n\n  var b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n  var b64tab = function (bin) {\n    var t = {};\n\n    for (var i = 0, l = bin.length; i < l; i++) {\n      t[bin.charAt(i)] = i;\n    }\n\n    return t;\n  }(b64chars);\n\n  var fromCharCode = String.fromCharCode; // encoder stuff\n\n  var cb_utob = function cb_utob(c) {\n    if (c.length < 2) {\n      var cc = c.charCodeAt(0);\n      return cc < 0x80 ? c : cc < 0x800 ? fromCharCode(0xc0 | cc >>> 6) + fromCharCode(0x80 | cc & 0x3f) : fromCharCode(0xe0 | cc >>> 12 & 0x0f) + fromCharCode(0x80 | cc >>> 6 & 0x3f) + fromCharCode(0x80 | cc & 0x3f);\n    } else {\n      var cc = 0x10000 + (c.charCodeAt(0) - 0xD800) * 0x400 + (c.charCodeAt(1) - 0xDC00);\n      return fromCharCode(0xf0 | cc >>> 18 & 0x07) + fromCharCode(0x80 | cc >>> 12 & 0x3f) + fromCharCode(0x80 | cc >>> 6 & 0x3f) + fromCharCode(0x80 | cc & 0x3f);\n    }\n  };\n\n  var re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n\n  var utob = function utob(u) {\n    return u.replace(re_utob, cb_utob);\n  };\n\n  var cb_encode = function cb_encode(ccc) {\n    var padlen = [0, 2, 1][ccc.length % 3],\n        ord = ccc.charCodeAt(0) << 16 | (ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8 | (ccc.length > 2 ? ccc.charCodeAt(2) : 0),\n        chars = [b64chars.charAt(ord >>> 18), b64chars.charAt(ord >>> 12 & 63), padlen >= 2 ? '=' : b64chars.charAt(ord >>> 6 & 63), padlen >= 1 ? '=' : b64chars.charAt(ord & 63)];\n    return chars.join('');\n  };\n\n  var btoa = global.btoa || function (b) {\n    return b.replace(/[\\s\\S]{1,3}/g, cb_encode);\n  };\n\n  var _encode = buffer ? function (u) {\n    return new buffer(u).toString('base64');\n  } : function (u) {\n    return btoa(utob(u));\n  };\n\n  var encode = function encode(u, urisafe) {\n    return !urisafe ? _encode(u) : _encode(u).replace(/[+\\/]/g, function (m0) {\n      return m0 == '+' ? '-' : '_';\n    }).replace(/=/g, '');\n  };\n\n  var encodeURI = function encodeURI(u) {\n    return encode(u, true);\n  }; // decoder stuff\n\n\n  var re_btou = new RegExp(['[\\xC0-\\xDF][\\x80-\\xBF]', '[\\xE0-\\xEF][\\x80-\\xBF]{2}', '[\\xF0-\\xF7][\\x80-\\xBF]{3}'].join('|'), 'g');\n\n  var cb_btou = function cb_btou(cccc) {\n    switch (cccc.length) {\n      case 4:\n        var cp = (0x07 & cccc.charCodeAt(0)) << 18 | (0x3f & cccc.charCodeAt(1)) << 12 | (0x3f & cccc.charCodeAt(2)) << 6 | 0x3f & cccc.charCodeAt(3),\n            offset = cp - 0x10000;\n        return fromCharCode((offset >>> 10) + 0xD800) + fromCharCode((offset & 0x3FF) + 0xDC00);\n\n      case 3:\n        return fromCharCode((0x0f & cccc.charCodeAt(0)) << 12 | (0x3f & cccc.charCodeAt(1)) << 6 | 0x3f & cccc.charCodeAt(2));\n\n      default:\n        return fromCharCode((0x1f & cccc.charCodeAt(0)) << 6 | 0x3f & cccc.charCodeAt(1));\n    }\n  };\n\n  var btou = function btou(b) {\n    return b.replace(re_btou, cb_btou);\n  };\n\n  var cb_decode = function cb_decode(cccc) {\n    var len = cccc.length,\n        padlen = len % 4,\n        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0) | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0) | (len > 2 ? b64tab[cccc.charAt(2)] << 6 : 0) | (len > 3 ? b64tab[cccc.charAt(3)] : 0),\n        chars = [fromCharCode(n >>> 16), fromCharCode(n >>> 8 & 0xff), fromCharCode(n & 0xff)];\n    chars.length -= [0, 0, 2, 1][padlen];\n    return chars.join('');\n  };\n\n  var atob = global.atob || function (a) {\n    return a.replace(/[\\s\\S]{1,4}/g, cb_decode);\n  };\n\n  var _decode = buffer ? function (a) {\n    return new buffer(a, 'base64').toString();\n  } : function (a) {\n    return btou(atob(a));\n  };\n\n  var decode = function decode(a) {\n    return _decode(a.replace(/[-_]/g, function (m0) {\n      return m0 == '-' ? '+' : '/';\n    }).replace(/[^A-Za-z0-9\\+\\/]/g, ''));\n  }; // export Base64\n\n\n  global.Base64 = {\n    VERSION: version,\n    atob: atob,\n    btoa: btoa,\n    fromBase64: decode,\n    toBase64: encode,\n    utob: utob,\n    encode: encode,\n    encodeURI: encodeURI,\n    btou: btou,\n    decode: decode\n  }; // if ES5 is available, make Base64.extendString() available\n\n  if (typeof Object.defineProperty === 'function') {\n    var noEnum = function noEnum(v) {\n      return {\n        value: v,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      };\n    };\n\n    global.Base64.extendString = function () {\n      Object.defineProperty(String.prototype, 'fromBase64', noEnum(function () {\n        return decode(this);\n      }));\n      Object.defineProperty(String.prototype, 'toBase64', noEnum(function (urisafe) {\n        return encode(this, urisafe);\n      }));\n      Object.defineProperty(String.prototype, 'toBase64URI', noEnum(function () {\n        return encode(this, true);\n      }));\n    };\n  } // that's it!\n\n})(this);\n\n//# sourceURL=webpack:///./lib/base64.js?");

/***/ }),

/***/ "./lib/blob.js":
/*!*********************!*\
  !*** ./lib/blob.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* Blob.js\r\n * A Blob implementation.\r\n * 2013-06-20\r\n * \r\n * By Eli Grey, http://eligrey.com\r\n * By Devin Samarin, https://github.com/eboyjr\r\n * License: X11/MIT\r\n *   See LICENSE.md\r\n */\n\n/*global self, unescape */\n\n/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,\r\n  plusplus: true */\n\n/*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */\nif (typeof Blob !== \"function\" || typeof URL === \"undefined\") if (typeof Blob === \"function\" && typeof webkitURL !== \"undefined\") self.URL = webkitURL;else var Blob = function (view) {\n  \"use strict\";\n\n  var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || view.MSBlobBuilder || function (view) {\n    var get_class = function get_class(object) {\n      return Object.prototype.toString.call(object).match(/^\\[object\\s(.*)\\]$/)[1];\n    },\n        FakeBlobBuilder = function BlobBuilder() {\n      this.data = [];\n    },\n        FakeBlob = function Blob(data, type, encoding) {\n      this.data = data;\n      this.size = data.length;\n      this.type = type;\n      this.encoding = encoding;\n    },\n        FBB_proto = FakeBlobBuilder.prototype,\n        FB_proto = FakeBlob.prototype,\n        FileReaderSync = view.FileReaderSync,\n        FileException = function FileException(type) {\n      this.code = this[this.name = type];\n    },\n        file_ex_codes = (\"NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR \" + \"NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR\").split(\" \"),\n        file_ex_code = file_ex_codes.length,\n        real_URL = view.URL || view.webkitURL || view,\n        real_create_object_URL = real_URL.createObjectURL,\n        real_revoke_object_URL = real_URL.revokeObjectURL,\n        URL = real_URL,\n        btoa = view.btoa,\n        atob = view.atob,\n        ArrayBuffer = view.ArrayBuffer,\n        Uint8Array = view.Uint8Array;\n\n    FakeBlob.fake = FB_proto.fake = true;\n\n    while (file_ex_code--) {\n      FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;\n    }\n\n    if (!real_URL.createObjectURL) {\n      URL = view.URL = {};\n    }\n\n    URL.createObjectURL = function (blob) {\n      var type = blob.type,\n          data_URI_header;\n\n      if (type === null) {\n        type = \"application/octet-stream\";\n      }\n\n      if (blob instanceof FakeBlob) {\n        data_URI_header = \"data:\" + type;\n\n        if (blob.encoding === \"base64\") {\n          return data_URI_header + \";base64,\" + blob.data;\n        } else if (blob.encoding === \"URI\") {\n          return data_URI_header + \",\" + decodeURIComponent(blob.data);\n        }\n\n        if (btoa) {\n          return data_URI_header + \";base64,\" + btoa(blob.data);\n        } else {\n          return data_URI_header + \",\" + encodeURIComponent(blob.data);\n        }\n      } else if (real_create_object_URL) {\n        return real_create_object_URL.call(real_URL, blob);\n      }\n    };\n\n    URL.revokeObjectURL = function (object_URL) {\n      if (object_URL.substring(0, 5) !== \"data:\" && real_revoke_object_URL) {\n        real_revoke_object_URL.call(real_URL, object_URL);\n      }\n    };\n\n    FBB_proto.append = function (data\n    /*, endings*/\n    ) {\n      var bb = this.data; // decode data to a binary string\n\n      if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {\n        var str = \"\",\n            buf = new Uint8Array(data),\n            i = 0,\n            buf_len = buf.length;\n\n        for (; i < buf_len; i++) {\n          str += String.fromCharCode(buf[i]);\n        }\n\n        bb.push(str);\n      } else if (get_class(data) === \"Blob\" || get_class(data) === \"File\") {\n        if (FileReaderSync) {\n          var fr = new FileReaderSync();\n          bb.push(fr.readAsBinaryString(data));\n        } else {\n          // async FileReader won't work as BlobBuilder is sync\n          throw new FileException(\"NOT_READABLE_ERR\");\n        }\n      } else if (data instanceof FakeBlob) {\n        if (data.encoding === \"base64\" && atob) {\n          bb.push(atob(data.data));\n        } else if (data.encoding === \"URI\") {\n          bb.push(decodeURIComponent(data.data));\n        } else if (data.encoding === \"raw\") {\n          bb.push(data.data);\n        }\n      } else {\n        if (typeof data !== \"string\") {\n          data += \"\"; // convert unsupported types to strings\n        } // decode UTF-16 to binary string\n\n\n        bb.push(unescape(encodeURIComponent(data)));\n      }\n    };\n\n    FBB_proto.getBlob = function (type) {\n      if (!arguments.length) {\n        type = null;\n      }\n\n      return new FakeBlob(this.data.join(\"\"), type, \"raw\");\n    };\n\n    FBB_proto.toString = function () {\n      return \"[object BlobBuilder]\";\n    };\n\n    FB_proto.slice = function (start, end, type) {\n      var args = arguments.length;\n\n      if (args < 3) {\n        type = null;\n      }\n\n      return new FakeBlob(this.data.slice(start, args > 1 ? end : this.data.length), type, this.encoding);\n    };\n\n    FB_proto.toString = function () {\n      return \"[object Blob]\";\n    };\n\n    return FakeBlobBuilder;\n  }(view);\n\n  return function Blob(blobParts, options) {\n    var type = options ? options.type || \"\" : \"\";\n    var builder = new BlobBuilder();\n\n    if (blobParts) {\n      for (var i = 0, len = blobParts.length; i < len; i++) {\n        builder.append(blobParts[i]);\n      }\n    }\n\n    return builder.getBlob(type);\n  };\n}(self);\n\n//# sourceURL=webpack:///./lib/blob.js?");

/***/ }),

/***/ "./lib/bucket.js":
/*!***********************!*\
  !*** ./lib/bucket.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function bucket() {\n  var event = d3.dispatch('chosen'),\n      deposits;\n  return {\n    deposit: deposit,\n    store: store\n  };\n\n  function deposit() {\n    return function (selection) {\n      deposits = selection;\n      selection.each(function () {\n        var sel = d3.select(this);\n        sel.attr('data-text', sel.text());\n      });\n    };\n  }\n\n  function store() {\n    var clone, dropped, dims;\n\n    function change() {\n      event.chosen(deposits.filter(function () {\n        return d3.select(this).classed('filled');\n      }).map(function (elems) {\n        return elems.map(function (e) {\n          return d3.select(e).text();\n        });\n      })[0]);\n    }\n\n    var drag = d3.behavior.drag().origin(function () {\n      // return { x: d3.event.pageX, y: d3.event.pageY };\n      return {\n        x: this.offsetLeft,\n        y: this.offsetTop\n      };\n    }).on('dragstart', function () {\n      clone = d3.select(this.parentNode.insertBefore(this.cloneNode(true), this));\n      d3.select(this).style('position', 'absolute').style('pointer-events', 'none');\n      dims = [this.offsetWidth, this.offsetHeight];\n    }).on('drag', function () {\n      d3.select(this).style('left', d3.event.x - dims[0] / 2 + 'px').style('top', d3.event.y - dims[1] / 2 + 'px');\n    }).on('dragend', function () {\n      var self = d3.select(this);\n      var target = d3.select(d3.event.sourceEvent.target);\n\n      if (target.classed('bucket')) {\n        target.text(self.text()).classed('filled', true);\n        target.append('span').classed('remove-button', true).on('click', function () {\n          target.text(target.attr('data-text')).classed('filled', false);\n          change();\n        });\n        self.remove();\n        clone.call(drag);\n        change();\n      } else {\n        self.remove();\n        clone.call(drag);\n      }\n    });\n    return d3.rebind(function (selection) {\n      selection.each(function () {\n        var sel = d3.select(this).call(drag);\n        sel.attr('data-text', sel.text());\n      });\n    }, event, 'on');\n  }\n}\n\n//# sourceURL=webpack:///./lib/bucket.js?");

/***/ }),

/***/ "./lib/codemirror/lib/codemirror.js":
/*!******************************************!*\
  !*** ./lib/codemirror/lib/codemirror.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n// CodeMirror version 3.14\n//\n// CodeMirror is the only global var we claim\nwindow.CodeMirror = function () {\n  \"use strict\"; // BROWSER SNIFFING\n  // Crude, but necessary to handle a number of hard-to-feature-detect\n  // bugs and behavior differences.\n\n  var gecko = /gecko\\/\\d/i.test(navigator.userAgent);\n  var ie = /MSIE \\d/.test(navigator.userAgent);\n  var ie_lt8 = ie && (document.documentMode == null || document.documentMode < 8);\n  var ie_lt9 = ie && (document.documentMode == null || document.documentMode < 9);\n  var webkit = /WebKit\\//.test(navigator.userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(navigator.userAgent);\n  var chrome = /Chrome\\//.test(navigator.userAgent);\n  var opera = /Opera\\//.test(navigator.userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var khtml = /KHTML\\//.test(navigator.userAgent);\n  var mac_geLion = /Mac OS X 1\\d\\D([7-9]|\\d\\d)\\D/.test(navigator.userAgent);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(navigator.userAgent);\n  var phantom = /PhantomJS/.test(navigator.userAgent);\n  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent); // This is woefully incomplete. Suggestions for alternative methods welcome.\n\n  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);\n  var mac = ios || /Mac/.test(navigator.platform);\n  var windows = /windows/i.test(navigator.platform);\n  var opera_version = opera && navigator.userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (opera_version) opera_version = Number(opera_version[1]); // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n\n  var flipCtrlCmd = mac && (qtwebkit || opera && (opera_version == null || opera_version < 12.11));\n  var captureMiddleClick = gecko || ie && !ie_lt9; // Optimize some code when these features are not used\n\n  var sawReadOnlySpans = false,\n      sawCollapsedSpans = false; // CONSTRUCTOR\n\n  function CodeMirror(place, options) {\n    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\n    this.options = options = options || {}; // Determine effective options based on given values and defaults.\n\n    for (var opt in defaults) {\n      if (!options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt)) options[opt] = defaults[opt];\n    }\n\n    setGuttersForLineNumbers(options);\n    var docStart = typeof options.value == \"string\" ? 0 : options.value.first;\n    var display = this.display = makeDisplay(place, docStart);\n    display.wrapper.CodeMirror = this;\n    updateGutters(this);\n    if (options.autofocus && !mobile) focusInput(this);\n    this.state = {\n      keyMaps: [],\n      overlays: [],\n      modeGen: 0,\n      overwrite: false,\n      focused: false,\n      suppressEdits: false,\n      pasteIncoming: false,\n      draggingText: false,\n      highlight: new Delayed()\n    };\n    themeChanged(this);\n    if (options.lineWrapping) this.display.wrapper.className += \" CodeMirror-wrap\";\n    var doc = options.value;\n    if (typeof doc == \"string\") doc = new Doc(options.value, options.mode);\n    operation(this, attachDoc)(this, doc); // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n\n    if (ie) setTimeout(bind(resetInput, this, true), 20);\n    registerEventHandlers(this); // IE throws unspecified error in certain cases, when\n    // trying to access activeElement before onload\n\n    var hasFocus;\n\n    try {\n      hasFocus = document.activeElement == display.input;\n    } catch (e) {}\n\n    if (hasFocus || options.autofocus && !mobile) setTimeout(bind(onFocus, this), 20);else onBlur(this);\n    operation(this, function () {\n      for (var opt in optionHandlers) {\n        if (optionHandlers.propertyIsEnumerable(opt)) optionHandlers[opt](this, options[opt], Init);\n      }\n\n      for (var i = 0; i < initHooks.length; ++i) {\n        initHooks[i](this);\n      }\n    })();\n  } // DISPLAY CONSTRUCTOR\n\n\n  function makeDisplay(place, docStart) {\n    var d = {};\n    var input = d.input = elt(\"textarea\", null, null, \"position: absolute; padding: 0; width: 1px; height: 1em; outline: none; font-size: 4px;\");\n    if (webkit) input.style.width = \"1000px\";else input.setAttribute(\"wrap\", \"off\"); // if border: 0; -- iOS fails to open keyboard (issue #1287)\n\n    if (ios) input.style.border = \"1px solid black\";\n    input.setAttribute(\"autocorrect\", \"off\");\n    input.setAttribute(\"autocapitalize\", \"off\");\n    input.setAttribute(\"spellcheck\", \"false\"); // Wraps and hides input textarea\n\n    d.inputDiv = elt(\"div\", [input], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\"); // The actual fake scrollbars.\n\n    d.scrollbarH = elt(\"div\", [elt(\"div\", null, null, \"height: 1px\")], \"CodeMirror-hscrollbar\");\n    d.scrollbarV = elt(\"div\", [elt(\"div\", null, null, \"width: 1px\")], \"CodeMirror-vscrollbar\");\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\"); // DIVs containing the selection and the actual code\n\n    d.lineDiv = elt(\"div\", null, \"CodeMirror-code\");\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\"); // Blinky cursor, and element used to ensure cursor fits at the end of a line\n\n    d.cursor = elt(\"div\", \"\\xA0\", \"CodeMirror-cursor\"); // Secondary cursor, shown when on a 'jump' in bi-directional text\n\n    d.otherCursor = elt(\"div\", \"\\xA0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"); // Used to measure text size\n\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\"); // Wraps everything that needs to exist inside the vertically-padded coordinate system\n\n    d.lineSpace = elt(\"div\", [d.measure, d.selectionDiv, d.lineDiv, d.cursor, d.otherCursor], null, \"position: relative; outline: none\"); // Moved around its parent to cover visible view\n\n    d.mover = elt(\"div\", [elt(\"div\", [d.lineSpace], \"CodeMirror-lines\")], null, \"position: relative\"); // Set to the height of the text, causes scrolling\n\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\"); // D is needed because behavior of elts with overflow: auto and padding is inconsistent across browsers\n\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerCutOff + \"px; width: 1px;\"); // Will contain the gutters, if any\n\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null; // Provides scrolling\n\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\"); // The element in which the editor lives.\n\n    d.wrapper = elt(\"div\", [d.inputDiv, d.scrollbarH, d.scrollbarV, d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\"); // Work around IE7 z-index bug\n\n    if (ie_lt8) {\n      d.gutters.style.zIndex = -1;\n      d.scroller.style.paddingRight = 0;\n    }\n\n    if (place.appendChild) place.appendChild(d.wrapper);else place(d.wrapper); // Needed to hide big blue blinking cursor on Mobile Safari\n\n    if (ios) input.style.width = \"0px\";\n    if (!webkit) d.scroller.draggable = true; // Needed to handle Tab key in KHTML\n\n    if (khtml) {\n      d.inputDiv.style.height = \"1px\";\n      d.inputDiv.style.position = \"absolute\";\n    } // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    else if (ie_lt8) d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth = \"18px\"; // Current visible range (may be bigger than the view window).\n\n\n    d.viewOffset = d.lastSizeC = 0;\n    d.showingFrom = d.showingTo = docStart; // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null; // See readInput and resetInput\n\n    d.prevInput = \"\"; // Set to true when a non-horizontal-scrolling widget is added. As\n    // an optimization, widget aligning is skipped when d is false.\n\n    d.alignWidgets = false; // Flag that indicates whether we currently expect input to appear\n    // (after some event like 'keypress' or 'input') and are polling\n    // intensively.\n\n    d.pollingFast = false; // Self-resetting timeout for the poller\n\n    d.poll = new Delayed();\n    d.cachedCharWidth = d.cachedTextHeight = null;\n    d.measureLineCache = [];\n    d.measureLineCachePos = 0; // Tracks when resetInput has punted to just putting a short\n    // string instead of the (large) selection.\n\n    d.inaccurateSelection = false; // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false; // Used for measuring wheel scrolling granularity\n\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n    return d;\n  } // STATE UPDATES\n  // Used to get the editor into a consistent state again when options change.\n\n\n  function loadMode(cm) {\n    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\n    cm.doc.iter(function (line) {\n      if (line.stateAfter) line.stateAfter = null;\n      if (line.styles) line.styles = null;\n    });\n    cm.doc.frontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) regChange(cm);\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      cm.display.wrapper.className += \" CodeMirror-wrap\";\n      cm.display.sizer.style.minWidth = \"\";\n    } else {\n      cm.display.wrapper.className = cm.display.wrapper.className.replace(\" CodeMirror-wrap\", \"\");\n      computeMaxLength(cm);\n    }\n\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function () {\n      updateScrollbars(cm);\n    }, 100);\n  }\n\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display),\n        wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function (line) {\n      if (lineIsHidden(cm.doc, line)) return 0;else if (wrapping) return (Math.ceil(line.text.length / perLine) || 1) * th;else return th;\n    };\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc,\n        est = estimateHeight(cm);\n    doc.iter(function (line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) updateLineHeight(line, estHeight);\n    });\n  }\n\n  function keyMapChanged(cm) {\n    var map = keyMap[cm.options.keyMap],\n        style = map.style;\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-keymap-\\S+/g, \"\") + (style ? \" cm-keymap-\" + style : \"\");\n    cm.state.disableInput = map.disableInput;\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") + cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  function guttersChanged(cm) {\n    updateGutters(cm);\n    regChange(cm);\n    setTimeout(function () {\n      alignHorizontally(cm);\n    }, 20);\n  }\n\n  function updateGutters(cm) {\n    var gutters = cm.display.gutters,\n        specs = cm.options.gutters;\n    removeChildren(gutters);\n\n    for (var i = 0; i < specs.length; ++i) {\n      var gutterClass = specs[i];\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n\n      if (gutterClass == \"CodeMirror-linenumbers\") {\n        cm.display.lineGutter = gElt;\n        gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n      }\n    }\n\n    gutters.style.display = i ? \"\" : \"none\";\n  }\n\n  function lineLength(doc, line) {\n    if (line.height == 0) return 0;\n    var len = line.text.length,\n        merged,\n        cur = line;\n\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find();\n      cur = getLine(doc, found.from.line);\n      len += found.from.ch - found.to.ch;\n    }\n\n    cur = line;\n\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found = merged.find();\n      len -= cur.text.length - found.from.ch;\n      cur = getLine(doc, found.to.line);\n      len += cur.text.length - found.to.ch;\n    }\n\n    return len;\n  }\n\n  function computeMaxLength(cm) {\n    var d = cm.display,\n        doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(doc, d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function (line) {\n      var len = lineLength(doc, line);\n\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  } // Make sure the gutters options contains the element\n  // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\n\n\n  function setGuttersForLineNumbers(options) {\n    var found = false;\n\n    for (var i = 0; i < options.gutters.length; ++i) {\n      if (options.gutters[i] == \"CodeMirror-linenumbers\") {\n        if (options.lineNumbers) found = true;else options.gutters.splice(i--, 1);\n      }\n    }\n\n    if (!found && options.lineNumbers) options.gutters.push(\"CodeMirror-linenumbers\");\n  } // SCROLLBARS\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content. Optionally force a scrollTop.\n\n\n  function updateScrollbars(cm) {\n    var d = cm.display,\n        docHeight = cm.doc.height;\n    var totalHeight = docHeight + paddingVert(d);\n    d.sizer.style.minHeight = d.heightForcer.style.top = totalHeight + \"px\";\n    d.gutters.style.height = Math.max(totalHeight, d.scroller.clientHeight - scrollerCutOff) + \"px\";\n    var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight);\n    var needsH = d.scroller.scrollWidth > d.scroller.clientWidth + 1;\n    var needsV = scrollHeight > d.scroller.clientHeight + 1;\n\n    if (needsV) {\n      d.scrollbarV.style.display = \"block\";\n      d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + \"px\" : \"0\";\n      d.scrollbarV.firstChild.style.height = scrollHeight - d.scroller.clientHeight + d.scrollbarV.clientHeight + \"px\";\n    } else d.scrollbarV.style.display = \"\";\n\n    if (needsH) {\n      d.scrollbarH.style.display = \"block\";\n      d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + \"px\" : \"0\";\n      d.scrollbarH.firstChild.style.width = d.scroller.scrollWidth - d.scroller.clientWidth + d.scrollbarH.clientWidth + \"px\";\n    } else d.scrollbarH.style.display = \"\";\n\n    if (needsH && needsV) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + \"px\";\n    } else d.scrollbarFiller.style.display = \"\";\n\n    if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = scrollbarWidth(d.measure) + \"px\";\n      d.gutterFiller.style.width = d.gutters.offsetWidth + \"px\";\n    } else d.gutterFiller.style.display = \"\";\n\n    if (mac_geLion && scrollbarWidth(d.measure) === 0) d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = mac_geMountainLion ? \"18px\" : \"12px\";\n  }\n\n  function visibleLines(display, doc, viewPort) {\n    var top = display.scroller.scrollTop,\n        height = display.wrapper.clientHeight;\n    if (typeof viewPort == \"number\") top = viewPort;else if (viewPort) {\n      top = viewPort.top;\n      height = viewPort.bottom - viewPort.top;\n    }\n    top = Math.floor(top - paddingTop(display));\n    var bottom = Math.ceil(top + height);\n    return {\n      from: _lineAtHeight(doc, top),\n      to: _lineAtHeight(doc, bottom)\n    };\n  } // LINE NUMBERS\n\n\n  function alignHorizontally(cm) {\n    var display = cm.display;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth,\n        l = comp + \"px\";\n\n    for (var n = display.lineDiv.firstChild; n; n = n.nextSibling) {\n      if (n.alignable) {\n        for (var i = 0, a = n.alignable; i < a.length; ++i) {\n          a[i].style.left = l;\n        }\n      }\n    }\n\n    if (cm.options.fixedGutter) display.gutters.style.left = comp + gutterW + \"px\";\n  }\n\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) return false;\n    var doc = cm.doc,\n        last = lineNumberFor(cm.options, doc.first + doc.size - 1),\n        display = cm.display;\n\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)], \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth,\n          padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      return true;\n    }\n\n    return false;\n  }\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n  }\n\n  function compensateForHScroll(display) {\n    return getRect(display.scroller).left - getRect(display.sizer).left;\n  } // DISPLAY DRAWING\n\n\n  function updateDisplay(cm, changes, viewPort) {\n    var oldFrom = cm.display.showingFrom,\n        oldTo = cm.display.showingTo,\n        updated;\n    var visible = visibleLines(cm.display, cm.doc, viewPort);\n\n    for (;;) {\n      if (!updateDisplayInner(cm, changes, visible)) break;\n      updated = true;\n      updateSelection(cm);\n      updateScrollbars(cm); // Clip forced viewport to actual scrollable area\n\n      if (viewPort) viewPort = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, typeof viewPort == \"number\" ? viewPort : viewPort.top);\n      visible = visibleLines(cm.display, cm.doc, viewPort);\n      if (visible.from >= cm.display.showingFrom && visible.to <= cm.display.showingTo) break;\n      changes = [];\n    }\n\n    if (updated) {\n      signalLater(cm, \"update\", cm);\n      if (cm.display.showingFrom != oldFrom || cm.display.showingTo != oldTo) signalLater(cm, \"viewportChange\", cm, cm.display.showingFrom, cm.display.showingTo);\n    }\n\n    return updated;\n  } // Uses a set of changes plus the current scroll position to\n  // determine which DOM updates have to be made, and makes the\n  // updates.\n\n\n  function updateDisplayInner(cm, changes, visible) {\n    var display = cm.display,\n        doc = cm.doc;\n\n    if (!display.wrapper.clientWidth) {\n      display.showingFrom = display.showingTo = doc.first;\n      display.viewOffset = 0;\n      return;\n    } // Bail out if the visible area is already rendered and nothing changed.\n\n\n    if (changes.length == 0 && visible.from > display.showingFrom && visible.to < display.showingTo) return;\n    if (maybeUpdateLineNumberWidth(cm)) changes = [{\n      from: doc.first,\n      to: doc.first + doc.size\n    }];\n    var gutterW = display.sizer.style.marginLeft = display.gutters.offsetWidth + \"px\";\n    display.scrollbarH.style.left = cm.options.fixedGutter ? gutterW : \"0\"; // Used to determine which lines need their line numbers updated\n\n    var positionsChangedFrom = Infinity;\n    if (cm.options.lineNumbers) for (var i = 0; i < changes.length; ++i) {\n      if (changes[i].diff) {\n        positionsChangedFrom = changes[i].from;\n        break;\n      }\n    }\n    var end = doc.first + doc.size;\n    var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, visible.to + cm.options.viewportMargin);\n    if (display.showingFrom < from && from - display.showingFrom < 20) from = Math.max(doc.first, display.showingFrom);\n    if (display.showingTo > to && display.showingTo - to < 20) to = Math.min(end, display.showingTo);\n\n    if (sawCollapsedSpans) {\n      from = lineNo(visualLine(doc, getLine(doc, from)));\n\n      while (to < end && lineIsHidden(doc, getLine(doc, to))) {\n        ++to;\n      }\n    } // Create a range of theoretically intact lines, and punch holes\n    // in that using the change info.\n\n\n    var intact = [{\n      from: Math.max(display.showingFrom, doc.first),\n      to: Math.min(display.showingTo, end)\n    }];\n    if (intact[0].from >= intact[0].to) intact = [];else intact = computeIntact(intact, changes); // When merged lines are present, we might have to reduce the\n    // intact ranges because changes in continued fragments of the\n    // intact lines do require the lines to be redrawn.\n\n    if (sawCollapsedSpans) for (var i = 0; i < intact.length; ++i) {\n      var range = intact[i],\n          merged;\n\n      while (merged = collapsedSpanAtEnd(getLine(doc, range.to - 1))) {\n        var newTo = merged.find().from.line;\n        if (newTo > range.from) range.to = newTo;else {\n          intact.splice(i--, 1);\n          break;\n        }\n      }\n    } // Clip off the parts that won't be visible\n\n    var intactLines = 0;\n\n    for (var i = 0; i < intact.length; ++i) {\n      var range = intact[i];\n      if (range.from < from) range.from = from;\n      if (range.to > to) range.to = to;\n      if (range.from >= range.to) intact.splice(i--, 1);else intactLines += range.to - range.from;\n    }\n\n    if (intactLines == to - from && from == display.showingFrom && to == display.showingTo) {\n      updateViewOffset(cm);\n      return;\n    }\n\n    intact.sort(function (a, b) {\n      return a.from - b.from;\n    }); // Avoid crashing on IE's \"unspecified error\" when in iframes\n\n    try {\n      var focused = document.activeElement;\n    } catch (e) {}\n\n    if (intactLines < (to - from) * .7) display.lineDiv.style.display = \"none\";\n    patchDisplay(cm, from, to, intact, positionsChangedFrom);\n    display.lineDiv.style.display = \"\";\n    if (focused && document.activeElement != focused && focused.offsetHeight) focused.focus();\n    var different = from != display.showingFrom || to != display.showingTo || display.lastSizeC != display.wrapper.clientHeight; // This is just a bogus formula that detects when the editor is\n    // resized or the font size changes.\n\n    if (different) {\n      display.lastSizeC = display.wrapper.clientHeight;\n      startWorker(cm, 400);\n    }\n\n    display.showingFrom = from;\n    display.showingTo = to;\n    var prevBottom = display.lineDiv.offsetTop;\n\n    for (var node = display.lineDiv.firstChild, height; node; node = node.nextSibling) {\n      if (node.lineObj) {\n        if (ie_lt8) {\n          var bot = node.offsetTop + node.offsetHeight;\n          height = bot - prevBottom;\n          prevBottom = bot;\n        } else {\n          var box = getRect(node);\n          height = box.bottom - box.top;\n        }\n\n        var diff = node.lineObj.height - height;\n        if (height < 2) height = textHeight(display);\n\n        if (diff > .001 || diff < -.001) {\n          updateLineHeight(node.lineObj, height);\n          var widgets = node.lineObj.widgets;\n          if (widgets) for (var i = 0; i < widgets.length; ++i) {\n            widgets[i].height = widgets[i].node.offsetHeight;\n          }\n        }\n      }\n    }\n\n    updateViewOffset(cm);\n    return true;\n  }\n\n  function updateViewOffset(cm) {\n    var off = cm.display.viewOffset = heightAtLine(cm, getLine(cm.doc, cm.display.showingFrom)); // Position the mover div to align with the current virtual scroll position\n\n    cm.display.mover.style.top = off + \"px\";\n  }\n\n  function computeIntact(intact, changes) {\n    for (var i = 0, l = changes.length || 0; i < l; ++i) {\n      var change = changes[i],\n          intact2 = [],\n          diff = change.diff || 0;\n\n      for (var j = 0, l2 = intact.length; j < l2; ++j) {\n        var range = intact[j];\n\n        if (change.to <= range.from && change.diff) {\n          intact2.push({\n            from: range.from + diff,\n            to: range.to + diff\n          });\n        } else if (change.to <= range.from || change.from >= range.to) {\n          intact2.push(range);\n        } else {\n          if (change.from > range.from) intact2.push({\n            from: range.from,\n            to: change.from\n          });\n          if (change.to < range.to) intact2.push({\n            from: change.to + diff,\n            to: range.to + diff\n          });\n        }\n      }\n\n      intact = intact2;\n    }\n\n    return intact;\n  }\n\n  function getDimensions(cm) {\n    var d = cm.display,\n        left = {},\n        width = {};\n\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      left[cm.options.gutters[i]] = n.offsetLeft;\n      width[cm.options.gutters[i]] = n.offsetWidth;\n    }\n\n    return {\n      fixedPos: compensateForHScroll(d),\n      gutterTotalWidth: d.gutters.offsetWidth,\n      gutterLeft: left,\n      gutterWidth: width,\n      wrapperWidth: d.wrapper.clientWidth\n    };\n  }\n\n  function patchDisplay(cm, from, to, intact, updateNumbersFrom) {\n    var dims = getDimensions(cm);\n    var display = cm.display,\n        lineNumbers = cm.options.lineNumbers;\n    if (!intact.length && (!webkit || !cm.display.currentWheelTarget)) removeChildren(display.lineDiv);\n    var container = display.lineDiv,\n        cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n\n      if (webkit && mac && cm.display.currentWheelTarget == node) {\n        node.style.display = \"none\";\n        node.lineObj = null;\n      } else {\n        node.parentNode.removeChild(node);\n      }\n\n      return next;\n    }\n\n    var nextIntact = intact.shift(),\n        lineN = from;\n    cm.doc.iter(from, to, function (line) {\n      if (nextIntact && nextIntact.to == lineN) nextIntact = intact.shift();\n\n      if (lineIsHidden(cm.doc, line)) {\n        if (line.height != 0) updateLineHeight(line, 0);\n        if (line.widgets && cur.previousSibling) for (var i = 0; i < line.widgets.length; ++i) {\n          var w = line.widgets[i];\n\n          if (w.showIfHidden) {\n            var prev = cur.previousSibling;\n\n            if (/pre/i.test(prev.nodeName)) {\n              var wrap = elt(\"div\", null, null, \"position: relative\");\n              prev.parentNode.replaceChild(wrap, prev);\n              wrap.appendChild(prev);\n              prev = wrap;\n            }\n\n            var wnode = prev.appendChild(elt(\"div\", [w.node], \"CodeMirror-linewidget\"));\n            if (!w.handleMouseEvents) wnode.ignoreEvents = true;\n            positionLineWidget(w, wnode, prev, dims);\n          }\n        }\n      } else if (nextIntact && nextIntact.from <= lineN && nextIntact.to > lineN) {\n        // This line is intact. Skip to the actual node. Update its\n        // line number if needed.\n        while (cur.lineObj != line) {\n          cur = rm(cur);\n        }\n\n        if (lineNumbers && updateNumbersFrom <= lineN && cur.lineNumber) setTextContent(cur.lineNumber, lineNumberFor(cm.options, lineN));\n        cur = cur.nextSibling;\n      } else {\n        // For lines with widgets, make an attempt to find and reuse\n        // the existing element, so that widgets aren't needlessly\n        // removed and re-inserted into the dom\n        if (line.widgets) for (var j = 0, search = cur, reuse; search && j < 20; ++j, search = search.nextSibling) {\n          if (search.lineObj == line && /div/i.test(search.nodeName)) {\n            reuse = search;\n            break;\n          }\n        } // This line needs to be generated.\n\n        var lineNode = buildLineElement(cm, line, lineN, dims, reuse);\n\n        if (lineNode != reuse) {\n          container.insertBefore(lineNode, cur);\n        } else {\n          while (cur != reuse) {\n            cur = rm(cur);\n          }\n\n          cur = cur.nextSibling;\n        }\n\n        lineNode.lineObj = line;\n      }\n\n      ++lineN;\n    });\n\n    while (cur) {\n      cur = rm(cur);\n    }\n  }\n\n  function buildLineElement(cm, line, lineNo, dims, reuse) {\n    var lineElement = lineContent(cm, line);\n    var markers = line.gutterMarkers,\n        display = cm.display,\n        wrap;\n    if (!cm.options.lineNumbers && !markers && !line.bgClass && !line.wrapClass && !line.widgets) return lineElement; // Lines with gutter elements, widgets or a background class need\n    // to be wrapped again, and have the extra elements added to the\n    // wrapper div\n\n    if (reuse) {\n      reuse.alignable = null;\n      var isOk = true,\n          widgetsSeen = 0,\n          insertBefore = null;\n\n      for (var n = reuse.firstChild, next; n; n = next) {\n        next = n.nextSibling;\n\n        if (!/\\bCodeMirror-linewidget\\b/.test(n.className)) {\n          reuse.removeChild(n);\n        } else {\n          for (var i = 0, first = true; i < line.widgets.length; ++i) {\n            var widget = line.widgets[i];\n\n            if (!widget.above) {\n              insertBefore = n;\n              first = false;\n            }\n\n            if (widget.node == n.firstChild) {\n              positionLineWidget(widget, n, reuse, dims);\n              ++widgetsSeen;\n              break;\n            }\n          }\n\n          if (i == line.widgets.length) {\n            isOk = false;\n            break;\n          }\n        }\n      }\n\n      reuse.insertBefore(lineElement, insertBefore);\n\n      if (isOk && widgetsSeen == line.widgets.length) {\n        wrap = reuse;\n        reuse.className = line.wrapClass || \"\";\n      }\n    }\n\n    if (!wrap) {\n      wrap = elt(\"div\", null, line.wrapClass, \"position: relative\");\n      wrap.appendChild(lineElement);\n    } // Kludge to make sure the styled element lies behind the selection (by z-index)\n\n\n    if (line.bgClass) wrap.insertBefore(elt(\"div\", null, line.bgClass + \" CodeMirror-linebackground\"), wrap.firstChild);\n\n    if (cm.options.lineNumbers || markers) {\n      var gutterWrap = wrap.insertBefore(elt(\"div\", null, null, \"position: absolute; left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"), wrap.firstChild);\n      if (cm.options.fixedGutter) (wrap.alignable || (wrap.alignable = [])).push(gutterWrap);\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"])) wrap.lineNumber = gutterWrap.appendChild(elt(\"div\", lineNumberFor(cm.options, lineNo), \"CodeMirror-linenumber CodeMirror-gutter-elt\", \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \" + display.lineNumInnerWidth + \"px\"));\n      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {\n        var id = cm.options.gutters[k],\n            found = markers.hasOwnProperty(id) && markers[id];\n        if (found) gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" + dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\n      }\n    }\n\n    if (ie_lt8) wrap.style.zIndex = 2;\n    if (line.widgets && wrap != reuse) for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i],\n          node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n      if (!widget.handleMouseEvents) node.ignoreEvents = true;\n      positionLineWidget(widget, node, wrap, dims);\n      if (widget.above) wrap.insertBefore(node, cm.options.lineNumbers && line.height != 0 ? gutterWrap : lineElement);else wrap.appendChild(node);\n      signalLater(widget, \"redraw\");\n    }\n    return wrap;\n  }\n\n  function positionLineWidget(widget, node, wrap, dims) {\n    if (widget.noHScroll) {\n      (wrap.alignable || (wrap.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n\n      node.style.width = width + \"px\";\n    }\n\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n    }\n  } // SELECTION / CURSOR\n\n\n  function updateSelection(cm) {\n    var display = cm.display;\n    var collapsed = posEq(cm.doc.sel.from, cm.doc.sel.to);\n    if (collapsed || cm.options.showCursorWhenSelecting) updateSelectionCursor(cm);else display.cursor.style.display = display.otherCursor.style.display = \"none\";\n    if (!collapsed) updateSelectionRange(cm);else display.selectionDiv.style.display = \"none\"; // Move the hidden textarea near the cursor to prevent scrolling artifacts\n\n    if (cm.options.moveInputWithCursor) {\n      var headPos = _cursorCoords(cm, cm.doc.sel.head, \"div\");\n\n      var wrapOff = getRect(display.wrapper),\n          lineOff = getRect(display.lineDiv);\n      display.inputDiv.style.top = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top)) + \"px\";\n      display.inputDiv.style.left = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left)) + \"px\";\n    }\n  } // No selection, plain cursor\n\n\n  function updateSelectionCursor(cm) {\n    var display = cm.display,\n        pos = _cursorCoords(cm, cm.doc.sel.head, \"div\");\n\n    display.cursor.style.left = pos.left + \"px\";\n    display.cursor.style.top = pos.top + \"px\";\n    display.cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n    display.cursor.style.display = \"\";\n\n    if (pos.other) {\n      display.otherCursor.style.display = \"\";\n      display.otherCursor.style.left = pos.other.left + \"px\";\n      display.otherCursor.style.top = pos.other.top + \"px\";\n      display.otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    } else {\n      display.otherCursor.style.display = \"none\";\n    }\n  } // Highlight selection\n\n\n  function updateSelectionRange(cm) {\n    var display = cm.display,\n        doc = cm.doc,\n        sel = cm.doc.sel;\n    var fragment = document.createDocumentFragment();\n    var clientWidth = display.lineSpace.offsetWidth,\n        pl = paddingLeft(cm.display);\n\n    function add(left, top, width, bottom) {\n      if (top < 0) top = 0;\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left + \"px; top: \" + top + \"px; width: \" + (width == null ? clientWidth - left : width) + \"px; height: \" + (bottom - top) + \"px\"));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n\n      function coords(ch, bias) {\n        return _charCoords(cm, Pos(line, ch), \"div\", lineObj, bias);\n      }\n\n      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {\n        var leftPos = coords(from, \"left\"),\n            rightPos,\n            left,\n            right;\n\n        if (from == to) {\n          rightPos = leftPos;\n          left = right = leftPos.left;\n        } else {\n          rightPos = coords(to - 1, \"right\");\n\n          if (dir == \"rtl\") {\n            var tmp = leftPos;\n            leftPos = rightPos;\n            rightPos = tmp;\n          }\n\n          left = leftPos.left;\n          right = rightPos.right;\n        }\n\n        if (fromArg == null && from == 0) left = pl;\n\n        if (rightPos.top - leftPos.top > 3) {\n          // Different lines, draw top part\n          add(left, leftPos.top, null, leftPos.bottom);\n          left = pl;\n          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\n        }\n\n        if (toArg == null && to == lineLen) right = clientWidth;\n        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left) start = leftPos;\n        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right) end = rightPos;\n        if (left < pl + 1) left = pl;\n        add(left, rightPos.top, right - left, rightPos.bottom);\n      });\n      return {\n        start: start,\n        end: end\n      };\n    }\n\n    if (sel.from.line == sel.to.line) {\n      drawForLine(sel.from.line, sel.from.ch, sel.to.ch);\n    } else {\n      var fromLine = getLine(doc, sel.from.line),\n          toLine = getLine(doc, sel.to.line);\n      var singleVLine = visualLine(doc, fromLine) == visualLine(doc, toLine);\n      var leftEnd = drawForLine(sel.from.line, sel.from.ch, singleVLine ? fromLine.text.length : null).end;\n      var rightStart = drawForLine(sel.to.line, singleVLine ? 0 : null, sel.to.ch).start;\n\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(pl, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n\n      if (leftEnd.bottom < rightStart.top) add(pl, leftEnd.bottom, null, rightStart.top);\n    }\n\n    removeChildrenAndAdd(display.selectionDiv, fragment);\n    display.selectionDiv.style.display = \"\";\n  } // Cursor-blinking\n\n\n  function restartBlink(cm) {\n    if (!cm.state.focused) return;\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursor.style.visibility = display.otherCursor.style.visibility = \"\";\n    display.blinker = setInterval(function () {\n      display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? \"\" : \"hidden\";\n    }, cm.options.cursorBlinkRate);\n  } // HIGHLIGHT WORKER\n\n\n  function startWorker(cm, time) {\n    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.showingTo) cm.state.highlight.set(time, bind(highlightWorker, cm));\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.frontier < doc.first) doc.frontier = doc.first;\n    if (doc.frontier >= cm.display.showingTo) return;\n    var end = +new Date() + cm.options.workTime;\n    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n    var changed = [],\n        prevChange;\n    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.showingTo + 500), function (line) {\n      if (doc.frontier >= cm.display.showingFrom) {\n        // Visible\n        var oldStyles = line.styles;\n        line.styles = highlightLine(cm, line, state);\n        var ischange = !oldStyles || oldStyles.length != line.styles.length;\n\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) {\n          ischange = oldStyles[i] != line.styles[i];\n        }\n\n        if (ischange) {\n          if (prevChange && prevChange.end == doc.frontier) prevChange.end++;else changed.push(prevChange = {\n            start: doc.frontier,\n            end: doc.frontier + 1\n          });\n        }\n\n        line.stateAfter = copyState(doc.mode, state);\n      } else {\n        processLine(cm, line, state);\n        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n      }\n\n      ++doc.frontier;\n\n      if (+new Date() > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true;\n      }\n    });\n    if (changed.length) operation(cm, function () {\n      for (var i = 0; i < changed.length; ++i) {\n        regChange(this, changed[i].start, changed[i].end);\n      }\n    })();\n  } // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n\n\n  function findStartLine(cm, n, precise) {\n    var minindent,\n        minline,\n        doc = cm.doc;\n\n    for (var search = n, lim = n - 100; search > lim; --search) {\n      if (search <= doc.first) return doc.first;\n      var line = getLine(doc, search - 1);\n      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n\n    return minline;\n  }\n\n  function getStateBefore(cm, n, precise) {\n    var doc = cm.doc,\n        display = cm.display;\n    if (!doc.mode.startState) return true;\n    var pos = findStartLine(cm, n, precise),\n        state = pos > doc.first && getLine(doc, pos - 1).stateAfter;\n    if (!state) state = startState(doc.mode);else state = copyState(doc.mode, state);\n    doc.iter(pos, n, function (line) {\n      processLine(cm, line, state);\n      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.showingFrom && pos < display.showingTo;\n      line.stateAfter = save ? copyState(doc.mode, state) : null;\n      ++pos;\n    });\n    return state;\n  } // POSITION MEASUREMENT\n\n\n  function paddingTop(display) {\n    return display.lineSpace.offsetTop;\n  }\n\n  function paddingVert(display) {\n    return display.mover.offsetHeight - display.lineSpace.offsetHeight;\n  }\n\n  function paddingLeft(display) {\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", null, null, \"text-align: left\")).appendChild(elt(\"span\", \"x\"));\n    return e.offsetLeft;\n  }\n\n  function measureChar(cm, line, ch, data, bias) {\n    var dir = -1;\n    data = data || measureLine(cm, line);\n\n    for (var pos = ch;; pos += dir) {\n      var r = data[pos];\n      if (r) break;\n      if (dir < 0 && pos == 0) dir = 1;\n    }\n\n    var rightV = (pos < ch || bias == \"right\") && r.topRight != null;\n    return {\n      left: pos < ch ? r.right : r.left,\n      right: pos > ch ? r.left : r.right,\n      top: rightV ? r.topRight : r.top,\n      bottom: rightV ? r.bottomRight : r.bottom\n    };\n  }\n\n  function findCachedMeasurement(cm, line) {\n    var cache = cm.display.measureLineCache;\n\n    for (var i = 0; i < cache.length; ++i) {\n      var memo = cache[i];\n      if (memo.text == line.text && memo.markedSpans == line.markedSpans && cm.display.scroller.clientWidth == memo.width && memo.classes == line.textClass + \"|\" + line.bgClass + \"|\" + line.wrapClass) return memo;\n    }\n  }\n\n  function clearCachedMeasurement(cm, line) {\n    var exists = findCachedMeasurement(cm, line);\n    if (exists) exists.text = exists.measure = exists.markedSpans = null;\n  }\n\n  function measureLine(cm, line) {\n    // First look in the cache\n    var cached = findCachedMeasurement(cm, line);\n    if (cached) return cached.measure; // Failing that, recompute and store result in cache\n\n    var measure = measureLineInner(cm, line);\n    var cache = cm.display.measureLineCache;\n    var memo = {\n      text: line.text,\n      width: cm.display.scroller.clientWidth,\n      markedSpans: line.markedSpans,\n      measure: measure,\n      classes: line.textClass + \"|\" + line.bgClass + \"|\" + line.wrapClass\n    };\n    if (cache.length == 16) cache[++cm.display.measureLineCachePos % 16] = memo;else cache.push(memo);\n    return measure;\n  }\n\n  function measureLineInner(cm, line) {\n    var display = cm.display,\n        measure = emptyArray(line.text.length);\n    var pre = lineContent(cm, line, measure); // IE does not cache element positions of inline elements between\n    // calls to getBoundingClientRect. This makes the loop below,\n    // which gathers the positions of all the characters on the line,\n    // do an amount of layout work quadratic to the number of\n    // characters. When line wrapping is off, we try to improve things\n    // by first subdividing the line into a bunch of inline blocks, so\n    // that IE can reuse most of the layout information from caches\n    // for those blocks. This does interfere with line wrapping, so it\n    // doesn't work when wrapping is on, but in that case the\n    // situation is slightly better, since IE does cache line-wrapping\n    // information and only recomputes per-line.\n\n    if (ie && !ie_lt8 && !cm.options.lineWrapping && pre.childNodes.length > 100) {\n      var fragment = document.createDocumentFragment();\n      var chunk = 10,\n          n = pre.childNodes.length;\n\n      for (var i = 0, chunks = Math.ceil(n / chunk); i < chunks; ++i) {\n        var wrap = elt(\"div\", null, null, \"display: inline-block\");\n\n        for (var j = 0; j < chunk && n; ++j) {\n          wrap.appendChild(pre.firstChild);\n          --n;\n        }\n\n        fragment.appendChild(wrap);\n      }\n\n      pre.appendChild(fragment);\n    }\n\n    removeChildrenAndAdd(display.measure, pre);\n    var outer = getRect(display.lineDiv);\n    var vranges = [],\n        data = emptyArray(line.text.length),\n        maxBot = pre.offsetHeight; // Work around an IE7/8 bug where it will sometimes have randomly\n    // replaced our pre with a clone at this point.\n\n    if (ie_lt9 && display.measure.first != pre) removeChildrenAndAdd(display.measure, pre);\n\n    function categorizeVSpan(top, bot) {\n      if (bot > maxBot) bot = maxBot;\n      if (top < 0) top = 0;\n\n      for (var j = 0; j < vranges.length; j += 2) {\n        var rtop = vranges[j],\n            rbot = vranges[j + 1];\n        if (rtop > bot || rbot < top) continue;\n\n        if (rtop <= top && rbot >= bot || top <= rtop && bot >= rbot || Math.min(bot, rbot) - Math.max(top, rtop) >= bot - top >> 1) {\n          vranges[j] = Math.min(top, rtop);\n          vranges[j + 1] = Math.max(bot, rbot);\n          return j;\n        }\n      }\n\n      vranges.push(top, bot);\n      return j;\n    }\n\n    for (var i = 0, cur; i < measure.length; ++i) {\n      if (cur = measure[i]) {\n        var size,\n            node = cur; // A widget might wrap, needs special care\n\n        if (/\\bCodeMirror-widget\\b/.test(cur.className) && cur.getClientRects) {\n          if (cur.firstChild.nodeType == 1) node = cur.firstChild;\n          var rects = node.getClientRects(),\n              rLeft = rects[0],\n              rRight = rects[rects.length - 1];\n\n          if (rects.length > 1) {\n            var vCatLeft = categorizeVSpan(rLeft.top - outer.top, rLeft.bottom - outer.top);\n            var vCatRight = categorizeVSpan(rRight.top - outer.top, rRight.bottom - outer.top);\n            data[i] = {\n              left: rLeft.left - outer.left,\n              right: rRight.right - outer.left,\n              top: vCatLeft,\n              topRight: vCatRight\n            };\n            continue;\n          }\n        }\n\n        size = getRect(node);\n        var vCat = categorizeVSpan(size.top - outer.top, size.bottom - outer.top);\n        var right = size.right;\n        if (cur.measureRight) right = getRect(cur.measureRight).left;\n        data[i] = {\n          left: size.left - outer.left,\n          right: right - outer.left,\n          top: vCat\n        };\n      }\n    }\n\n    for (var i = 0, cur; i < data.length; ++i) {\n      if (cur = data[i]) {\n        var vr = cur.top,\n            vrRight = cur.topRight;\n        cur.top = vranges[vr];\n        cur.bottom = vranges[vr + 1];\n\n        if (vrRight != null) {\n          cur.topRight = vranges[vrRight];\n          cur.bottomRight = vranges[vrRight + 1];\n        }\n      }\n    }\n\n    return data;\n  }\n\n  function measureLineWidth(cm, line) {\n    var hasBadSpan = false;\n    if (line.markedSpans) for (var i = 0; i < line.markedSpans; ++i) {\n      var sp = line.markedSpans[i];\n      if (sp.collapsed && (sp.to == null || sp.to == line.text.length)) hasBadSpan = true;\n    }\n    var cached = !hasBadSpan && findCachedMeasurement(cm, line);\n    if (cached) return measureChar(cm, line, line.text.length, cached.measure, \"right\").right;\n    var pre = lineContent(cm, line);\n    var end = pre.appendChild(zeroWidthElement(cm.display.measure));\n    removeChildrenAndAdd(cm.display.measure, pre);\n    return getRect(end).right - getRect(cm.display.lineDiv).left;\n  }\n\n  function clearCaches(cm) {\n    cm.display.measureLineCache.length = cm.display.measureLineCachePos = 0;\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = null;\n    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() {\n    return window.pageXOffset || (document.documentElement || document.body).scrollLeft;\n  }\n\n  function pageScrollY() {\n    return window.pageYOffset || (document.documentElement || document.body).scrollTop;\n  } // Context is one of \"line\", \"div\" (display.lineDiv), \"local\"/null (editor), or \"page\"\n\n\n  function intoCoordSystem(cm, lineObj, rect, context) {\n    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) {\n      if (lineObj.widgets[i].above) {\n        var size = widgetHeight(lineObj.widgets[i]);\n        rect.top += size;\n        rect.bottom += size;\n      }\n    }\n    if (context == \"line\") return rect;\n    if (!context) context = \"local\";\n    var yOff = heightAtLine(cm, lineObj);\n    if (context == \"local\") yOff += paddingTop(cm.display);else yOff -= cm.display.viewOffset;\n\n    if (context == \"page\" || context == \"window\") {\n      var lOff = getRect(cm.display.lineSpace);\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n      rect.left += xOff;\n      rect.right += xOff;\n    }\n\n    rect.top += yOff;\n    rect.bottom += yOff;\n    return rect;\n  } // Context may be \"window\", \"page\", \"div\", or \"local\"/null\n  // Result is in \"div\" coords\n\n\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") return coords;\n    var left = coords.left,\n        top = coords.top; // First move into \"page\" coordinate system\n\n    if (context == \"page\") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == \"local\" || !context) {\n      var localBox = getRect(cm.display.sizer);\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = getRect(cm.display.lineSpace);\n    return {\n      left: left - lineSpaceBox.left,\n      top: top - lineSpaceBox.top\n    };\n  }\n\n  function _charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, null, bias), context);\n  }\n\n  function _cursorCoords(cm, pos, context, lineObj, measurement) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!measurement) measurement = measureLine(cm, lineObj);\n\n    function get(ch, right) {\n      var m = measureChar(cm, lineObj, ch, measurement, right ? \"right\" : \"left\");\n      if (right) m.left = m.right;else m.right = m.left;\n      return intoCoordSystem(cm, lineObj, m, context);\n    }\n\n    function getBidi(ch, partPos) {\n      var part = order[partPos],\n          right = part.level % 2;\n\n      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\n        part = order[--partPos];\n        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\n        right = true;\n      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\n        part = order[++partPos];\n        ch = bidiLeft(part) - part.level % 2;\n        right = false;\n      }\n\n      if (right && ch == part.to && ch > part.from) return get(ch - 1);\n      return get(ch, right);\n    }\n\n    var order = getOrder(lineObj),\n        ch = pos.ch;\n    if (!order) return get(ch);\n    var partPos = getBidiPartAt(order, ch);\n    var val = getBidi(ch, partPos);\n    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\n    return val;\n  }\n\n  function PosWithInfo(line, ch, outside, xRel) {\n    var pos = new Pos(line, ch);\n    pos.xRel = xRel;\n    if (outside) pos.outside = true;\n    return pos;\n  } // Coords must be lineSpace-local\n\n\n  function _coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\n\n    var lineNo = _lineAtHeight(doc, y),\n        last = doc.first + doc.size - 1;\n\n    if (lineNo > last) return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\n    if (x < 0) x = 0;\n\n    for (;;) {\n      var lineObj = getLine(doc, lineNo);\n      var found = coordsCharInner(cm, lineObj, lineNo, x, y);\n      var merged = collapsedSpanAtEnd(lineObj);\n      var mergedPos = merged && merged.find();\n      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0)) lineNo = mergedPos.to.line;else return found;\n    }\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    var innerOff = y - heightAtLine(cm, lineObj);\n    var wrongLine = false,\n        adjust = 2 * cm.display.wrapper.clientWidth;\n    var measurement = measureLine(cm, lineObj);\n\n    function getX(ch) {\n      var sp = _cursorCoords(cm, Pos(lineNo, ch), \"line\", lineObj, measurement);\n\n      wrongLine = true;\n      if (innerOff > sp.bottom) return sp.left - adjust;else if (innerOff < sp.top) return sp.left + adjust;else wrongLine = false;\n      return sp.left;\n    }\n\n    var bidi = getOrder(lineObj),\n        dist = lineObj.text.length;\n    var from = lineLeft(lineObj),\n        to = lineRight(lineObj);\n    var fromX = getX(from),\n        fromOutside = wrongLine,\n        toX = getX(to),\n        toOutside = wrongLine;\n    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1); // Do a binary search between these bounds.\n\n    for (;;) {\n      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\n        var ch = x < fromX || x - fromX <= toX - x ? from : to;\n        var xDiff = x - (ch == from ? fromX : toX);\n\n        while (isExtendingChar.test(lineObj.text.charAt(ch))) {\n          ++ch;\n        }\n\n        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside, xDiff < 0 ? -1 : xDiff ? 1 : 0);\n        return pos;\n      }\n\n      var step = Math.ceil(dist / 2),\n          middle = from + step;\n\n      if (bidi) {\n        middle = from;\n\n        for (var i = 0; i < step; ++i) {\n          middle = moveVisually(lineObj, middle, 1);\n        }\n      }\n\n      var middleX = getX(middle);\n\n      if (middleX > x) {\n        to = middle;\n        toX = middleX;\n        if (toOutside = wrongLine) toX += 1000;\n        dist = step;\n      } else {\n        from = middle;\n        fromX = middleX;\n        fromOutside = wrongLine;\n        dist -= step;\n      }\n    }\n  }\n\n  var measureText;\n\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) return display.cachedTextHeight;\n\n    if (measureText == null) {\n      measureText = elt(\"pre\"); // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) display.cachedTextHeight = height;\n    removeChildren(display.measure);\n    return height || 1;\n  }\n\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) return display.cachedCharWidth;\n    var anchor = elt(\"span\", \"x\");\n    var pre = elt(\"pre\", [anchor]);\n    removeChildrenAndAdd(display.measure, pre);\n    var width = anchor.offsetWidth;\n    if (width > 2) display.cachedCharWidth = width;\n    return width || 10;\n  } // OPERATIONS\n  // Operations are used to wrap changes in such a way that each\n  // change won't have to update the cursor and display (which would\n  // be awkward, slow, and error-prone), but instead updates are\n  // batched and then all combined and executed at once.\n\n\n  var nextOpId = 0;\n\n  function startOperation(cm) {\n    cm.curOp = {\n      // An array of ranges of lines that have to be updated. See\n      // updateDisplay.\n      changes: [],\n      updateInput: null,\n      userSelChange: null,\n      textChanged: null,\n      selectionChanged: false,\n      cursorActivity: false,\n      updateMaxLine: false,\n      updateScrollPos: false,\n      id: ++nextOpId\n    };\n    if (!delayedCallbackDepth++) delayedCallbacks = [];\n  }\n\n  function endOperation(cm) {\n    var op = cm.curOp,\n        doc = cm.doc,\n        display = cm.display;\n    cm.curOp = null;\n    if (op.updateMaxLine) computeMaxLength(cm);\n\n    if (display.maxLineChanged && !cm.options.lineWrapping && display.maxLine) {\n      var width = measureLineWidth(cm, display.maxLine);\n      display.sizer.style.minWidth = Math.max(0, width + 3 + scrollerCutOff) + \"px\";\n      display.maxLineChanged = false;\n      var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + display.sizer.offsetWidth - display.scroller.clientWidth);\n      if (maxScrollLeft < doc.scrollLeft && !op.updateScrollPos) setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);\n    }\n\n    var newScrollPos, updated;\n\n    if (op.updateScrollPos) {\n      newScrollPos = op.updateScrollPos;\n    } else if (op.selectionChanged && display.scroller.clientHeight) {\n      // don't rescroll if not visible\n      var coords = _cursorCoords(cm, doc.sel.head);\n\n      newScrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);\n    }\n\n    if (op.changes.length || newScrollPos && newScrollPos.scrollTop != null) {\n      updated = updateDisplay(cm, op.changes, newScrollPos && newScrollPos.scrollTop);\n      if (cm.display.scroller.offsetHeight) cm.doc.scrollTop = cm.display.scroller.scrollTop;\n    }\n\n    if (!updated && op.selectionChanged) updateSelection(cm);\n\n    if (op.updateScrollPos) {\n      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = newScrollPos.scrollTop;\n      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = newScrollPos.scrollLeft;\n      alignHorizontally(cm);\n      if (op.scrollToPos) scrollPosIntoView(cm, _clipPos(cm.doc, op.scrollToPos), op.scrollToPosMargin);\n    } else if (newScrollPos) {\n      scrollCursorIntoView(cm);\n    }\n\n    if (op.selectionChanged) restartBlink(cm);\n    if (cm.state.focused && op.updateInput) resetInput(cm, op.userSelChange);\n    var hidden = op.maybeHiddenMarkers,\n        unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) for (var i = 0; i < hidden.length; ++i) {\n      if (!hidden[i].lines.length) signal(hidden[i], \"hide\");\n    }\n    if (unhidden) for (var i = 0; i < unhidden.length; ++i) {\n      if (unhidden[i].lines.length) signal(unhidden[i], \"unhide\");\n    }\n    var delayed;\n\n    if (! --delayedCallbackDepth) {\n      delayed = delayedCallbacks;\n      delayedCallbacks = null;\n    }\n\n    if (op.textChanged) signal(cm, \"change\", cm, op.textChanged);\n    if (op.cursorActivity) signal(cm, \"cursorActivity\", cm);\n    if (delayed) for (var i = 0; i < delayed.length; ++i) {\n      delayed[i]();\n    }\n  } // Wraps a function in an operation. Returns the wrapped function.\n\n\n  function operation(cm1, f) {\n    return function () {\n      var cm = cm1 || this,\n          withOp = !cm.curOp;\n      if (withOp) startOperation(cm);\n\n      try {\n        var result = f.apply(cm, arguments);\n      } finally {\n        if (withOp) endOperation(cm);\n      }\n\n      return result;\n    };\n  }\n\n  function docOperation(f) {\n    return function () {\n      var withOp = this.cm && !this.cm.curOp,\n          result;\n      if (withOp) startOperation(this.cm);\n\n      try {\n        result = f.apply(this, arguments);\n      } finally {\n        if (withOp) endOperation(this.cm);\n      }\n\n      return result;\n    };\n  }\n\n  function runInOp(cm, f) {\n    var withOp = !cm.curOp,\n        result;\n    if (withOp) startOperation(cm);\n\n    try {\n      result = f();\n    } finally {\n      if (withOp) endOperation(cm);\n    }\n\n    return result;\n  }\n\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) from = cm.doc.first;\n    if (to == null) to = cm.doc.first + cm.doc.size;\n    cm.curOp.changes.push({\n      from: from,\n      to: to,\n      diff: lendiff\n    });\n  } // INPUT HANDLING\n\n\n  function slowPoll(cm) {\n    if (cm.display.pollingFast) return;\n    cm.display.poll.set(cm.options.pollInterval, function () {\n      readInput(cm);\n      if (cm.state.focused) slowPoll(cm);\n    });\n  }\n\n  function fastPoll(cm) {\n    var missed = false;\n    cm.display.pollingFast = true;\n\n    function p() {\n      var changed = readInput(cm);\n\n      if (!changed && !missed) {\n        missed = true;\n        cm.display.poll.set(60, p);\n      } else {\n        cm.display.pollingFast = false;\n        slowPoll(cm);\n      }\n    }\n\n    cm.display.poll.set(20, p);\n  } // prevInput is a hack to work with IME. If we reset the textarea\n  // on every change, that breaks IME. So we look for changes\n  // compared to the previous content instead. (Modern browsers have\n  // events that indicate IME taking place, but these are not widely\n  // supported or compatible enough yet to rely on.)\n\n\n  function readInput(cm) {\n    var input = cm.display.input,\n        prevInput = cm.display.prevInput,\n        doc = cm.doc,\n        sel = doc.sel;\n    if (!cm.state.focused || hasSelection(input) || isReadOnly(cm) || cm.state.disableInput) return false;\n    var text = input.value;\n    if (text == prevInput && posEq(sel.from, sel.to)) return false;\n\n    if (ie && !ie_lt9 && cm.display.inputHasSelection === text) {\n      resetInput(cm, true);\n      return false;\n    }\n\n    var withOp = !cm.curOp;\n    if (withOp) startOperation(cm);\n    sel.shift = false;\n    var same = 0,\n        l = Math.min(prevInput.length, text.length);\n\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {\n      ++same;\n    }\n\n    var from = sel.from,\n        to = sel.to;\n    if (same < prevInput.length) from = Pos(from.line, from.ch - (prevInput.length - same));else if (cm.state.overwrite && posEq(from, to) && !cm.state.pasteIncoming) to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + (text.length - same)));\n    var updateInput = cm.curOp.updateInput;\n    var changeEvent = {\n      from: from,\n      to: to,\n      text: splitLines(text.slice(same)),\n      origin: cm.state.pasteIncoming ? \"paste\" : \"+input\"\n    };\n    makeChange(cm.doc, changeEvent, \"end\");\n    cm.curOp.updateInput = updateInput;\n    signalLater(cm, \"inputRead\", cm, changeEvent);\n    if (text.length > 1000 || text.indexOf(\"\\n\") > -1) input.value = cm.display.prevInput = \"\";else cm.display.prevInput = text;\n    if (withOp) endOperation(cm);\n    cm.state.pasteIncoming = false;\n    return true;\n  }\n\n  function resetInput(cm, user) {\n    var minimal,\n        selected,\n        doc = cm.doc;\n\n    if (!posEq(doc.sel.from, doc.sel.to)) {\n      cm.display.prevInput = \"\";\n      minimal = hasCopyEvent && (doc.sel.to.line - doc.sel.from.line > 100 || (selected = cm.getSelection()).length > 1000);\n      var content = minimal ? \"-\" : selected || cm.getSelection();\n      cm.display.input.value = content;\n      if (cm.state.focused) selectInput(cm.display.input);\n      if (ie && !ie_lt9) cm.display.inputHasSelection = content;\n    } else if (user) {\n      cm.display.prevInput = cm.display.input.value = \"\";\n      if (ie && !ie_lt9) cm.display.inputHasSelection = null;\n    }\n\n    cm.display.inaccurateSelection = minimal;\n  }\n\n  function focusInput(cm) {\n    if (cm.options.readOnly != \"nocursor\" && (!mobile || document.activeElement != cm.display.input)) cm.display.input.focus();\n  }\n\n  function isReadOnly(cm) {\n    return cm.options.readOnly || cm.doc.cantEdit;\n  } // EVENT HANDLERS\n\n\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n\n    _on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n\n    if (ie) _on(d.scroller, \"dblclick\", operation(cm, function (e) {\n      if (signalDOMEvent(cm, e)) return;\n      var pos = posFromMouse(cm, e);\n      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\n      e_preventDefault(e);\n      var word = findWordAt(getLine(cm.doc, pos.line).text, pos);\n      extendSelection(cm.doc, word.from, word.to);\n    }));else _on(d.scroller, \"dblclick\", function (e) {\n      signalDOMEvent(cm, e) || e_preventDefault(e);\n    });\n\n    _on(d.lineSpace, \"selectstart\", function (e) {\n      if (!eventInWidget(d, e)) e_preventDefault(e);\n    }); // Gecko browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for Gecko.\n\n\n    if (!captureMiddleClick) _on(d.scroller, \"contextmenu\", function (e) {\n      onContextMenu(cm, e);\n    });\n\n    _on(d.scroller, \"scroll\", function () {\n      if (d.scroller.clientHeight) {\n        setScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    });\n\n    _on(d.scrollbarV, \"scroll\", function () {\n      if (d.scroller.clientHeight) setScrollTop(cm, d.scrollbarV.scrollTop);\n    });\n\n    _on(d.scrollbarH, \"scroll\", function () {\n      if (d.scroller.clientHeight) setScrollLeft(cm, d.scrollbarH.scrollLeft);\n    });\n\n    _on(d.scroller, \"mousewheel\", function (e) {\n      onScrollWheel(cm, e);\n    });\n\n    _on(d.scroller, \"DOMMouseScroll\", function (e) {\n      onScrollWheel(cm, e);\n    });\n\n    function reFocus() {\n      if (cm.state.focused) setTimeout(bind(focusInput, cm), 0);\n    }\n\n    _on(d.scrollbarH, \"mousedown\", reFocus);\n\n    _on(d.scrollbarV, \"mousedown\", reFocus); // Prevent wrapper from ever scrolling\n\n\n    _on(d.wrapper, \"scroll\", function () {\n      d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;\n    });\n\n    var resizeTimer;\n\n    function onResize() {\n      if (resizeTimer == null) resizeTimer = setTimeout(function () {\n        resizeTimer = null; // Might be a text scaling operation, clear size caches.\n\n        d.cachedCharWidth = d.cachedTextHeight = knownScrollbarWidth = null;\n        clearCaches(cm);\n        runInOp(cm, bind(regChange, cm));\n      }, 100);\n    }\n\n    _on(window, \"resize\", onResize); // Above handler holds on to the editor and its data structures.\n    // Here we poll to unregister it when the editor is no longer in\n    // the document, so that it can be garbage-collected.\n\n\n    function unregister() {\n      for (var p = d.wrapper.parentNode; p && p != document.body; p = p.parentNode) {}\n\n      if (p) setTimeout(unregister, 5000);else _off(window, \"resize\", onResize);\n    }\n\n    setTimeout(unregister, 5000);\n\n    _on(d.input, \"keyup\", operation(cm, function (e) {\n      if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n      if (e.keyCode == 16) cm.doc.sel.shift = false;\n    }));\n\n    _on(d.input, \"input\", bind(fastPoll, cm));\n\n    _on(d.input, \"keydown\", operation(cm, onKeyDown));\n\n    _on(d.input, \"keypress\", operation(cm, onKeyPress));\n\n    _on(d.input, \"focus\", bind(onFocus, cm));\n\n    _on(d.input, \"blur\", bind(onBlur, cm));\n\n    function drag_(e) {\n      if (signalDOMEvent(cm, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))) return;\n      e_stop(e);\n    }\n\n    if (cm.options.dragDrop) {\n      _on(d.scroller, \"dragstart\", function (e) {\n        onDragStart(cm, e);\n      });\n\n      _on(d.scroller, \"dragenter\", drag_);\n\n      _on(d.scroller, \"dragover\", drag_);\n\n      _on(d.scroller, \"drop\", operation(cm, onDrop));\n    }\n\n    _on(d.scroller, \"paste\", function (e) {\n      if (eventInWidget(d, e)) return;\n      focusInput(cm);\n      fastPoll(cm);\n    });\n\n    _on(d.input, \"paste\", function () {\n      cm.state.pasteIncoming = true;\n      fastPoll(cm);\n    });\n\n    function prepareCopy() {\n      if (d.inaccurateSelection) {\n        d.prevInput = \"\";\n        d.inaccurateSelection = false;\n        d.input.value = cm.getSelection();\n        selectInput(d.input);\n      }\n    }\n\n    _on(d.input, \"cut\", prepareCopy);\n\n    _on(d.input, \"copy\", prepareCopy); // Needed to handle Tab key in KHTML\n\n\n    if (khtml) _on(d.sizer, \"mouseup\", function () {\n      if (document.activeElement == d.input) d.input.blur();\n      focusInput(cm);\n    });\n  }\n\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover) return true;\n    }\n  }\n\n  function posFromMouse(cm, e, liberal) {\n    var display = cm.display;\n\n    if (!liberal) {\n      var target = e_target(e);\n      if (target == display.scrollbarH || target == display.scrollbarH.firstChild || target == display.scrollbarV || target == display.scrollbarV.firstChild || target == display.scrollbarFiller || target == display.gutterFiller) return null;\n    }\n\n    var x,\n        y,\n        space = getRect(display.lineSpace); // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n\n    try {\n      x = e.clientX;\n      y = e.clientY;\n    } catch (e) {\n      return null;\n    }\n\n    return _coordsChar(cm, x - space.left, y - space.top);\n  }\n\n  var lastClick, lastDoubleClick;\n\n  function onMouseDown(e) {\n    if (signalDOMEvent(this, e)) return;\n    var cm = this,\n        display = cm.display,\n        doc = cm.doc,\n        sel = doc.sel;\n    sel.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        display.scroller.draggable = false;\n        setTimeout(function () {\n          display.scroller.draggable = true;\n        }, 100);\n      }\n\n      return;\n    }\n\n    if (clickInGutter(cm, e)) return;\n    var start = posFromMouse(cm, e);\n\n    switch (e_button(e)) {\n      case 3:\n        if (captureMiddleClick) onContextMenu.call(cm, cm, e);\n        return;\n\n      case 2:\n        if (start) extendSelection(cm.doc, start);\n        setTimeout(bind(focusInput, cm), 20);\n        e_preventDefault(e);\n        return;\n    } // For button 1, if it was clicked inside the editor\n    // (posFromMouse returning non-null), we have to adjust the\n    // selection.\n\n\n    if (!start) {\n      if (e_target(e) == display.scroller) e_preventDefault(e);\n      return;\n    }\n\n    if (!cm.state.focused) onFocus(cm);\n    var now = +new Date(),\n        type = \"single\";\n\n    if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {\n      type = \"triple\";\n      e_preventDefault(e);\n      setTimeout(bind(focusInput, cm), 20);\n      selectLine(cm, start.line);\n    } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {\n      type = \"double\";\n      lastDoubleClick = {\n        time: now,\n        pos: start\n      };\n      e_preventDefault(e);\n      var word = findWordAt(getLine(doc, start.line).text, start);\n      extendSelection(cm.doc, word.from, word.to);\n    } else {\n      lastClick = {\n        time: now,\n        pos: start\n      };\n    }\n\n    var last = start;\n\n    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && !posEq(sel.from, sel.to) && !posLess(start, sel.from) && !posLess(sel.to, start) && type == \"single\") {\n      var dragEnd = operation(cm, function (e2) {\n        if (webkit) display.scroller.draggable = false;\n        cm.state.draggingText = false;\n\n        _off(document, \"mouseup\", dragEnd);\n\n        _off(display.scroller, \"drop\", dragEnd);\n\n        if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n          e_preventDefault(e2);\n          extendSelection(cm.doc, start);\n          focusInput(cm);\n        }\n      }); // Let the drag handler handle this.\n\n      if (webkit) display.scroller.draggable = true;\n      cm.state.draggingText = dragEnd; // IE's approach to draggable\n\n      if (display.scroller.dragDrop) display.scroller.dragDrop();\n\n      _on(document, \"mouseup\", dragEnd);\n\n      _on(display.scroller, \"drop\", dragEnd);\n\n      return;\n    }\n\n    e_preventDefault(e);\n    if (type == \"single\") extendSelection(cm.doc, _clipPos(doc, start));\n    var startstart = sel.from,\n        startend = sel.to,\n        lastPos = start;\n\n    function doSelect(cur) {\n      if (posEq(lastPos, cur)) return;\n      lastPos = cur;\n\n      if (type == \"single\") {\n        extendSelection(cm.doc, _clipPos(doc, start), cur);\n        return;\n      }\n\n      startstart = _clipPos(doc, startstart);\n      startend = _clipPos(doc, startend);\n\n      if (type == \"double\") {\n        var word = findWordAt(getLine(doc, cur.line).text, cur);\n        if (posLess(cur, startstart)) extendSelection(cm.doc, word.from, startend);else extendSelection(cm.doc, startstart, word.to);\n      } else if (type == \"triple\") {\n        if (posLess(cur, startstart)) extendSelection(cm.doc, startend, _clipPos(doc, Pos(cur.line, 0)));else extendSelection(cm.doc, startstart, _clipPos(doc, Pos(cur.line + 1, 0)));\n      }\n    }\n\n    var editorSize = getRect(display.wrapper); // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true);\n      if (!cur) return;\n\n      if (!posEq(cur, last)) {\n        if (!cm.state.focused) onFocus(cm);\n        last = cur;\n        doSelect(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from) setTimeout(operation(cm, function () {\n          if (counter == curCount) extend(e);\n        }), 150);\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) setTimeout(operation(cm, function () {\n          if (counter != curCount) return;\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50);\n      }\n    }\n\n    function done(e) {\n      counter = Infinity;\n      e_preventDefault(e);\n      focusInput(cm);\n\n      _off(document, \"mousemove\", move);\n\n      _off(document, \"mouseup\", up);\n    }\n\n    var move = operation(cm, function (e) {\n      if (!ie && !e_button(e)) done(e);else extend(e);\n    });\n    var up = operation(cm, done);\n\n    _on(document, \"mousemove\", move);\n\n    _on(document, \"mouseup\", up);\n  }\n\n  function clickInGutter(cm, e) {\n    var display = cm.display;\n\n    try {\n      var mX = e.clientX,\n          mY = e.clientY;\n    } catch (e) {\n      return false;\n    }\n\n    if (mX >= Math.floor(getRect(display.gutters).right)) return false;\n    e_preventDefault(e);\n    if (!hasHandler(cm, \"gutterClick\")) return true;\n    var lineBox = getRect(display.lineDiv);\n    if (mY > lineBox.bottom) return true;\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.options.gutters.length; ++i) {\n      var g = display.gutters.childNodes[i];\n\n      if (g && getRect(g).right >= mX) {\n        var line = _lineAtHeight(cm.doc, mY);\n\n        var gutter = cm.options.gutters[i];\n        signalLater(cm, \"gutterClick\", cm, line, gutter, e);\n        break;\n      }\n    }\n\n    return true;\n  } // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n\n\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))) return;\n    e_preventDefault(e);\n    if (ie) lastDrop = +new Date();\n    var pos = posFromMouse(cm, e, true),\n        files = e.dataTransfer.files;\n    if (!pos || isReadOnly(cm)) return;\n\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length,\n          text = Array(n),\n          read = 0;\n\n      var loadFile = function loadFile(file, i) {\n        var reader = new FileReader();\n\n        reader.onload = function () {\n          text[i] = reader.result;\n\n          if (++read == n) {\n            pos = _clipPos(cm.doc, pos);\n            makeChange(cm.doc, {\n              from: pos,\n              to: pos,\n              text: splitLines(text.join(\"\\n\")),\n              origin: \"paste\"\n            }, \"around\");\n          }\n        };\n\n        reader.readAsText(file);\n      };\n\n      for (var i = 0; i < n; ++i) {\n        loadFile(files[i], i);\n      }\n    } else {\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && !(posLess(pos, cm.doc.sel.from) || posLess(cm.doc.sel.to, pos))) {\n        cm.state.draggingText(e); // Ensure the editor is re-focused\n\n        setTimeout(bind(focusInput, cm), 20);\n        return;\n      }\n\n      try {\n        var text = e.dataTransfer.getData(\"Text\");\n\n        if (text) {\n          var curFrom = cm.doc.sel.from,\n              curTo = cm.doc.sel.to;\n          setSelection(cm.doc, pos, pos);\n          if (cm.state.draggingText) _replaceRange(cm.doc, \"\", curFrom, curTo, \"paste\");\n          cm.replaceSelection(text, null, \"paste\");\n          focusInput(cm);\n          onFocus(cm);\n        }\n      } catch (e) {}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {\n      e_stop(e);\n      return;\n    }\n\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\n    var txt = cm.getSelection();\n    e.dataTransfer.setData(\"Text\", txt); // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n\n      if (opera) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img); // Force a relayout, or Opera won't use our image for some obscure reason\n\n        img._top = img.offsetTop;\n      }\n\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (opera) img.parentNode.removeChild(img);\n    }\n  }\n\n  function setScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\n    cm.doc.scrollTop = val;\n    if (!gecko) updateDisplay(cm, [], val);\n    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\n    if (cm.display.scrollbarV.scrollTop != val) cm.display.scrollbarV.scrollTop = val;\n    if (gecko) updateDisplay(cm, []);\n    startWorker(cm, 100);\n  }\n\n  function setScrollLeft(cm, val, isScroller) {\n    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\n    if (cm.display.scrollbarH.scrollLeft != val) cm.display.scrollbarH.scrollLeft = val;\n  } // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n\n  var wheelSamples = 0,\n      wheelPixelsPerUnit = null; // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n\n  if (ie) wheelPixelsPerUnit = -.53;else if (gecko) wheelPixelsPerUnit = 15;else if (chrome) wheelPixelsPerUnit = -.7;else if (safari) wheelPixelsPerUnit = -1 / 3;\n\n  function onScrollWheel(cm, e) {\n    var dx = e.wheelDeltaX,\n        dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;else if (dy == null) dy = e.wheelDelta;\n    var display = cm.display,\n        scroll = display.scroller; // Quit if there's nothing to scroll here\n\n    if (!(dx && scroll.scrollWidth > scroll.clientWidth || dy && scroll.scrollHeight > scroll.clientHeight)) return; // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n\n    if (dy && mac && webkit) {\n      for (var cur = e.target; cur != scroll; cur = cur.parentNode) {\n        if (cur.lineObj) {\n          cm.display.currentWheelTarget = cur;\n          break;\n        }\n      }\n    } // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n\n\n    if (dx && !gecko && !opera && wheelPixelsPerUnit != null) {\n      if (dy) setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\n      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\n      e_preventDefault(e);\n      display.wheelStartX = null; // Abort measurement, if in progress\n\n      return;\n    }\n\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop,\n          bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) top = Math.max(0, top + pixels - 50);else bot = Math.min(cm.doc.height, bot + pixels + 50);\n      updateDisplay(cm, [], {\n        top: top,\n        bottom: bot\n      });\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft;\n        display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx;\n        display.wheelDY = dy;\n        setTimeout(function () {\n          if (display.wheelStartX == null) return;\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) return;\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx;\n        display.wheelDY += dy;\n      }\n    }\n  }\n\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n      if (!bound) return false;\n    } // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n\n\n    if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;\n    var doc = cm.doc,\n        prevShift = doc.sel.shift,\n        done = false;\n\n    try {\n      if (isReadOnly(cm)) cm.state.suppressEdits = true;\n      if (dropShift) doc.sel.shift = false;\n      done = bound(cm) != Pass;\n    } finally {\n      doc.sel.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n\n    return done;\n  }\n\n  function allKeyMaps(cm) {\n    var maps = cm.state.keyMaps.slice(0);\n    if (cm.options.extraKeys) maps.push(cm.options.extraKeys);\n    maps.push(cm.options.keyMap);\n    return maps;\n  }\n\n  var maybeTransition;\n\n  function handleKeyBinding(cm, e) {\n    // Handle auto keymap transitions\n    var startMap = getKeyMap(cm.options.keyMap),\n        next = startMap.auto;\n    clearTimeout(maybeTransition);\n    if (next && !isModifierKey(e)) maybeTransition = setTimeout(function () {\n      if (getKeyMap(cm.options.keyMap) == startMap) {\n        cm.options.keyMap = next.call ? next.call(null, cm) : next;\n        keyMapChanged(cm);\n      }\n    }, 50);\n    var name = keyName(e, true),\n        handled = false;\n    if (!name) return false;\n    var keymaps = allKeyMaps(cm);\n\n    if (e.shiftKey) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      handled = lookupKey(\"Shift-\" + name, keymaps, function (b) {\n        return doHandleBinding(cm, b, true);\n      }) || lookupKey(name, keymaps, function (b) {\n        if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion) return doHandleBinding(cm, b);\n      });\n    } else {\n      handled = lookupKey(name, keymaps, function (b) {\n        return doHandleBinding(cm, b);\n      });\n    }\n\n    if (handled) {\n      e_preventDefault(e);\n      restartBlink(cm);\n\n      if (ie_lt9) {\n        e.oldKeyCode = e.keyCode;\n        e.keyCode = 0;\n      }\n\n      signalLater(cm, \"keyHandled\", cm, name, e);\n    }\n\n    return handled;\n  }\n\n  function handleCharBinding(cm, e, ch) {\n    var handled = lookupKey(\"'\" + ch + \"'\", allKeyMaps(cm), function (b) {\n      return doHandleBinding(cm, b, true);\n    });\n\n    if (handled) {\n      e_preventDefault(e);\n      restartBlink(cm);\n      signalLater(cm, \"keyHandled\", cm, \"'\" + ch + \"'\", e);\n    }\n\n    return handled;\n  }\n\n  var lastStoppedKey = null;\n\n  function onKeyDown(e) {\n    var cm = this;\n    if (!cm.state.focused) onFocus(cm);\n\n    if (ie && e.keyCode == 27) {\n      e.returnValue = false;\n    }\n\n    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n    var code = e.keyCode; // IE does strange things with escape.\n\n    cm.doc.sel.shift = code == 16 || e.shiftKey; // First give onKeyEvent option a chance to handle this.\n\n    var handled = handleKeyBinding(cm, e);\n\n    if (opera) {\n      lastStoppedKey = handled ? code : null; // Opera has no cut event... we try to at least catch the key combo\n\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) cm.replaceSelection(\"\");\n    }\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n    var keyCode = e.keyCode,\n        charCode = e.charCode;\n\n    if (opera && keyCode == lastStoppedKey) {\n      lastStoppedKey = null;\n      e_preventDefault(e);\n      return;\n    }\n\n    if ((opera && (!e.which || e.which < 10) || khtml) && handleKeyBinding(cm, e)) return;\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    if (this.options.electricChars && this.doc.mode.electricChars && this.options.smartIndent && !isReadOnly(this) && this.doc.mode.electricChars.indexOf(ch) > -1) setTimeout(operation(cm, function () {\n      indentLine(cm, cm.doc.sel.to.line, \"smart\");\n    }), 75);\n    if (handleCharBinding(cm, e, ch)) return;\n    if (ie && !ie_lt9) cm.display.inputHasSelection = null;\n    fastPoll(cm);\n  }\n\n  function onFocus(cm) {\n    if (cm.options.readOnly == \"nocursor\") return;\n\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm);\n      cm.state.focused = true;\n      if (cm.display.wrapper.className.search(/\\bCodeMirror-focused\\b/) == -1) cm.display.wrapper.className += \" CodeMirror-focused\";\n      resetInput(cm, true);\n    }\n\n    slowPoll(cm);\n    restartBlink(cm);\n  }\n\n  function onBlur(cm) {\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm);\n      cm.state.focused = false;\n      cm.display.wrapper.className = cm.display.wrapper.className.replace(\" CodeMirror-focused\", \"\");\n    }\n\n    clearInterval(cm.display.blinker);\n    setTimeout(function () {\n      if (!cm.state.focused) cm.doc.sel.shift = false;\n    }, 150);\n  }\n\n  var detectingSelectAll;\n\n  function onContextMenu(cm, e) {\n    var display = cm.display,\n        sel = cm.doc.sel;\n    if (eventInWidget(display, e)) return;\n    var pos = posFromMouse(cm, e),\n        scrollPos = display.scroller.scrollTop;\n    if (!pos || opera) return; // Opera is difficult.\n\n    if (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to)) operation(cm, setSelection)(cm.doc, pos, pos);\n    var oldCSS = display.input.style.cssText;\n    display.inputDiv.style.position = \"absolute\";\n    display.input.style.cssText = \"position: fixed; width: 30px; height: 30px; top: \" + (e.clientY - 5) + \"px; left: \" + (e.clientX - 5) + \"px; z-index: 1000; background: white; outline: none;\" + \"border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);\";\n    focusInput(cm);\n    resetInput(cm, true); // Adds \"Select all\" to context menu in FF\n\n    if (posEq(sel.from, sel.to)) display.input.value = display.prevInput = \" \";\n\n    function prepareSelectAllHack() {\n      if (display.input.selectionStart != null) {\n        var extval = display.input.value = \" \" + (posEq(sel.from, sel.to) ? \"\" : display.input.value);\n        display.prevInput = \" \";\n        display.input.selectionStart = 1;\n        display.input.selectionEnd = extval.length;\n      }\n    }\n\n    function rehide() {\n      display.inputDiv.style.position = \"relative\";\n      display.input.style.cssText = oldCSS;\n      if (ie_lt9) display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;\n      slowPoll(cm); // Try to detect the user choosing select-all\n\n      if (display.input.selectionStart != null) {\n        if (!ie || ie_lt9) prepareSelectAllHack();\n        clearTimeout(detectingSelectAll);\n\n        var i = 0,\n            poll = function poll() {\n          if (display.prevInput == \" \" && display.input.selectionStart == 0) operation(cm, commands.selectAll)(cm);else if (i++ < 10) detectingSelectAll = setTimeout(poll, 500);else resetInput(cm);\n        };\n\n        detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (ie && !ie_lt9) prepareSelectAllHack();\n\n    if (captureMiddleClick) {\n      e_stop(e);\n\n      var mouseup = function mouseup() {\n        _off(window, \"mouseup\", mouseup);\n\n        setTimeout(rehide, 20);\n      };\n\n      _on(window, \"mouseup\", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  } // UPDATING\n\n\n  var changeEnd = CodeMirror.changeEnd = function (change) {\n    if (!change.text) return change.to;\n    return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n  }; // Make sure a position will be valid after the given change.\n\n\n  function clipPostChange(doc, change, pos) {\n    if (!posLess(change.from, pos)) return _clipPos(doc, pos);\n    var diff = change.text.length - 1 - (change.to.line - change.from.line);\n\n    if (pos.line > change.to.line + diff) {\n      var preLine = pos.line - diff,\n          lastLine = doc.first + doc.size - 1;\n      if (preLine > lastLine) return Pos(lastLine, getLine(doc, lastLine).text.length);\n      return clipToLen(pos, getLine(doc, preLine).text.length);\n    }\n\n    if (pos.line == change.to.line + diff) return clipToLen(pos, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0) + getLine(doc, change.to.line).text.length - change.to.ch);\n    var inside = pos.line - change.from.line;\n    return clipToLen(pos, change.text[inside].length + (inside ? 0 : change.from.ch));\n  } // Hint can be null|\"end\"|\"start\"|\"around\"|{anchor,head}\n\n\n  function computeSelAfterChange(doc, change, hint) {\n    if (hint && _typeof(hint) == \"object\") // Assumed to be {anchor, head} object\n      return {\n        anchor: clipPostChange(doc, change, hint.anchor),\n        head: clipPostChange(doc, change, hint.head)\n      };\n    if (hint == \"start\") return {\n      anchor: change.from,\n      head: change.from\n    };\n    var end = changeEnd(change);\n    if (hint == \"around\") return {\n      anchor: change.from,\n      head: end\n    };\n    if (hint == \"end\") return {\n      anchor: end,\n      head: end\n    }; // hint is null, leave the selection alone as much as possible\n\n    var adjustPos = function adjustPos(pos) {\n      if (posLess(pos, change.from)) return pos;\n      if (!posLess(change.to, pos)) return end;\n      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1,\n          ch = pos.ch;\n      if (pos.line == change.to.line) ch += end.ch - change.to.ch;\n      return Pos(line, ch);\n    };\n\n    return {\n      anchor: adjustPos(doc.sel.anchor),\n      head: adjustPos(doc.sel.head)\n    };\n  }\n\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function cancel() {\n        this.canceled = true;\n      }\n    };\n    if (update) obj.update = function (from, to, text, origin) {\n      if (from) this.from = _clipPos(doc, from);\n      if (to) this.to = _clipPos(doc, to);\n      if (text) this.text = text;\n      if (origin !== undefined) this.origin = origin;\n    };\n    signal(doc, \"beforeChange\", doc, obj);\n    if (doc.cm) signal(doc.cm, \"beforeChange\", doc.cm, obj);\n    if (obj.canceled) return null;\n    return {\n      from: obj.from,\n      to: obj.to,\n      text: obj.text,\n      origin: obj.origin\n    };\n  } // Replace the range from from to to by the strings in replacement.\n  // change is a {from, to, text [, origin]} object\n\n\n  function makeChange(doc, change, selUpdate, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, selUpdate, ignoreReadOnly);\n      if (doc.cm.state.suppressEdits) return;\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n      if (!change) return;\n    } // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n\n\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n\n    if (split) {\n      for (var i = split.length - 1; i >= 1; --i) {\n        makeChangeNoReadonly(doc, {\n          from: split[i].from,\n          to: split[i].to,\n          text: [\"\"]\n        });\n      }\n\n      if (split.length) makeChangeNoReadonly(doc, {\n        from: split[0].from,\n        to: split[0].to,\n        text: change.text\n      }, selUpdate);\n    } else {\n      makeChangeNoReadonly(doc, change, selUpdate);\n    }\n  }\n\n  function makeChangeNoReadonly(doc, change, selUpdate) {\n    var selAfter = computeSelAfterChange(doc, change, selUpdate);\n    addToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  function makeChangeFromHistory(doc, type) {\n    if (doc.cm && doc.cm.state.suppressEdits) return;\n    var hist = doc.history;\n    var event = (type == \"undo\" ? hist.done : hist.undone).pop();\n    if (!event) return;\n    var anti = {\n      changes: [],\n      anchorBefore: event.anchorAfter,\n      headBefore: event.headAfter,\n      anchorAfter: event.anchorBefore,\n      headAfter: event.headBefore,\n      generation: hist.generation\n    };\n    (type == \"undo\" ? hist.undone : hist.done).push(anti);\n    hist.generation = event.generation || ++hist.maxGeneration;\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n    for (var i = event.changes.length - 1; i >= 0; --i) {\n      var change = event.changes[i];\n      change.origin = type;\n\n      if (filter && !filterChange(doc, change, false)) {\n        (type == \"undo\" ? hist.done : hist.undone).length = 0;\n        return;\n      }\n\n      anti.changes.push(historyChangeFromChange(doc, change));\n      var after = i ? computeSelAfterChange(doc, change, null) : {\n        anchor: event.anchorBefore,\n        head: event.headBefore\n      };\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      var rebased = [];\n      linkedDocs(doc, function (doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    }\n  }\n\n  function shiftDoc(doc, distance) {\n    function shiftPos(pos) {\n      return Pos(pos.line + distance, pos.ch);\n    }\n\n    doc.first += distance;\n    if (doc.cm) regChange(doc.cm, doc.first, doc.first, distance);\n    doc.sel.head = shiftPos(doc.sel.head);\n    doc.sel.anchor = shiftPos(doc.sel.anchor);\n    doc.sel.from = shiftPos(doc.sel.from);\n    doc.sel.to = shiftPos(doc.sel.to);\n  }\n\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return;\n    }\n\n    if (change.from.line > doc.lastLine()) return; // Clip the change to the size of this doc\n\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {\n        from: Pos(doc.first, 0),\n        to: Pos(change.to.line + shift, change.to.ch),\n        text: [lst(change.text)],\n        origin: change.origin\n      };\n    }\n\n    var last = doc.lastLine();\n\n    if (change.to.line > last) {\n      change = {\n        from: change.from,\n        to: Pos(last, getLine(doc, last).text.length),\n        text: [change.text[0]],\n        origin: change.origin\n      };\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n    if (!selAfter) selAfter = computeSelAfterChange(doc, change, null);\n    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans, selAfter);else updateDoc(doc, change, spans, selAfter);\n  }\n\n  function makeChangeSingleDocInEditor(cm, change, spans, selAfter) {\n    var doc = cm.doc,\n        display = cm.display,\n        from = change.from,\n        to = change.to;\n    var recomputeMaxLength = false,\n        checkWidthStart = from.line;\n\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(doc, getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function (line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true;\n        }\n      });\n    }\n\n    if (!posLess(doc.sel.head, change.from) && !posLess(change.to, doc.sel.head)) cm.curOp.cursorActivity = true;\n    updateDoc(doc, change, spans, selAfter, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n        var len = lineLength(doc, line);\n\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\n    } // Adjust frontier, schedule worker\n\n\n    doc.frontier = Math.min(doc.frontier, from.line);\n    startWorker(cm, 400);\n    var lendiff = change.text.length - (to.line - from.line) - 1; // Remember that these lines changed, for updating the display\n\n    regChange(cm, from.line, to.line + 1, lendiff);\n\n    if (hasHandler(cm, \"change\")) {\n      var changeObj = {\n        from: from,\n        to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n\n      if (cm.curOp.textChanged) {\n        for (var cur = cm.curOp.textChanged; cur.next; cur = cur.next) {}\n\n        cur.next = changeObj;\n      } else cm.curOp.textChanged = changeObj;\n    }\n  }\n\n  function _replaceRange(doc, code, from, to, origin) {\n    if (!to) to = from;\n\n    if (posLess(to, from)) {\n      var tmp = to;\n      to = from;\n      from = tmp;\n    }\n\n    if (typeof code == \"string\") code = splitLines(code);\n    makeChange(doc, {\n      from: from,\n      to: to,\n      text: code,\n      origin: origin\n    }, null);\n  } // POSITION OBJECT\n\n\n  function Pos(line, ch) {\n    if (!(this instanceof Pos)) return new Pos(line, ch);\n    this.line = line;\n    this.ch = ch;\n  }\n\n  CodeMirror.Pos = Pos;\n\n  function posEq(a, b) {\n    return a.line == b.line && a.ch == b.ch;\n  }\n\n  function posLess(a, b) {\n    return a.line < b.line || a.line == b.line && a.ch < b.ch;\n  }\n\n  function copyPos(x) {\n    return Pos(x.line, x.ch);\n  } // SELECTION\n\n\n  function clipLine(doc, n) {\n    return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));\n  }\n\n  function _clipPos(doc, pos) {\n    if (pos.line < doc.first) return Pos(doc.first, 0);\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\n    return clipToLen(pos, getLine(doc, pos.line).text.length);\n  }\n\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) return Pos(pos.line, linelen);else if (ch < 0) return Pos(pos.line, 0);else return pos;\n  }\n\n  function isLine(doc, l) {\n    return l >= doc.first && l < doc.first + doc.size;\n  } // If shift is held, this will move the selection anchor. Otherwise,\n  // it'll set the whole selection.\n\n\n  function extendSelection(doc, pos, other, bias) {\n    if (doc.sel.shift || doc.sel.extend) {\n      var anchor = doc.sel.anchor;\n\n      if (other) {\n        var posBefore = posLess(pos, anchor);\n\n        if (posBefore != posLess(other, anchor)) {\n          anchor = pos;\n          pos = other;\n        } else if (posBefore != posLess(pos, other)) {\n          pos = other;\n        }\n      }\n\n      setSelection(doc, anchor, pos, bias);\n    } else {\n      setSelection(doc, pos, other || pos, bias);\n    }\n\n    if (doc.cm) doc.cm.curOp.userSelChange = true;\n  }\n\n  function filterSelectionChange(doc, anchor, head) {\n    var obj = {\n      anchor: anchor,\n      head: head\n    };\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n    if (doc.cm) signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\n    obj.anchor = _clipPos(doc, obj.anchor);\n    obj.head = _clipPos(doc, obj.head);\n    return obj;\n  } // Update the selection. Last two args are only used by\n  // updateDoc, since they have to be expressed in the line\n  // numbers before the update.\n\n\n  function setSelection(doc, anchor, head, bias, checkAtomic) {\n    if (!checkAtomic && hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\")) {\n      var filtered = filterSelectionChange(doc, anchor, head);\n      head = filtered.head;\n      anchor = filtered.anchor;\n    }\n\n    var sel = doc.sel;\n    sel.goalColumn = null; // Skip over atomic spans.\n\n    if (checkAtomic || !posEq(anchor, sel.anchor)) anchor = skipAtomic(doc, anchor, bias, checkAtomic != \"push\");\n    if (checkAtomic || !posEq(head, sel.head)) head = skipAtomic(doc, head, bias, checkAtomic != \"push\");\n    if (posEq(sel.anchor, anchor) && posEq(sel.head, head)) return;\n    sel.anchor = anchor;\n    sel.head = head;\n    var inv = posLess(head, anchor);\n    sel.from = inv ? head : anchor;\n    sel.to = inv ? anchor : head;\n    if (doc.cm) doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = doc.cm.curOp.cursorActivity = true;\n    signalLater(doc, \"cursorActivity\", doc);\n  }\n\n  function reCheckSelection(cm) {\n    setSelection(cm.doc, cm.doc.sel.from, cm.doc.sel.to, null, \"push\");\n  }\n\n  function skipAtomic(doc, pos, bias, mayClear) {\n    var flipped = false,\n        curPos = pos;\n    var dir = bias || 1;\n    doc.cantEdit = false;\n\n    search: for (;;) {\n      var line = getLine(doc, curPos.line);\n\n      if (line.markedSpans) {\n        for (var i = 0; i < line.markedSpans.length; ++i) {\n          var sp = line.markedSpans[i],\n              m = sp.marker;\n\n          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) && (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {\n            if (mayClear) {\n              signal(m, \"beforeCursorEnter\");\n\n              if (m.explicitlyCleared) {\n                if (!line.markedSpans) break;else {\n                  --i;\n                  continue;\n                }\n              }\n            }\n\n            if (!m.atomic) continue;\n            var newPos = m.find()[dir < 0 ? \"from\" : \"to\"];\n\n            if (posEq(newPos, curPos)) {\n              newPos.ch += dir;\n\n              if (newPos.ch < 0) {\n                if (newPos.line > doc.first) newPos = _clipPos(doc, Pos(newPos.line - 1));else newPos = null;\n              } else if (newPos.ch > line.text.length) {\n                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);else newPos = null;\n              }\n\n              if (!newPos) {\n                if (flipped) {\n                  // Driven in a corner -- no valid cursor position found at all\n                  // -- try again *with* clearing, if we didn't already\n                  if (!mayClear) return skipAtomic(doc, pos, bias, true); // Otherwise, turn off editing until further notice, and return the start of the doc\n\n                  doc.cantEdit = true;\n                  return Pos(doc.first, 0);\n                }\n\n                flipped = true;\n                newPos = pos;\n                dir = -dir;\n              }\n            }\n\n            curPos = newPos;\n            continue search;\n          }\n        }\n      }\n\n      return curPos;\n    }\n  } // SCROLLING\n\n\n  function scrollCursorIntoView(cm) {\n    var coords = scrollPosIntoView(cm, cm.doc.sel.head, cm.options.cursorScrollMargin);\n    if (!cm.state.focused) return;\n    var display = cm.display,\n        box = getRect(display.sizer),\n        doScroll = null;\n    if (coords.top + box.top < 0) doScroll = true;else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n\n    if (doScroll != null && !phantom) {\n      var hidden = display.cursor.style.display == \"none\";\n\n      if (hidden) {\n        display.cursor.style.display = \"\";\n        display.cursor.style.left = coords.left + \"px\";\n        display.cursor.style.top = coords.top - display.viewOffset + \"px\";\n      }\n\n      display.cursor.scrollIntoView(doScroll);\n      if (hidden) display.cursor.style.display = \"none\";\n    }\n  }\n\n  function scrollPosIntoView(cm, pos, margin) {\n    if (margin == null) margin = 0;\n\n    for (;;) {\n      var changed = false,\n          coords = _cursorCoords(cm, pos);\n\n      var scrollPos = calculateScrollPos(cm, coords.left, coords.top - margin, coords.left, coords.bottom + margin);\n      var startTop = cm.doc.scrollTop,\n          startLeft = cm.doc.scrollLeft;\n\n      if (scrollPos.scrollTop != null) {\n        setScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\n      }\n\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\n      }\n\n      if (!changed) return coords;\n    }\n  }\n\n  function scrollIntoView(cm, x1, y1, x2, y2) {\n    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\n    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\n    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\n  }\n\n  function calculateScrollPos(cm, x1, y1, x2, y2) {\n    var display = cm.display,\n        snapMargin = textHeight(cm.display);\n    if (y1 < 0) y1 = 0;\n    var screen = display.scroller.clientHeight - scrollerCutOff,\n        screentop = display.scroller.scrollTop,\n        result = {};\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = y1 < snapMargin,\n        atBottom = y2 > docBottom - snapMargin;\n\n    if (y1 < screentop) {\n      result.scrollTop = atTop ? 0 : y1;\n    } else if (y2 > screentop + screen) {\n      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\n      if (newTop != screentop) result.scrollTop = newTop;\n    }\n\n    var screenw = display.scroller.clientWidth - scrollerCutOff,\n        screenleft = display.scroller.scrollLeft;\n    x1 += display.gutters.offsetWidth;\n    x2 += display.gutters.offsetWidth;\n    var gutterw = display.gutters.offsetWidth;\n    var atLeft = x1 < gutterw + 10;\n\n    if (x1 < screenleft + gutterw || atLeft) {\n      if (atLeft) x1 = 0;\n      result.scrollLeft = Math.max(0, x1 - 10 - gutterw);\n    } else if (x2 > screenw + screenleft - 3) {\n      result.scrollLeft = x2 + 10 - screenw;\n    }\n\n    return result;\n  }\n\n  function updateScrollPos(cm, left, top) {\n    cm.curOp.updateScrollPos = {\n      scrollLeft: left == null ? cm.doc.scrollLeft : left,\n      scrollTop: top == null ? cm.doc.scrollTop : top\n    };\n  }\n\n  function addToScrollPos(cm, left, top) {\n    var pos = cm.curOp.updateScrollPos || (cm.curOp.updateScrollPos = {\n      scrollLeft: cm.doc.scrollLeft,\n      scrollTop: cm.doc.scrollTop\n    });\n    var scroll = cm.display.scroller;\n    pos.scrollTop = Math.max(0, Math.min(scroll.scrollHeight - scroll.clientHeight, pos.scrollTop + top));\n    pos.scrollLeft = Math.max(0, Math.min(scroll.scrollWidth - scroll.clientWidth, pos.scrollLeft + left));\n  } // API UTILITIES\n\n\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc;\n    if (how == null) how = \"add\";\n\n    if (how == \"smart\") {\n      if (!cm.doc.mode.indent) how = \"prev\";else var state = getStateBefore(cm, n);\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n),\n        curSpace = countColumn(line.text, null, tabSize);\n    var curSpaceString = line.text.match(/^\\s*/)[0],\n        indentation;\n\n    if (how == \"smart\") {\n      indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n\n      if (indentation == Pass) {\n        if (!aggressive) return;\n        how = \"prev\";\n      }\n    }\n\n    if (how == \"prev\") {\n      if (n > doc.first) indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);else indentation = 0;\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n\n    indentation = Math.max(0, indentation);\n    var indentString = \"\",\n        pos = 0;\n    if (cm.options.indentWithTabs) for (var i = Math.floor(indentation / tabSize); i; --i) {\n      pos += tabSize;\n      indentString += \"\\t\";\n    }\n    if (pos < indentation) indentString += spaceStr(indentation - pos);\n    if (indentString != curSpaceString) _replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n    line.stateAfter = null;\n  }\n\n  function changeLine(cm, handle, op) {\n    var no = handle,\n        line = handle,\n        doc = cm.doc;\n    if (typeof handle == \"number\") line = getLine(doc, clipLine(doc, handle));else no = lineNo(handle);\n    if (no == null) return null;\n    if (op(line, no)) regChange(cm, no, no + 1);else return null;\n    return line;\n  }\n\n  function _findPosH(doc, pos, dir, unit, visually) {\n    var line = pos.line,\n        ch = pos.ch,\n        origDir = dir;\n    var lineObj = getLine(doc, line);\n    var possible = true;\n\n    function findNextLine() {\n      var l = line + dir;\n      if (l < doc.first || l >= doc.first + doc.size) return possible = false;\n      line = l;\n      return lineObj = getLine(doc, l);\n    }\n\n    function moveOnce(boundToLine) {\n      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\n\n      if (next == null) {\n        if (!boundToLine && findNextLine()) {\n          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);else ch = dir < 0 ? lineObj.text.length : 0;\n        } else return possible = false;\n      } else ch = next;\n\n      return true;\n    }\n\n    if (unit == \"char\") moveOnce();else if (unit == \"column\") moveOnce(true);else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null,\n          group = unit == \"group\";\n\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) break;\n        var cur = lineObj.text.charAt(ch) || \"\\n\";\n        var type = isWordChar(cur) ? \"w\" : !group ? null : /\\s/.test(cur) ? null : \"p\";\n\n        if (sawType && sawType != type) {\n          if (dir < 0) {\n            dir = 1;\n            moveOnce();\n          }\n\n          break;\n        }\n\n        if (type) sawType = type;\n        if (dir > 0 && !moveOnce(!first)) break;\n      }\n    }\n    var result = skipAtomic(doc, Pos(line, ch), origDir, true);\n    if (!possible) result.hitSide = true;\n    return result;\n  }\n\n  function _findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc,\n        x = pos.left,\n        y;\n\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n\n    for (;;) {\n      var target = _coordsChar(cm, x, y);\n\n      if (!target.outside) break;\n\n      if (dir < 0 ? y <= 0 : y >= doc.height) {\n        target.hitSide = true;\n        break;\n      }\n\n      y += dir * 5;\n    }\n\n    return target;\n  }\n\n  function findWordAt(line, pos) {\n    var start = pos.ch,\n        end = pos.ch;\n\n    if (line) {\n      if (pos.xRel < 0 || end == line.length) --start;else ++end;\n      var startChar = line.charAt(start);\n      var check = isWordChar(startChar) ? isWordChar : /\\s/.test(startChar) ? function (ch) {\n        return /\\s/.test(ch);\n      } : function (ch) {\n        return !/\\s/.test(ch) && !isWordChar(ch);\n      };\n\n      while (start > 0 && check(line.charAt(start - 1))) {\n        --start;\n      }\n\n      while (end < line.length && check(line.charAt(end))) {\n        ++end;\n      }\n    }\n\n    return {\n      from: Pos(pos.line, start),\n      to: Pos(pos.line, end)\n    };\n  }\n\n  function selectLine(cm, line) {\n    extendSelection(cm.doc, Pos(line, 0), _clipPos(cm.doc, Pos(line + 1, 0)));\n  } // PROTOTYPE\n  // The publicly visible API. Note that operation(null, f) means\n  // 'wrap f in an operation, performed on its `this` parameter'\n\n\n  CodeMirror.prototype = {\n    constructor: CodeMirror,\n    focus: function focus() {\n      window.focus();\n      focusInput(this);\n      onFocus(this);\n      fastPoll(this);\n    },\n    setOption: function setOption(option, value) {\n      var options = this.options,\n          old = options[option];\n      if (options[option] == value && option != \"mode\") return;\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option)) operation(this, optionHandlers[option])(this, value, old);\n    },\n    getOption: function getOption(option) {\n      return this.options[option];\n    },\n    getDoc: function getDoc() {\n      return this.doc;\n    },\n    addKeyMap: function addKeyMap(map, bottom) {\n      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](map);\n    },\n    removeKeyMap: function removeKeyMap(map) {\n      var maps = this.state.keyMaps;\n\n      for (var i = 0; i < maps.length; ++i) {\n        if ((typeof map == \"string\" ? maps[i].name : maps[i]) == map) {\n          maps.splice(i, 1);\n          return true;\n        }\n      }\n    },\n    addOverlay: operation(null, function (spec, options) {\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n      if (mode.startState) throw new Error(\"Overlays may not be stateful.\");\n      this.state.overlays.push({\n        mode: mode,\n        modeSpec: spec,\n        opaque: options && options.opaque\n      });\n      this.state.modeGen++;\n      regChange(this);\n    }),\n    removeOverlay: operation(null, function (spec) {\n      var overlays = this.state.overlays;\n\n      for (var i = 0; i < overlays.length; ++i) {\n        var cur = overlays[i].modeSpec;\n\n        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n          overlays.splice(i, 1);\n          this.state.modeGen++;\n          regChange(this);\n          return;\n        }\n      }\n    }),\n    indentLine: operation(null, function (n, dir, aggressive) {\n      if (typeof dir != \"string\" && typeof dir != \"number\") {\n        if (dir == null) dir = this.options.smartIndent ? \"smart\" : \"prev\";else dir = dir ? \"add\" : \"subtract\";\n      }\n\n      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\n    }),\n    indentSelection: operation(null, function (how) {\n      var sel = this.doc.sel;\n      if (posEq(sel.from, sel.to)) return indentLine(this, sel.from.line, how);\n      var e = sel.to.line - (sel.to.ch ? 0 : 1);\n\n      for (var i = sel.from.line; i <= e; ++i) {\n        indentLine(this, i, how);\n      }\n    }),\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function getTokenAt(pos, precise) {\n      var doc = this.doc;\n      pos = _clipPos(doc, pos);\n      var state = getStateBefore(this, pos.line, precise),\n          mode = this.doc.mode;\n      var line = getLine(doc, pos.line);\n      var stream = new StringStream(line.text, this.options.tabSize);\n\n      while (stream.pos < pos.ch && !stream.eol()) {\n        stream.start = stream.pos;\n        var style = mode.token(stream, state);\n      }\n\n      return {\n        start: stream.start,\n        end: stream.pos,\n        string: stream.current(),\n        className: style || null,\n        // Deprecated, use 'type' instead\n        type: style || null,\n        state: state\n      };\n    },\n    getTokenTypeAt: function getTokenTypeAt(pos) {\n      pos = _clipPos(this.doc, pos);\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n      var before = 0,\n          after = (styles.length - 1) / 2,\n          ch = pos.ch;\n\n      for (;;) {\n        var mid = before + after >> 1;\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;else if (styles[mid * 2 + 1] < ch) before = mid + 1;else return styles[mid * 2 + 2];\n      }\n    },\n    getStateAfter: function getStateAfter(line, precise) {\n      var doc = this.doc;\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);\n      return getStateBefore(this, line + 1, precise);\n    },\n    cursorCoords: function cursorCoords(start, mode) {\n      var pos,\n          sel = this.doc.sel;\n      if (start == null) pos = sel.head;else if (_typeof(start) == \"object\") pos = _clipPos(this.doc, start);else pos = start ? sel.from : sel.to;\n      return _cursorCoords(this, pos, mode || \"page\");\n    },\n    charCoords: function charCoords(pos, mode) {\n      return _charCoords(this, _clipPos(this.doc, pos), mode || \"page\");\n    },\n    coordsChar: function coordsChar(coords, mode) {\n      coords = fromCoordSystem(this, coords, mode || \"page\");\n      return _coordsChar(this, coords.left, coords.top);\n    },\n    lineAtHeight: function lineAtHeight(height, mode) {\n      height = fromCoordSystem(this, {\n        top: height,\n        left: 0\n      }, mode || \"page\").top;\n      return _lineAtHeight(this.doc, height + this.display.viewOffset);\n    },\n    heightAtLine: function heightAtLine(line, mode) {\n      var end = false,\n          last = this.doc.first + this.doc.size - 1;\n      if (line < this.doc.first) line = this.doc.first;else if (line > last) {\n        line = last;\n        end = true;\n      }\n      var lineObj = getLine(this.doc, line);\n      return intoCoordSystem(this, getLine(this.doc, line), {\n        top: 0,\n        left: 0\n      }, mode || \"page\").top + (end ? lineObj.height : 0);\n    },\n    defaultTextHeight: function defaultTextHeight() {\n      return textHeight(this.display);\n    },\n    defaultCharWidth: function defaultCharWidth() {\n      return charWidth(this.display);\n    },\n    setGutterMarker: operation(null, function (line, gutterID, value) {\n      return changeLine(this, line, function (line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) line.gutterMarkers = null;\n        return true;\n      });\n    }),\n    clearGutter: operation(null, function (gutterID) {\n      var cm = this,\n          doc = cm.doc,\n          i = doc.first;\n      doc.iter(function (line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          line.gutterMarkers[gutterID] = null;\n          regChange(cm, i, i + 1);\n          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\n        }\n\n        ++i;\n      });\n    }),\n    addLineClass: operation(null, function (handle, where, cls) {\n      return changeLine(this, handle, function (line) {\n        var prop = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : \"wrapClass\";\n        if (!line[prop]) line[prop] = cls;else if (new RegExp(\"(?:^|\\\\s)\" + cls + \"(?:$|\\\\s)\").test(line[prop])) return false;else line[prop] += \" \" + cls;\n        return true;\n      });\n    }),\n    removeLineClass: operation(null, function (handle, where, cls) {\n      return changeLine(this, handle, function (line) {\n        var prop = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : \"wrapClass\";\n        var cur = line[prop];\n        if (!cur) return false;else if (cls == null) line[prop] = null;else {\n          var found = cur.match(new RegExp(\"(?:^|\\\\s+)\" + cls + \"(?:$|\\\\s+)\"));\n          if (!found) return false;\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n        return true;\n      });\n    }),\n    addLineWidget: operation(null, function (handle, node, options) {\n      return addLineWidget(this, handle, node, options);\n    }),\n    removeLineWidget: function removeLineWidget(widget) {\n      widget.clear();\n    },\n    lineInfo: function lineInfo(line) {\n      if (typeof line == \"number\") {\n        if (!isLine(this.doc, line)) return null;\n        var n = line;\n        line = getLine(this.doc, line);\n        if (!line) return null;\n      } else {\n        var n = lineNo(line);\n        if (n == null) return null;\n      }\n\n      return {\n        line: n,\n        handle: line,\n        text: line.text,\n        gutterMarkers: line.gutterMarkers,\n        textClass: line.textClass,\n        bgClass: line.bgClass,\n        wrapClass: line.wrapClass,\n        widgets: line.widgets\n      };\n    },\n    getViewport: function getViewport() {\n      return {\n        from: this.display.showingFrom,\n        to: this.display.showingTo\n      };\n    },\n    addWidget: function addWidget(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = _cursorCoords(this, _clipPos(this.doc, pos));\n      var top = pos.bottom,\n          left = pos.left;\n      node.style.position = \"absolute\";\n      display.sizer.appendChild(node);\n\n      if (vert == \"over\") {\n        top = pos.top;\n      } else if (vert == \"above\" || vert == \"near\") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n            hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth); // Default to positioning above (if specified and possible); otherwise default to positioning below\n\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) top = pos.top - node.offsetHeight;else if (pos.bottom + node.offsetHeight <= vspace) top = pos.bottom;\n        if (left + node.offsetWidth > hspace) left = hspace - node.offsetWidth;\n      }\n\n      node.style.top = top + \"px\";\n      node.style.left = node.style.right = \"\";\n\n      if (horiz == \"right\") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = \"0px\";\n      } else {\n        if (horiz == \"left\") left = 0;else if (horiz == \"middle\") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n        node.style.left = left + \"px\";\n      }\n\n      if (scroll) scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\n    },\n    triggerOnKeyDown: operation(null, onKeyDown),\n    execCommand: function execCommand(cmd) {\n      return commands[cmd](this);\n    },\n    findPosH: function findPosH(from, amount, unit, visually) {\n      var dir = 1;\n\n      if (amount < 0) {\n        dir = -1;\n        amount = -amount;\n      }\n\n      for (var i = 0, cur = _clipPos(this.doc, from); i < amount; ++i) {\n        cur = _findPosH(this.doc, cur, dir, unit, visually);\n        if (cur.hitSide) break;\n      }\n\n      return cur;\n    },\n    moveH: operation(null, function (dir, unit) {\n      var sel = this.doc.sel,\n          pos;\n      if (sel.shift || sel.extend || posEq(sel.from, sel.to)) pos = _findPosH(this.doc, sel.head, dir, unit, this.options.rtlMoveVisually);else pos = dir < 0 ? sel.from : sel.to;\n      extendSelection(this.doc, pos, pos, dir);\n    }),\n    deleteH: operation(null, function (dir, unit) {\n      var sel = this.doc.sel;\n      if (!posEq(sel.from, sel.to)) _replaceRange(this.doc, \"\", sel.from, sel.to, \"+delete\");else _replaceRange(this.doc, \"\", sel.from, _findPosH(this.doc, sel.head, dir, unit, false), \"+delete\");\n      this.curOp.userSelChange = true;\n    }),\n    findPosV: function findPosV(from, amount, unit, goalColumn) {\n      var dir = 1,\n          x = goalColumn;\n\n      if (amount < 0) {\n        dir = -1;\n        amount = -amount;\n      }\n\n      for (var i = 0, cur = _clipPos(this.doc, from); i < amount; ++i) {\n        var coords = _cursorCoords(this, cur, \"div\");\n\n        if (x == null) x = coords.left;else coords.left = x;\n        cur = _findPosV(this, coords, dir, unit);\n        if (cur.hitSide) break;\n      }\n\n      return cur;\n    },\n    moveV: operation(null, function (dir, unit) {\n      var sel = this.doc.sel;\n\n      var pos = _cursorCoords(this, sel.head, \"div\");\n\n      if (sel.goalColumn != null) pos.left = sel.goalColumn;\n\n      var target = _findPosV(this, pos, dir, unit);\n\n      if (unit == \"page\") addToScrollPos(this, 0, _charCoords(this, target, \"div\").top - pos.top);\n      extendSelection(this.doc, target, target, dir);\n      sel.goalColumn = pos.left;\n    }),\n    toggleOverwrite: function toggleOverwrite(value) {\n      if (value != null && value == this.state.overwrite) return;\n      if (this.state.overwrite = !this.state.overwrite) this.display.cursor.className += \" CodeMirror-overwrite\";else this.display.cursor.className = this.display.cursor.className.replace(\" CodeMirror-overwrite\", \"\");\n    },\n    hasFocus: function hasFocus() {\n      return this.state.focused;\n    },\n    scrollTo: operation(null, function (x, y) {\n      updateScrollPos(this, x, y);\n    }),\n    getScrollInfo: function getScrollInfo() {\n      var scroller = this.display.scroller,\n          co = scrollerCutOff;\n      return {\n        left: scroller.scrollLeft,\n        top: scroller.scrollTop,\n        height: scroller.scrollHeight - co,\n        width: scroller.scrollWidth - co,\n        clientHeight: scroller.clientHeight - co,\n        clientWidth: scroller.clientWidth - co\n      };\n    },\n    scrollIntoView: operation(null, function (pos, margin) {\n      if (typeof pos == \"number\") pos = Pos(pos, 0);\n      if (!margin) margin = 0;\n      var coords = pos;\n\n      if (!pos || pos.line != null) {\n        this.curOp.scrollToPos = pos ? _clipPos(this.doc, pos) : this.doc.sel.head;\n        this.curOp.scrollToPosMargin = margin;\n        coords = _cursorCoords(this, this.curOp.scrollToPos);\n      }\n\n      var sPos = calculateScrollPos(this, coords.left, coords.top - margin, coords.right, coords.bottom + margin);\n      updateScrollPos(this, sPos.scrollLeft, sPos.scrollTop);\n    }),\n    setSize: function setSize(width, height) {\n      function interpret(val) {\n        return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n      }\n\n      if (width != null) this.display.wrapper.style.width = interpret(width);\n      if (height != null) this.display.wrapper.style.height = interpret(height);\n      this.refresh();\n    },\n    on: function on(type, f) {\n      _on(this, type, f);\n    },\n    off: function off(type, f) {\n      _off(this, type, f);\n    },\n    operation: function operation(f) {\n      return runInOp(this, f);\n    },\n    refresh: operation(null, function () {\n      clearCaches(this);\n      updateScrollPos(this, this.doc.scrollLeft, this.doc.scrollTop);\n      regChange(this);\n    }),\n    swapDoc: operation(null, function (doc) {\n      var old = this.doc;\n      old.cm = null;\n      attachDoc(this, doc);\n      clearCaches(this);\n      resetInput(this, true);\n      updateScrollPos(this, doc.scrollLeft, doc.scrollTop);\n      return old;\n    }),\n    getInputField: function getInputField() {\n      return this.display.input;\n    },\n    getWrapperElement: function getWrapperElement() {\n      return this.display.wrapper;\n    },\n    getScrollerElement: function getScrollerElement() {\n      return this.display.scroller;\n    },\n    getGutterElement: function getGutterElement() {\n      return this.display.gutters;\n    }\n  }; // OPTION DEFAULTS\n\n  var optionHandlers = CodeMirror.optionHandlers = {}; // The default configuration options.\n\n  var defaults = CodeMirror.defaults = {};\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) optionHandlers[name] = notOnInit ? function (cm, val, old) {\n      if (old != Init) handle(cm, val, old);\n    } : handle;\n  }\n\n  var Init = CodeMirror.Init = {\n    toString: function toString() {\n      return \"CodeMirror.Init\";\n    }\n  }; // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n\n  option(\"value\", \"\", function (cm, val) {\n    cm.setValue(val);\n  }, true);\n  option(\"mode\", null, function (cm, val) {\n    cm.doc.modeOption = val;\n    loadMode(cm);\n  }, true);\n  option(\"indentUnit\", 2, loadMode, true);\n  option(\"indentWithTabs\", false);\n  option(\"smartIndent\", true);\n  option(\"tabSize\", 4, function (cm) {\n    loadMode(cm);\n    clearCaches(cm);\n    regChange(cm);\n  }, true);\n  option(\"electricChars\", true);\n  option(\"rtlMoveVisually\", !windows);\n  option(\"theme\", \"default\", function (cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option(\"keyMap\", \"default\", keyMapChanged);\n  option(\"extraKeys\", null);\n  option(\"onKeyEvent\", null);\n  option(\"onDragEvent\", null);\n  option(\"lineWrapping\", false, wrappingChanged, true);\n  option(\"gutters\", [], function (cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"fixedGutter\", true, function (cm, val) {\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n    cm.refresh();\n  }, true);\n  option(\"coverGutterNextToScrollbar\", false, updateScrollbars, true);\n  option(\"lineNumbers\", false, function (cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"firstLineNumber\", 1, guttersChanged, true);\n  option(\"lineNumberFormatter\", function (integer) {\n    return integer;\n  }, guttersChanged, true);\n  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n  option(\"readOnly\", false, function (cm, val) {\n    if (val == \"nocursor\") {\n      onBlur(cm);\n      cm.display.input.blur();\n    } else if (!val) resetInput(cm, true);\n  });\n  option(\"dragDrop\", true);\n  option(\"cursorBlinkRate\", 530);\n  option(\"cursorScrollMargin\", 0);\n  option(\"cursorHeight\", 1);\n  option(\"workTime\", 100);\n  option(\"workDelay\", 100);\n  option(\"flattenSpans\", true);\n  option(\"pollInterval\", 100);\n  option(\"undoDepth\", 40, function (cm, val) {\n    cm.doc.history.undoDepth = val;\n  });\n  option(\"historyEventDelay\", 500);\n  option(\"viewportMargin\", 10, function (cm) {\n    cm.refresh();\n  }, true);\n  option(\"maxHighlightLength\", 10000, function (cm) {\n    loadMode(cm);\n    cm.refresh();\n  }, true);\n  option(\"moveInputWithCursor\", true, function (cm, val) {\n    if (!val) cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;\n  });\n  option(\"tabindex\", null, function (cm, val) {\n    cm.display.input.tabIndex = val || \"\";\n  });\n  option(\"autofocus\", null); // MODE DEFINITION AND QUERYING\n  // Known modes, by name and by MIME\n\n  var modes = CodeMirror.modes = {},\n      mimeModes = CodeMirror.mimeModes = {};\n\n  CodeMirror.defineMode = function (name, mode) {\n    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\n\n    if (arguments.length > 2) {\n      mode.dependencies = [];\n\n      for (var i = 2; i < arguments.length; ++i) {\n        mode.dependencies.push(arguments[i]);\n      }\n    }\n\n    modes[name] = mode;\n  };\n\n  CodeMirror.defineMIME = function (mime, spec) {\n    mimeModes[mime] = spec;\n  };\n\n  CodeMirror.resolveMode = function (spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return CodeMirror.resolveMode(\"application/xml\");\n    }\n\n    if (typeof spec == \"string\") return {\n      name: spec\n    };else return spec || {\n      name: \"null\"\n    };\n  };\n\n  CodeMirror.getMode = function (options, spec) {\n    spec = CodeMirror.resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) return CodeMirror.getMode(options, \"text/plain\");\n    var modeObj = mfactory(options, spec);\n\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) continue;\n        if (modeObj.hasOwnProperty(prop)) modeObj[\"_\" + prop] = modeObj[prop];\n        modeObj[prop] = exts[prop];\n      }\n    }\n\n    modeObj.name = spec.name;\n    return modeObj;\n  };\n\n  CodeMirror.defineMode(\"null\", function () {\n    return {\n      token: function token(stream) {\n        stream.skipToEnd();\n      }\n    };\n  });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n  var modeExtensions = CodeMirror.modeExtensions = {};\n\n  CodeMirror.extendMode = function (mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};\n    copyObj(properties, exts);\n  }; // EXTENSIONS\n\n\n  CodeMirror.defineExtension = function (name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n\n  CodeMirror.defineDocExtension = function (name, func) {\n    Doc.prototype[name] = func;\n  };\n\n  CodeMirror.defineOption = option;\n  var initHooks = [];\n\n  CodeMirror.defineInitHook = function (f) {\n    initHooks.push(f);\n  }; // MODE STATE HANDLING\n  // Utility functions for working with state. Exported because modes\n  // sometimes need to do this.\n\n\n  function copyState(mode, state) {\n    if (state === true) return state;\n    if (mode.copyState) return mode.copyState(state);\n    var nstate = {};\n\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) val = val.concat([]);\n      nstate[n] = val;\n    }\n\n    return nstate;\n  }\n\n  CodeMirror.copyState = copyState;\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true;\n  }\n\n  CodeMirror.startState = startState;\n\n  CodeMirror.innerMode = function (mode, state) {\n    while (mode.innerMode) {\n      var info = mode.innerMode(state);\n      state = info.state;\n      mode = info.mode;\n    }\n\n    return info || {\n      mode: mode,\n      state: state\n    };\n  }; // STANDARD COMMANDS\n\n\n  var commands = CodeMirror.commands = {\n    selectAll: function selectAll(cm) {\n      cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()));\n    },\n    killLine: function killLine(cm) {\n      var from = cm.getCursor(true),\n          to = cm.getCursor(false),\n          sel = !posEq(from, to);\n      if (!sel && cm.getLine(from.line).length == from.ch) cm.replaceRange(\"\", from, Pos(from.line + 1, 0), \"+delete\");else cm.replaceRange(\"\", from, sel ? to : Pos(from.line), \"+delete\");\n    },\n    deleteLine: function deleteLine(cm) {\n      var l = cm.getCursor().line;\n      cm.replaceRange(\"\", Pos(l, 0), Pos(l), \"+delete\");\n    },\n    delLineLeft: function delLineLeft(cm) {\n      var cur = cm.getCursor();\n      cm.replaceRange(\"\", Pos(cur.line, 0), cur, \"+delete\");\n    },\n    undo: function undo(cm) {\n      cm.undo();\n    },\n    redo: function redo(cm) {\n      cm.redo();\n    },\n    goDocStart: function goDocStart(cm) {\n      cm.extendSelection(Pos(cm.firstLine(), 0));\n    },\n    goDocEnd: function goDocEnd(cm) {\n      cm.extendSelection(Pos(cm.lastLine()));\n    },\n    goLineStart: function goLineStart(cm) {\n      cm.extendSelection(lineStart(cm, cm.getCursor().line));\n    },\n    goLineStartSmart: function goLineStartSmart(cm) {\n      var cur = cm.getCursor(),\n          start = lineStart(cm, cur.line);\n      var line = cm.getLineHandle(start.line);\n      var order = getOrder(line);\n\n      if (!order || order[0].level == 0) {\n        var firstNonWS = Math.max(0, line.text.search(/\\S/));\n        var inWS = cur.line == start.line && cur.ch <= firstNonWS && cur.ch;\n        cm.extendSelection(Pos(start.line, inWS ? 0 : firstNonWS));\n      } else cm.extendSelection(start);\n    },\n    goLineEnd: function goLineEnd(cm) {\n      cm.extendSelection(lineEnd(cm, cm.getCursor().line));\n    },\n    goLineRight: function goLineRight(cm) {\n      var top = cm.charCoords(cm.getCursor(), \"div\").top + 5;\n      cm.extendSelection(cm.coordsChar({\n        left: cm.display.lineDiv.offsetWidth + 100,\n        top: top\n      }, \"div\"));\n    },\n    goLineLeft: function goLineLeft(cm) {\n      var top = cm.charCoords(cm.getCursor(), \"div\").top + 5;\n      cm.extendSelection(cm.coordsChar({\n        left: 0,\n        top: top\n      }, \"div\"));\n    },\n    goLineUp: function goLineUp(cm) {\n      cm.moveV(-1, \"line\");\n    },\n    goLineDown: function goLineDown(cm) {\n      cm.moveV(1, \"line\");\n    },\n    goPageUp: function goPageUp(cm) {\n      cm.moveV(-1, \"page\");\n    },\n    goPageDown: function goPageDown(cm) {\n      cm.moveV(1, \"page\");\n    },\n    goCharLeft: function goCharLeft(cm) {\n      cm.moveH(-1, \"char\");\n    },\n    goCharRight: function goCharRight(cm) {\n      cm.moveH(1, \"char\");\n    },\n    goColumnLeft: function goColumnLeft(cm) {\n      cm.moveH(-1, \"column\");\n    },\n    goColumnRight: function goColumnRight(cm) {\n      cm.moveH(1, \"column\");\n    },\n    goWordLeft: function goWordLeft(cm) {\n      cm.moveH(-1, \"word\");\n    },\n    goGroupRight: function goGroupRight(cm) {\n      cm.moveH(1, \"group\");\n    },\n    goGroupLeft: function goGroupLeft(cm) {\n      cm.moveH(-1, \"group\");\n    },\n    goWordRight: function goWordRight(cm) {\n      cm.moveH(1, \"word\");\n    },\n    delCharBefore: function delCharBefore(cm) {\n      cm.deleteH(-1, \"char\");\n    },\n    delCharAfter: function delCharAfter(cm) {\n      cm.deleteH(1, \"char\");\n    },\n    delWordBefore: function delWordBefore(cm) {\n      cm.deleteH(-1, \"word\");\n    },\n    delWordAfter: function delWordAfter(cm) {\n      cm.deleteH(1, \"word\");\n    },\n    delGroupBefore: function delGroupBefore(cm) {\n      cm.deleteH(-1, \"group\");\n    },\n    delGroupAfter: function delGroupAfter(cm) {\n      cm.deleteH(1, \"group\");\n    },\n    indentAuto: function indentAuto(cm) {\n      cm.indentSelection(\"smart\");\n    },\n    indentMore: function indentMore(cm) {\n      cm.indentSelection(\"add\");\n    },\n    indentLess: function indentLess(cm) {\n      cm.indentSelection(\"subtract\");\n    },\n    insertTab: function insertTab(cm) {\n      cm.replaceSelection(\"\\t\", \"end\", \"+input\");\n    },\n    defaultTab: function defaultTab(cm) {\n      if (cm.somethingSelected()) cm.indentSelection(\"add\");else cm.replaceSelection(\"\\t\", \"end\", \"+input\");\n    },\n    transposeChars: function transposeChars(cm) {\n      var cur = cm.getCursor(),\n          line = cm.getLine(cur.line);\n      if (cur.ch > 0 && cur.ch < line.length - 1) cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1), Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));\n    },\n    newlineAndIndent: function newlineAndIndent(cm) {\n      operation(cm, function () {\n        cm.replaceSelection(\"\\n\", \"end\", \"+input\");\n        cm.indentLine(cm.getCursor().line, null, true);\n      })();\n    },\n    toggleOverwrite: function toggleOverwrite(cm) {\n      cm.toggleOverwrite();\n    }\n  }; // STANDARD KEYMAPS\n\n  var keyMap = CodeMirror.keyMap = {};\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\",\n    \"Right\": \"goCharRight\",\n    \"Up\": \"goLineUp\",\n    \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\",\n    \"Home\": \"goLineStartSmart\",\n    \"PageUp\": \"goPageUp\",\n    \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\",\n    \"Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\",\n    \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\",\n    \"Insert\": \"toggleOverwrite\"\n  }; // Note that the save and find-related commands aren't defined by\n  // default. Unknown commands are simply ignored.\n\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\",\n    \"Ctrl-D\": \"deleteLine\",\n    \"Ctrl-Z\": \"undo\",\n    \"Shift-Ctrl-Z\": \"redo\",\n    \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\",\n    \"Alt-Up\": \"goDocStart\",\n    \"Ctrl-End\": \"goDocEnd\",\n    \"Ctrl-Down\": \"goDocEnd\",\n    \"Ctrl-Left\": \"goGroupLeft\",\n    \"Ctrl-Right\": \"goGroupRight\",\n    \"Alt-Left\": \"goLineStart\",\n    \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Delete\": \"delGroupAfter\",\n    \"Ctrl-S\": \"save\",\n    \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\",\n    \"Shift-Ctrl-G\": \"findPrev\",\n    \"Shift-Ctrl-F\": \"replace\",\n    \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\",\n    \"Ctrl-]\": \"indentMore\",\n    fallthrough: \"basic\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\",\n    \"Cmd-D\": \"deleteLine\",\n    \"Cmd-Z\": \"undo\",\n    \"Shift-Cmd-Z\": \"redo\",\n    \"Cmd-Y\": \"redo\",\n    \"Cmd-Up\": \"goDocStart\",\n    \"Cmd-End\": \"goDocEnd\",\n    \"Cmd-Down\": \"goDocEnd\",\n    \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\",\n    \"Cmd-Left\": \"goLineStart\",\n    \"Cmd-Right\": \"goLineEnd\",\n    \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\",\n    \"Alt-Delete\": \"delGroupAfter\",\n    \"Cmd-S\": \"save\",\n    \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\",\n    \"Shift-Cmd-G\": \"findPrev\",\n    \"Cmd-Alt-F\": \"replace\",\n    \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\",\n    \"Cmd-]\": \"indentMore\",\n    \"Cmd-Backspace\": \"delLineLeft\",\n    fallthrough: [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\",\n    \"Ctrl-B\": \"goCharLeft\",\n    \"Ctrl-P\": \"goLineUp\",\n    \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\",\n    \"Alt-B\": \"goWordLeft\",\n    \"Ctrl-A\": \"goLineStart\",\n    \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageDown\",\n    \"Shift-Ctrl-V\": \"goPageUp\",\n    \"Ctrl-D\": \"delCharAfter\",\n    \"Ctrl-H\": \"delCharBefore\",\n    \"Alt-D\": \"delWordAfter\",\n    \"Alt-Backspace\": \"delWordBefore\",\n    \"Ctrl-K\": \"killLine\",\n    \"Ctrl-T\": \"transposeChars\"\n  }; // KEYMAP DISPATCH\n\n  function getKeyMap(val) {\n    if (typeof val == \"string\") return keyMap[val];else return val;\n  }\n\n  function lookupKey(name, maps, handle) {\n    function lookup(map) {\n      map = getKeyMap(map);\n      var found = map[name];\n      if (found === false) return \"stop\";\n      if (found != null && handle(found)) return true;\n      if (map.nofallthrough) return \"stop\";\n      var fallthrough = map.fallthrough;\n      if (fallthrough == null) return false;\n      if (Object.prototype.toString.call(fallthrough) != \"[object Array]\") return lookup(fallthrough);\n\n      for (var i = 0, e = fallthrough.length; i < e; ++i) {\n        var done = lookup(fallthrough[i]);\n        if (done) return done;\n      }\n\n      return false;\n    }\n\n    for (var i = 0; i < maps.length; ++i) {\n      var done = lookup(maps[i]);\n      if (done) return done != \"stop\";\n    }\n  }\n\n  function isModifierKey(event) {\n    var name = keyNames[event.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n  }\n\n  function keyName(event, noShift) {\n    if (opera && event.keyCode == 34 && event[\"char\"]) return false;\n    var name = keyNames[event.keyCode];\n    if (name == null || event.altGraphKey) return false;\n    if (event.altKey) name = \"Alt-\" + name;\n    if (flipCtrlCmd ? event.metaKey : event.ctrlKey) name = \"Ctrl-\" + name;\n    if (flipCtrlCmd ? event.ctrlKey : event.metaKey) name = \"Cmd-\" + name;\n    if (!noShift && event.shiftKey) name = \"Shift-\" + name;\n    return name;\n  }\n\n  CodeMirror.lookupKey = lookupKey;\n  CodeMirror.isModifierKey = isModifierKey;\n  CodeMirror.keyName = keyName; // FROMTEXTAREA\n\n  CodeMirror.fromTextArea = function (textarea, options) {\n    if (!options) options = {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabindex) options.tabindex = textarea.tabindex;\n    if (!options.placeholder && textarea.placeholder) options.placeholder = textarea.placeholder; // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n\n    if (options.autofocus == null) {\n      var hasFocus = document.body; // doc.activeElement occasionally throws on IE\n\n      try {\n        hasFocus = document.activeElement;\n      } catch (e) {}\n\n      options.autofocus = hasFocus == textarea || textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {\n      textarea.value = cm.getValue();\n    }\n\n    if (textarea.form) {\n      _on(textarea.form, \"submit\", save); // Deplorable hack to make the submit method do the right thing.\n\n\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form,\n            realSubmit = form.submit;\n\n        try {\n          var wrappedSubmit = form.submit = function () {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch (e) {}\n      }\n    }\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function (node) {\n      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n    }, options);\n    cm.save = save;\n\n    cm.getTextArea = function () {\n      return textarea;\n    };\n\n    cm.toTextArea = function () {\n      save();\n      textarea.parentNode.removeChild(cm.getWrapperElement());\n      textarea.style.display = \"\";\n\n      if (textarea.form) {\n        _off(textarea.form, \"submit\", save);\n\n        if (typeof textarea.form.submit == \"function\") textarea.form.submit = realSubmit;\n      }\n    };\n\n    return cm;\n  }; // STRING STREAM\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n  // The character stream used by a mode's parser.\n\n\n  function StringStream(string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n  }\n\n  StringStream.prototype = {\n    eol: function eol() {\n      return this.pos >= this.string.length;\n    },\n    sol: function sol() {\n      return this.pos == 0;\n    },\n    peek: function peek() {\n      return this.string.charAt(this.pos) || undefined;\n    },\n    next: function next() {\n      if (this.pos < this.string.length) return this.string.charAt(this.pos++);\n    },\n    eat: function eat(match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == \"string\") var ok = ch == match;else var ok = ch && (match.test ? match.test(ch) : match(ch));\n\n      if (ok) {\n        ++this.pos;\n        return ch;\n      }\n    },\n    eatWhile: function eatWhile(match) {\n      var start = this.pos;\n\n      while (this.eat(match)) {}\n\n      return this.pos > start;\n    },\n    eatSpace: function eatSpace() {\n      var start = this.pos;\n\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) {\n        ++this.pos;\n      }\n\n      return this.pos > start;\n    },\n    skipToEnd: function skipToEnd() {\n      this.pos = this.string.length;\n    },\n    skipTo: function skipTo(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n\n      if (found > -1) {\n        this.pos = found;\n        return true;\n      }\n    },\n    backUp: function backUp(n) {\n      this.pos -= n;\n    },\n    column: function column() {\n      if (this.lastColumnPos < this.start) {\n        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n        this.lastColumnPos = this.start;\n      }\n\n      return this.lastColumnValue;\n    },\n    indentation: function indentation() {\n      return countColumn(this.string, null, this.tabSize);\n    },\n    match: function match(pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function cased(str) {\n          return caseInsensitive ? str.toLowerCase() : str;\n        };\n\n        var substr = this.string.substr(this.pos, pattern.length);\n\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function current() {\n      return this.string.slice(this.start, this.pos);\n    }\n  };\n  CodeMirror.StringStream = StringStream; // TEXTMARKERS\n\n  function TextMarker(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n  }\n\n  CodeMirror.TextMarker = TextMarker;\n\n  TextMarker.prototype.clear = function () {\n    if (this.explicitlyCleared) return;\n    var cm = this.doc.cm,\n        withOp = cm && !cm.curOp;\n    if (withOp) startOperation(cm);\n    var min = null,\n        max = null;\n\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.to != null) max = lineNo(line);\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from != null) min = lineNo(line);else if (this.collapsed && !lineIsHidden(this.doc, line) && cm) updateLineHeight(line, textHeight(cm.display));\n    }\n\n    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\n      var visual = visualLine(cm.doc, this.lines[i]),\n          len = lineLength(cm.doc, visual);\n\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    }\n    if (min != null && cm) regChange(cm, min, max + 1);\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) reCheckSelection(cm);\n    }\n\n    if (withOp) endOperation(cm);\n    signalLater(this, \"clear\");\n  };\n\n  TextMarker.prototype.find = function () {\n    var from, to;\n\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n\n      if (span.from != null || span.to != null) {\n        var found = lineNo(line);\n        if (span.from != null) from = Pos(found, span.from);\n        if (span.to != null) to = Pos(found, span.to);\n      }\n    }\n\n    if (this.type == \"bookmark\") return from;\n    return from && {\n      from: from,\n      to: to\n    };\n  };\n\n  TextMarker.prototype.changed = function () {\n    var pos = this.find(),\n        cm = this.doc.cm;\n    if (!pos || !cm) return;\n    var line = getLine(this.doc, pos.from.line);\n    clearCachedMeasurement(cm, line);\n\n    if (pos.from.line >= cm.display.showingFrom && pos.from.line < cm.display.showingTo) {\n      for (var node = cm.display.lineDiv.firstChild; node; node = node.nextSibling) {\n        if (node.lineObj == line) {\n          if (node.offsetHeight != line.height) updateLineHeight(line, node.offsetHeight);\n          break;\n        }\n      }\n\n      runInOp(cm, function () {\n        cm.curOp.selectionChanged = true;\n      });\n    }\n  };\n\n  TextMarker.prototype.attachLine = function (line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n    }\n\n    this.lines.push(line);\n  };\n\n  TextMarker.prototype.detachLine = function (line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n\n  function _markText(doc, from, to, options, type) {\n    if (options && options.shared) return markTextShared(doc, from, to, options, type);\n    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, _markText)(doc, from, to, options, type);\n    var marker = new TextMarker(doc, type);\n    if (type == \"range\" && !posLess(from, to)) return marker;\n    if (options) copyObj(options, marker);\n\n    if (marker.replacedWith) {\n      marker.collapsed = true;\n      marker.replacedWith = elt(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n      if (!options.handleMouseEvents) marker.replacedWith.ignoreEvents = true;\n    }\n\n    if (marker.collapsed) sawCollapsedSpans = true;\n    if (marker.addToHistory) addToHistory(doc, {\n      from: from,\n      to: to,\n      origin: \"markText\"\n    }, {\n      head: doc.sel.head,\n      anchor: doc.sel.anchor\n    }, NaN);\n    var curLine = from.line,\n        size = 0,\n        collapsedAtStart,\n        collapsedAtEnd,\n        cm = doc.cm,\n        updateMaxLine;\n    doc.iter(curLine, to.line + 1, function (line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(doc, line) == cm.display.maxLine) updateMaxLine = true;\n      var span = {\n        from: null,\n        to: null,\n        marker: marker\n      };\n      size += line.text.length;\n\n      if (curLine == from.line) {\n        span.from = from.ch;\n        size -= from.ch;\n      }\n\n      if (curLine == to.line) {\n        span.to = to.ch;\n        size -= line.text.length - to.ch;\n      }\n\n      if (marker.collapsed) {\n        if (curLine == to.line) collapsedAtEnd = collapsedSpanAt(line, to.ch);\n        if (curLine == from.line) collapsedAtStart = collapsedSpanAt(line, from.ch);else updateLineHeight(line, 0);\n      }\n\n      addMarkedSpan(line, span);\n      ++curLine;\n    });\n    if (marker.collapsed) doc.iter(from.line, to.line + 1, function (line) {\n      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\n    });\n    if (marker.clearOnEnter) _on(marker, \"beforeCursorEnter\", function () {\n      marker.clear();\n    });\n\n    if (marker.readOnly) {\n      sawReadOnlySpans = true;\n      if (doc.history.done.length || doc.history.undone.length) doc.clearHistory();\n    }\n\n    if (marker.collapsed) {\n      if (collapsedAtStart != collapsedAtEnd) throw new Error(\"Inserting collapsed marker overlapping an existing one\");\n      marker.size = size;\n      marker.atomic = true;\n    }\n\n    if (cm) {\n      if (updateMaxLine) cm.curOp.updateMaxLine = true;\n      if (marker.className || marker.startStyle || marker.endStyle || marker.collapsed) regChange(cm, from.line, to.line + 1);\n      if (marker.atomic) reCheckSelection(cm);\n    }\n\n    return marker;\n  } // SHARED TEXTMARKERS\n\n\n  function SharedTextMarker(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n\n    for (var i = 0, me = this; i < markers.length; ++i) {\n      markers[i].parent = this;\n\n      _on(markers[i], \"clear\", function () {\n        me.clear();\n      });\n    }\n  }\n\n  CodeMirror.SharedTextMarker = SharedTextMarker;\n\n  SharedTextMarker.prototype.clear = function () {\n    if (this.explicitlyCleared) return;\n    this.explicitlyCleared = true;\n\n    for (var i = 0; i < this.markers.length; ++i) {\n      this.markers[i].clear();\n    }\n\n    signalLater(this, \"clear\");\n  };\n\n  SharedTextMarker.prototype.find = function () {\n    return this.primary.find();\n  };\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [_markText(doc, from, to, options, type)],\n        primary = markers[0];\n    var widget = options.replacedWith;\n    linkedDocs(doc, function (doc) {\n      if (widget) options.replacedWith = widget.cloneNode(true);\n      markers.push(_markText(doc, _clipPos(doc, from), _clipPos(doc, to), options, type));\n\n      for (var i = 0; i < doc.linked.length; ++i) {\n        if (doc.linked[i].isParent) return;\n      }\n\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary);\n  } // TEXTMARKER SPANS\n\n\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) return span;\n    }\n  }\n\n  function removeMarkedSpan(spans, span) {\n    for (var r, i = 0; i < spans.length; ++i) {\n      if (spans[i] != span) (r || (r = [])).push(spans[i]);\n    }\n\n    return r;\n  }\n\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  }\n\n  function markedSpansBefore(old, startCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i],\n          marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n\n      if (startsBefore || marker.type == \"bookmark\" && span.from == startCh && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n        (nw || (nw = [])).push({\n          from: span.from,\n          to: endsAfter ? null : span.to,\n          marker: marker\n        });\n      }\n    }\n    return nw;\n  }\n\n  function markedSpansAfter(old, endCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i],\n          marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n\n      if (endsAfter || marker.type == \"bookmark\" && span.from == endCh && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n        (nw || (nw = [])).push({\n          from: startsBefore ? null : span.from - endCh,\n          to: span.to == null ? null : span.to - endCh,\n          marker: marker\n        });\n      }\n    }\n    return nw;\n  }\n\n  function stretchSpansOverChange(doc, change) {\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) return null;\n    var startCh = change.from.ch,\n        endCh = change.to.ch,\n        isInsert = posEq(change.from, change.to); // Get the spans that 'stick out' on both sides\n\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert); // Next, merge those two ends\n\n    var sameLine = change.text.length == 1,\n        offset = lst(change.text).length + (sameLine ? startCh : 0);\n\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) span.to = startCh;else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n        }\n      }\n    }\n\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i = 0; i < last.length; ++i) {\n        var span = last[i];\n        if (span.to != null) span.to += offset;\n\n        if (span.from == null) {\n          var found = getMarkedSpanFor(first, span.marker);\n\n          if (!found) {\n            span.from = offset;\n            if (sameLine) (first || (first = [])).push(span);\n          }\n        } else {\n          span.from += offset;\n          if (sameLine) (first || (first = [])).push(span);\n        }\n      }\n    }\n\n    if (sameLine && first) {\n      // Make sure we didn't create any zero-length spans\n      for (var i = 0; i < first.length; ++i) {\n        if (first[i].from != null && first[i].from == first[i].to && first[i].marker.type != \"bookmark\") first.splice(i--, 1);\n      }\n\n      if (!first.length) first = null;\n    }\n\n    var newMarkers = [first];\n\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2,\n          gapMarkers;\n      if (gap > 0 && first) for (var i = 0; i < first.length; ++i) {\n        if (first[i].to == null) (gapMarkers || (gapMarkers = [])).push({\n          from: null,\n          to: null,\n          marker: first[i].marker\n        });\n      }\n\n      for (var i = 0; i < gap; ++i) {\n        newMarkers.push(gapMarkers);\n      }\n\n      newMarkers.push(last);\n    }\n\n    return newMarkers;\n  }\n\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) return stretched;\n    if (!stretched) return old;\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i],\n          stretchCur = stretched[i];\n\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n\n          for (var k = 0; k < oldCur.length; ++k) {\n            if (oldCur[k].marker == span.marker) continue spans;\n          }\n\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n\n    return old;\n  }\n\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function (line) {\n      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) (markers || (markers = [])).push(mark);\n      }\n    });\n    if (!markers) return null;\n    var parts = [{\n      from: from,\n      to: to\n    }];\n\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i],\n          m = mk.find();\n\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (posLess(p.to, m.from) || posLess(m.to, p.from)) continue;\n        var newParts = [j, 1];\n        if (posLess(p.from, m.from) || !mk.inclusiveLeft && posEq(p.from, m.from)) newParts.push({\n          from: p.from,\n          to: m.from\n        });\n        if (posLess(m.to, p.to) || !mk.inclusiveRight && posEq(p.to, m.to)) newParts.push({\n          from: m.to,\n          to: p.to\n        });\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 1;\n      }\n    }\n\n    return parts;\n  }\n\n  function collapsedSpanAt(line, ch) {\n    var sps = sawCollapsedSpans && line.markedSpans,\n        found;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      if ((sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || found.width < sp.marker.width)) found = sp.marker;\n    }\n    return found;\n  }\n\n  function collapsedSpanAtStart(line) {\n    return collapsedSpanAt(line, -1);\n  }\n\n  function collapsedSpanAtEnd(line) {\n    return collapsedSpanAt(line, line.text.length + 1);\n  }\n\n  function visualLine(doc, line) {\n    var merged;\n\n    while (merged = collapsedSpanAtStart(line)) {\n      line = getLine(doc, merged.find().from.line);\n    }\n\n    return line;\n  }\n\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      if (sp.from == null) return true;\n      if (sp.marker.replacedWith) continue;\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) return true;\n    }\n  }\n\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find().to,\n          endLine = getLine(doc, end.line);\n      return lineIsHiddenInner(doc, endLine, getMarkedSpanFor(endLine.markedSpans, span.marker));\n    }\n\n    if (span.marker.inclusiveRight && span.to == line.text.length) return true;\n\n    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.replacedWith && sp.from == span.to && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) return true;\n    }\n  }\n\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) return;\n\n    for (var i = 0; i < spans.length; ++i) {\n      spans[i].marker.detachLine(line);\n    }\n\n    line.markedSpans = null;\n  }\n\n  function attachMarkedSpans(line, spans) {\n    if (!spans) return;\n\n    for (var i = 0; i < spans.length; ++i) {\n      spans[i].marker.attachLine(line);\n    }\n\n    line.markedSpans = spans;\n  } // LINE WIDGETS\n\n\n  var LineWidget = CodeMirror.LineWidget = function (cm, node, options) {\n    for (var opt in options) {\n      if (options.hasOwnProperty(opt)) this[opt] = options[opt];\n    }\n\n    this.cm = cm;\n    this.node = node;\n  };\n\n  function widgetOperation(f) {\n    return function () {\n      var withOp = !this.cm.curOp;\n      if (withOp) startOperation(this.cm);\n\n      try {\n        var result = f.apply(this, arguments);\n      } finally {\n        if (withOp) endOperation(this.cm);\n      }\n\n      return result;\n    };\n  }\n\n  LineWidget.prototype.clear = widgetOperation(function () {\n    var ws = this.line.widgets,\n        no = lineNo(this.line);\n    if (no == null || !ws) return;\n\n    for (var i = 0; i < ws.length; ++i) {\n      if (ws[i] == this) ws.splice(i--, 1);\n    }\n\n    if (!ws.length) this.line.widgets = null;\n    updateLineHeight(this.line, Math.max(0, this.line.height - widgetHeight(this)));\n    regChange(this.cm, no, no + 1);\n  });\n  LineWidget.prototype.changed = widgetOperation(function () {\n    var oldH = this.height;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) return;\n    updateLineHeight(this.line, this.line.height + diff);\n    var no = lineNo(this.line);\n    regChange(this.cm, no, no + 1);\n  });\n\n  function widgetHeight(widget) {\n    if (widget.height != null) return widget.height;\n    if (!widget.node.parentNode || widget.node.parentNode.nodeType != 1) removeChildrenAndAdd(widget.cm.display.measure, elt(\"div\", [widget.node], null, \"position: relative\"));\n    return widget.height = widget.node.offsetHeight;\n  }\n\n  function addLineWidget(cm, handle, node, options) {\n    var widget = new LineWidget(cm, node, options);\n    if (widget.noHScroll) cm.display.alignWidgets = true;\n    changeLine(cm, handle, function (line) {\n      (line.widgets || (line.widgets = [])).push(widget);\n      widget.line = line;\n\n      if (!lineIsHidden(cm.doc, line) || widget.showIfHidden) {\n        var aboveVisible = heightAtLine(cm, line) < cm.display.scroller.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) addToScrollPos(cm, 0, widget.height);\n      }\n\n      return true;\n    });\n    return widget;\n  } // LINE DATA STRUCTURE\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n\n\n  function makeLine(text, markedSpans, estimateHeight) {\n    var line = {\n      text: text\n    };\n    attachMarkedSpans(line, markedSpans);\n    line.height = estimateHeight ? estimateHeight(line) : 1;\n    return line;\n  }\n\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) line.stateAfter = null;\n    if (line.styles) line.styles = null;\n    if (line.order != null) line.order = null;\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) updateLineHeight(line, estHeight);\n  }\n\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  } // Run the given mode's parser over a line, update the styles\n  // array, which contains alternating fragments of text and CSS\n  // classes.\n\n\n  function runMode(cm, text, mode, state, f) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\n    var curStart = 0,\n        curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize),\n        style;\n    if (text == \"\" && mode.blankLine) mode.blankLine(state);\n\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false; // Webkit seems to refuse to render text nodes longer than 57444 characters\n\n        stream.pos = Math.min(text.length, stream.start + 50000);\n        style = null;\n      } else {\n        style = mode.token(stream, state);\n      }\n\n      if (!flattenSpans || curStyle != style) {\n        if (curStart < stream.start) f(stream.start, curStyle);\n        curStart = stream.start;\n        curStyle = style;\n      }\n\n      stream.start = stream.pos;\n    }\n\n    if (curStart < stream.pos) f(stream.pos, curStyle);\n  }\n\n  function highlightLine(cm, line, state) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen]; // Compute the base array of styles\n\n    runMode(cm, line.text, cm.doc.mode, state, function (end, style) {\n      st.push(end, style);\n    }); // Run overlays, adjust style array.\n\n    for (var o = 0; o < cm.state.overlays.length; ++o) {\n      var overlay = cm.state.overlays[o],\n          i = 1,\n          at = 0;\n      runMode(cm, line.text, overlay.mode, true, function (end, style) {\n        var start = i; // Ensure there's a token end at the current position, and that i points at it\n\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end) st.splice(i, 1, end, st[i + 1], i_end);\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n\n        if (!style) return;\n\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start + 1];\n            st[start + 1] = cur ? cur + \" \" + style : style;\n          }\n        }\n      });\n    }\n\n    return st;\n  }\n\n  function getLineStyles(cm, line) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) line.styles = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));\n    return line.styles;\n  } // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array.\n\n\n  function processLine(cm, line, state) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(line.text, cm.options.tabSize);\n    if (line.text == \"\" && mode.blankLine) mode.blankLine(state);\n\n    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {\n      mode.token(stream, state);\n      stream.start = stream.pos;\n    }\n  }\n\n  var styleToClassCache = {};\n\n  function styleToClass(style) {\n    if (!style) return null;\n    return styleToClassCache[style] || (styleToClassCache[style] = \"cm-\" + style.replace(/ +/g, \" cm-\"));\n  }\n\n  function lineContent(cm, realLine, measure) {\n    var merged,\n        line = realLine,\n        empty = true;\n\n    while (merged = collapsedSpanAtStart(line)) {\n      line = getLine(cm.doc, merged.find().from.line);\n    }\n\n    var builder = {\n      pre: elt(\"pre\"),\n      col: 0,\n      pos: 0,\n      display: !measure,\n      measure: null,\n      measuredSomething: false,\n      cm: cm\n    };\n    if (line.textClass) builder.pre.className = line.textClass;\n\n    do {\n      if (line.text) empty = false;\n      builder.measure = line == realLine && measure;\n      builder.pos = 0;\n      builder.addToken = builder.measure ? buildTokenMeasure : buildToken;\n      if ((ie || webkit) && cm.getOption(\"lineWrapping\")) builder.addToken = buildTokenSplitSpaces(builder.addToken);\n      var next = insertLineContent(line, builder, getLineStyles(cm, line));\n\n      if (measure && line == realLine && !builder.measuredSomething) {\n        measure[0] = builder.pre.appendChild(zeroWidthElement(cm.display.measure));\n        builder.measuredSomething = true;\n      }\n\n      if (next) line = getLine(cm.doc, next.to.line);\n    } while (next);\n\n    if (measure && !builder.measuredSomething && !measure[0]) measure[0] = builder.pre.appendChild(empty ? elt(\"span\", \"\\xA0\") : zeroWidthElement(cm.display.measure));\n    if (!builder.pre.firstChild && !lineIsHidden(cm.doc, realLine)) builder.pre.appendChild(document.createTextNode(\"\\xA0\"));\n    var order; // Work around problem with the reported dimensions of single-char\n    // direction spans on IE (issue #1129). See also the comment in\n    // cursorCoords.\n\n    if (measure && ie && (order = getOrder(line))) {\n      var l = order.length - 1;\n      if (order[l].from == order[l].to) --l;\n      var last = order[l],\n          prev = order[l - 1];\n\n      if (last.from + 1 == last.to && prev && last.level < prev.level) {\n        var span = measure[builder.pos - 1];\n        if (span) span.parentNode.insertBefore(span.measureRight = zeroWidthElement(cm.display.measure), span.nextSibling);\n      }\n    }\n\n    signal(cm, \"renderLine\", cm, realLine, builder.pre);\n    return builder.pre;\n  }\n\n  var tokenSpecialChars = /[\\t\\u0000-\\u0019\\u00ad\\u200b\\u2028\\u2029\\uFEFF]/g;\n\n  function buildToken(builder, text, style, startStyle, endStyle) {\n    if (!text) return;\n\n    if (!tokenSpecialChars.test(text)) {\n      builder.col += text.length;\n      var content = document.createTextNode(text);\n    } else {\n      var content = document.createDocumentFragment(),\n          pos = 0;\n\n      while (true) {\n        tokenSpecialChars.lastIndex = pos;\n        var m = tokenSpecialChars.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n\n        if (skipped) {\n          content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));\n          builder.col += skipped;\n        }\n\n        if (!m) break;\n        pos += skipped + 1;\n\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize,\n              tabWidth = tabSize - builder.col % tabSize;\n          content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          builder.col += tabWidth;\n        } else {\n          var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n          token.title = \"\\\\u\" + m[0].charCodeAt(0).toString(16);\n          content.appendChild(token);\n          builder.col += 1;\n        }\n      }\n    }\n\n    if (style || startStyle || endStyle || builder.measure) {\n      var fullStyle = style || \"\";\n      if (startStyle) fullStyle += startStyle;\n      if (endStyle) fullStyle += endStyle;\n      return builder.pre.appendChild(elt(\"span\", [content], fullStyle));\n    }\n\n    builder.pre.appendChild(content);\n  }\n\n  function buildTokenMeasure(builder, text, style, startStyle, endStyle) {\n    var wrapping = builder.cm.options.lineWrapping;\n\n    for (var i = 0; i < text.length; ++i) {\n      var ch = text.charAt(i),\n          start = i == 0;\n\n      if (ch >= \"\\uD800\" && ch < \"\\uDBFF\" && i < text.length - 1) {\n        ch = text.slice(i, i + 2);\n        ++i;\n      } else if (i && wrapping && spanAffectsWrapping(text, i)) {\n        builder.pre.appendChild(elt(\"wbr\"));\n      }\n\n      var span = builder.measure[builder.pos] = buildToken(builder, ch, style, start && startStyle, i == text.length - 1 && endStyle); // In IE single-space nodes wrap differently than spaces\n      // embedded in larger text nodes, except when set to\n      // white-space: normal (issue #1268).\n\n      if (ie && wrapping && ch == \" \" && i && !/\\s/.test(text.charAt(i - 1)) && i < text.length - 1 && !/\\s/.test(text.charAt(i + 1))) span.style.whiteSpace = \"normal\";\n      builder.pos += ch.length;\n    }\n\n    if (text.length) builder.measuredSomething = true;\n  }\n\n  function buildTokenSplitSpaces(inner) {\n    function split(old) {\n      var out = \" \";\n\n      for (var i = 0; i < old.length - 2; ++i) {\n        out += i % 2 ? \" \" : \"\\xA0\";\n      }\n\n      out += \" \";\n      return out;\n    }\n\n    return function (builder, text, style, startStyle, endStyle) {\n      return inner(builder, text.replace(/ {3,}/, split), style, startStyle, endStyle);\n    };\n  }\n\n  function buildCollapsedSpan(builder, size, widget) {\n    if (widget) {\n      if (!builder.display) widget = widget.cloneNode(true);\n\n      if (builder.measure) {\n        builder.measure[builder.pos] = size ? widget : builder.pre.appendChild(zeroWidthElement(builder.cm.display.measure));\n        builder.measuredSomething = true;\n      }\n\n      builder.pre.appendChild(widget);\n    }\n\n    builder.pos += size;\n  } // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n\n\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans,\n        allText = line.text,\n        at = 0;\n\n    if (!spans) {\n      for (var i = 1; i < styles.length; i += 2) {\n        builder.addToken(builder, allText.slice(at, at = styles[i]), styleToClass(styles[i + 1]));\n      }\n\n      return;\n    }\n\n    var len = allText.length,\n        pos = 0,\n        i = 1,\n        text = \"\",\n        style;\n    var nextChange = 0,\n        spanStyle,\n        spanEndStyle,\n        spanStartStyle,\n        collapsed;\n\n    for (;;) {\n      if (nextChange == pos) {\n        // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = \"\";\n        collapsed = null;\n        nextChange = Infinity;\n        var foundBookmark = null;\n\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j],\n              m = sp.marker;\n\n          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {\n            if (sp.to != null && nextChange > sp.to) {\n              nextChange = sp.to;\n              spanEndStyle = \"\";\n            }\n\n            if (m.className) spanStyle += \" \" + m.className;\n            if (m.startStyle && sp.from == pos) spanStartStyle += \" \" + m.startStyle;\n            if (m.endStyle && sp.to == nextChange) spanEndStyle += \" \" + m.endStyle;\n            if (m.collapsed && (!collapsed || collapsed.marker.size < m.size)) collapsed = sp;\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n\n          if (m.type == \"bookmark\" && sp.from == pos && m.replacedWith) foundBookmark = m.replacedWith;\n        }\n\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len : collapsed.to) - pos, collapsed.from != null && collapsed.marker.replacedWith);\n          if (collapsed.to == null) return collapsed.marker.find();\n        }\n\n        if (foundBookmark && !collapsed) buildCollapsedSpan(builder, 0, foundBookmark);\n      }\n\n      if (pos >= len) break;\n      var upto = Math.min(len, nextChange);\n\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\");\n          }\n\n          if (end >= upto) {\n            text = text.slice(upto - pos);\n            pos = upto;\n            break;\n          }\n\n          pos = end;\n          spanStartStyle = \"\";\n        }\n\n        text = allText.slice(at, at = styles[i++]);\n        style = styleToClass(styles[i++]);\n      }\n    }\n  } // DOCUMENT DATA STRUCTURE\n\n\n  function updateDoc(doc, change, markedSpans, selAfter, estimateHeight) {\n    function spansFor(n) {\n      return markedSpans ? markedSpans[n] : null;\n    }\n\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight);\n      signalLater(line, \"change\", line, change);\n    }\n\n    var from = change.from,\n        to = change.to,\n        text = change.text;\n    var firstLine = getLine(doc, from.line),\n        lastLine = getLine(doc, to.line);\n    var lastText = lst(text),\n        lastSpans = spansFor(text.length - 1),\n        nlines = to.line - from.line; // First adjust the line structure\n\n    if (from.ch == 0 && to.ch == 0 && lastText == \"\") {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      for (var i = 0, e = text.length - 1, added = []; i < e; ++i) {\n        added.push(makeLine(text[i], spansFor(i), estimateHeight));\n      }\n\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) doc.remove(from.line, nlines);\n      if (added.length) doc.insert(from.line, added);\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        for (var added = [], i = 1, e = text.length - 1; i < e; ++i) {\n          added.push(makeLine(text[i], spansFor(i), estimateHeight));\n        }\n\n        added.push(makeLine(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n\n      for (var i = 1, e = text.length - 1, added = []; i < e; ++i) {\n        added.push(makeLine(text[i], spansFor(i), estimateHeight));\n      }\n\n      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\n      doc.insert(from.line + 1, added);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n    setSelection(doc, selAfter.anchor, selAfter.head, null, true);\n  }\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n\n    for (var i = 0, e = lines.length, height = 0; i < e; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function chunkSize() {\n      return this.lines.length;\n    },\n    removeInner: function removeInner(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n\n      this.lines.splice(at, n);\n    },\n    collapse: function collapse(lines) {\n      lines.splice.apply(lines, [lines.length, 0].concat(this.lines));\n    },\n    insertInner: function insertInner(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n\n      for (var i = 0, e = lines.length; i < e; ++i) {\n        lines[i].parent = this;\n      }\n    },\n    iterN: function iterN(at, n, op) {\n      for (var e = at + n; at < e; ++at) {\n        if (op(this.lines[at])) return true;\n      }\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0,\n        height = 0;\n\n    for (var i = 0, e = children.length; i < e; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize();\n      height += ch.height;\n      ch.parent = this;\n    }\n\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function chunkSize() {\n      return this.size;\n    },\n    removeInner: function removeInner(at, n) {\n      this.size -= n;\n\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i],\n            sz = child.chunkSize();\n\n        if (at < sz) {\n          var rm = Math.min(n, sz - at),\n              oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n\n          if (sz == rm) {\n            this.children.splice(i--, 1);\n            child.parent = null;\n          }\n\n          if ((n -= rm) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n\n      if (this.size - n < 25) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n    collapse: function collapse(lines) {\n      for (var i = 0, e = this.children.length; i < e; ++i) {\n        this.children[i].collapse(lines);\n      }\n    },\n    insertInner: function insertInner(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n\n      for (var i = 0, e = this.children.length; i < e; ++i) {\n        var child = this.children[i],\n            sz = child.chunkSize();\n\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n\n          if (child.lines && child.lines.length > 50) {\n            while (child.lines.length > 50) {\n              var spilled = child.lines.splice(child.lines.length - 25, 25);\n              var newleaf = new LeafChunk(spilled);\n              child.height -= newleaf.height;\n              this.children.splice(i + 1, 0, newleaf);\n              newleaf.parent = this;\n            }\n\n            this.maybeSpill();\n          }\n\n          break;\n        }\n\n        at -= sz;\n      }\n    },\n    maybeSpill: function maybeSpill() {\n      if (this.children.length <= 10) return;\n      var me = this;\n\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n\n        if (!me.parent) {\n          // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n        } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n\n        sibling.parent = me.parent;\n      } while (me.children.length > 10);\n\n      me.parent.maybeSpill();\n    },\n    iterN: function iterN(at, n, op) {\n      for (var i = 0, e = this.children.length; i < e; ++i) {\n        var child = this.children[i],\n            sz = child.chunkSize();\n\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) return true;\n          if ((n -= used) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n    }\n  };\n  var nextDocId = 0;\n\n  var Doc = CodeMirror.Doc = function (text, mode, firstLine) {\n    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);\n    if (firstLine == null) firstLine = 0;\n    BranchChunk.call(this, [new LeafChunk([makeLine(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.history = makeHistory();\n    this.cleanGeneration = 1;\n    this.frontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = {\n      from: start,\n      to: start,\n      head: start,\n      anchor: start,\n      shift: false,\n      extend: false,\n      goalColumn: null\n    };\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n    if (typeof text == \"string\") text = splitLines(text);\n    updateDoc(this, {\n      from: start,\n      to: start,\n      text: text\n    }, null, {\n      head: start,\n      anchor: start\n    });\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    iter: function iter(from, to, op) {\n      if (op) this.iterN(from - this.first, to - from, op);else this.iterN(this.first, this.first + this.size, from);\n    },\n    insert: function insert(at, lines) {\n      var height = 0;\n\n      for (var i = 0, e = lines.length; i < e; ++i) {\n        height += lines[i].height;\n      }\n\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function remove(at, n) {\n      this.removeInner(at - this.first, n);\n    },\n    getValue: function getValue(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || \"\\n\");\n    },\n    setValue: function setValue(code) {\n      var top = Pos(this.first, 0),\n          last = this.first + this.size - 1;\n      makeChange(this, {\n        from: top,\n        to: Pos(last, getLine(this, last).text.length),\n        text: splitLines(code),\n        origin: \"setValue\"\n      }, {\n        head: top,\n        anchor: top\n      }, true);\n    },\n    replaceRange: function replaceRange(code, from, to, origin) {\n      from = _clipPos(this, from);\n      to = to ? _clipPos(this, to) : from;\n\n      _replaceRange(this, code, from, to, origin);\n    },\n    getRange: function getRange(from, to, lineSep) {\n      var lines = getBetween(this, _clipPos(this, from), _clipPos(this, to));\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || \"\\n\");\n    },\n    getLine: function getLine(line) {\n      var l = this.getLineHandle(line);\n      return l && l.text;\n    },\n    setLine: function setLine(line, text) {\n      if (isLine(this, line)) _replaceRange(this, text, Pos(line, 0), _clipPos(this, Pos(line)));\n    },\n    removeLine: function removeLine(line) {\n      if (line) _replaceRange(this, \"\", _clipPos(this, Pos(line - 1)), _clipPos(this, Pos(line)));else _replaceRange(this, \"\", Pos(0, 0), _clipPos(this, Pos(1, 0)));\n    },\n    getLineHandle: function getLineHandle(line) {\n      if (isLine(this, line)) return getLine(this, line);\n    },\n    getLineNumber: function getLineNumber(line) {\n      return lineNo(line);\n    },\n    lineCount: function lineCount() {\n      return this.size;\n    },\n    firstLine: function firstLine() {\n      return this.first;\n    },\n    lastLine: function lastLine() {\n      return this.first + this.size - 1;\n    },\n    clipPos: function clipPos(pos) {\n      return _clipPos(this, pos);\n    },\n    getCursor: function getCursor(start) {\n      var sel = this.sel,\n          pos;\n      if (start == null || start == \"head\") pos = sel.head;else if (start == \"anchor\") pos = sel.anchor;else if (start == \"end\" || start === false) pos = sel.to;else pos = sel.from;\n      return copyPos(pos);\n    },\n    somethingSelected: function somethingSelected() {\n      return !posEq(this.sel.head, this.sel.anchor);\n    },\n    setCursor: docOperation(function (line, ch, extend) {\n      var pos = _clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line);\n\n      if (extend) extendSelection(this, pos);else setSelection(this, pos, pos);\n    }),\n    setSelection: docOperation(function (anchor, head) {\n      setSelection(this, _clipPos(this, anchor), _clipPos(this, head || anchor));\n    }),\n    extendSelection: docOperation(function (from, to) {\n      extendSelection(this, _clipPos(this, from), to && _clipPos(this, to));\n    }),\n    getSelection: function getSelection(lineSep) {\n      return this.getRange(this.sel.from, this.sel.to, lineSep);\n    },\n    replaceSelection: function replaceSelection(code, collapse, origin) {\n      makeChange(this, {\n        from: this.sel.from,\n        to: this.sel.to,\n        text: splitLines(code),\n        origin: origin\n      }, collapse || \"around\");\n    },\n    undo: docOperation(function () {\n      makeChangeFromHistory(this, \"undo\");\n    }),\n    redo: docOperation(function () {\n      makeChangeFromHistory(this, \"redo\");\n    }),\n    setExtending: function setExtending(val) {\n      this.sel.extend = val;\n    },\n    historySize: function historySize() {\n      var hist = this.history;\n      return {\n        undo: hist.done.length,\n        redo: hist.undone.length\n      };\n    },\n    clearHistory: function clearHistory() {\n      this.history = makeHistory(this.history.maxGeneration);\n    },\n    markClean: function markClean() {\n      this.cleanGeneration = this.changeGeneration();\n    },\n    changeGeneration: function changeGeneration() {\n      this.history.lastOp = this.history.lastOrigin = null;\n      return this.history.generation;\n    },\n    isClean: function isClean(gen) {\n      return this.history.generation == (gen || this.cleanGeneration);\n    },\n    getHistory: function getHistory() {\n      return {\n        done: copyHistoryArray(this.history.done),\n        undone: copyHistoryArray(this.history.undone)\n      };\n    },\n    setHistory: function setHistory(histData) {\n      var hist = this.history = makeHistory(this.history.maxGeneration);\n      hist.done = histData.done.slice(0);\n      hist.undone = histData.undone.slice(0);\n    },\n    markText: function markText(from, to, options) {\n      return _markText(this, _clipPos(this, from), _clipPos(this, to), options, \"range\");\n    },\n    setBookmark: function setBookmark(pos, options) {\n      var realOpts = {\n        replacedWith: options && (options.nodeType == null ? options.widget : options),\n        insertLeft: options && options.insertLeft\n      };\n      pos = _clipPos(this, pos);\n      return _markText(this, pos, pos, realOpts, \"bookmark\");\n    },\n    findMarksAt: function findMarksAt(pos) {\n      pos = _clipPos(this, pos);\n      var markers = [],\n          spans = getLine(this, pos.line).markedSpans;\n      if (spans) for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) markers.push(span.marker.parent || span.marker);\n      }\n      return markers;\n    },\n    getAllMarks: function getAllMarks() {\n      var markers = [];\n      this.iter(function (line) {\n        var sps = line.markedSpans;\n        if (sps) for (var i = 0; i < sps.length; ++i) {\n          if (sps[i].from != null) markers.push(sps[i].marker);\n        }\n      });\n      return markers;\n    },\n    posFromIndex: function posFromIndex(off) {\n      var ch,\n          lineNo = this.first;\n      this.iter(function (line) {\n        var sz = line.text.length + 1;\n\n        if (sz > off) {\n          ch = off;\n          return true;\n        }\n\n        off -= sz;\n        ++lineNo;\n      });\n      return _clipPos(this, Pos(lineNo, ch));\n    },\n    indexFromPos: function indexFromPos(coords) {\n      coords = _clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) return 0;\n      this.iter(this.first, coords.line, function (line) {\n        index += line.text.length + 1;\n      });\n      return index;\n    },\n    copy: function copy(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);\n      doc.scrollTop = this.scrollTop;\n      doc.scrollLeft = this.scrollLeft;\n      doc.sel = {\n        from: this.sel.from,\n        to: this.sel.to,\n        head: this.sel.head,\n        anchor: this.sel.anchor,\n        shift: this.sel.shift,\n        extend: false,\n        goalColumn: this.sel.goalColumn\n      };\n\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n\n      return doc;\n    },\n    linkedDoc: function linkedDoc(options) {\n      if (!options) options = {};\n      var from = this.first,\n          to = this.first + this.size;\n      if (options.from != null && options.from > from) from = options.from;\n      if (options.to != null && options.to < to) to = options.to;\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);\n      if (options.sharedHist) copy.history = this.history;\n      (this.linked || (this.linked = [])).push({\n        doc: copy,\n        sharedHist: options.sharedHist\n      });\n      copy.linked = [{\n        doc: this,\n        isParent: true,\n        sharedHist: options.sharedHist\n      }];\n      return copy;\n    },\n    unlinkDoc: function unlinkDoc(other) {\n      if (other instanceof CodeMirror) other = other.doc;\n      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\n        var link = this.linked[i];\n        if (link.doc != other) continue;\n        this.linked.splice(i, 1);\n        other.unlinkDoc(this);\n        break;\n      } // If the histories were shared, split them again\n\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function (doc) {\n          splitIds.push(doc.id);\n        }, true);\n        other.history = makeHistory();\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function iterLinkedDocs(f) {\n      linkedDocs(this, f);\n    },\n    getMode: function getMode() {\n      return this.mode;\n    },\n    getEditor: function getEditor() {\n      return this.cm;\n    }\n  });\n  Doc.prototype.eachLine = Doc.prototype.iter; // The Doc methods that should be available on CodeMirror instances\n\n  var dontDelegate = \"iter insert remove copy getEditor\".split(\" \");\n\n  for (var prop in Doc.prototype) {\n    if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) CodeMirror.prototype[prop] = function (method) {\n      return function () {\n        return method.apply(this.doc, arguments);\n      };\n    }(Doc.prototype[prop]);\n  }\n\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) continue;\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) continue;\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      }\n    }\n\n    propagate(doc, null, true);\n  }\n\n  function attachDoc(cm, doc) {\n    if (doc.cm) throw new Error(\"This document is already in use.\");\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    if (!cm.options.lineWrapping) computeMaxLength(cm);\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  } // LINE UTILITIES\n\n\n  function getLine(chunk, n) {\n    n -= chunk.first;\n\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i],\n            sz = child.chunkSize();\n\n        if (n < sz) {\n          chunk = child;\n          break;\n        }\n\n        n -= sz;\n      }\n    }\n\n    return chunk.lines[n];\n  }\n\n  function getBetween(doc, start, end) {\n    var out = [],\n        n = start.line;\n    doc.iter(start.line, end.line + 1, function (line) {\n      var text = line.text;\n      if (n == end.line) text = text.slice(0, end.ch);\n      if (n == start.line) text = text.slice(start.ch);\n      out.push(text);\n      ++n;\n    });\n    return out;\n  }\n\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function (line) {\n      out.push(line.text);\n    });\n    return out;\n  }\n\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n\n    for (var n = line; n; n = n.parent) {\n      n.height += diff;\n    }\n  }\n\n  function lineNo(line) {\n    if (line.parent == null) return null;\n    var cur = line.parent,\n        no = indexOf(cur.lines, line);\n\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) break;\n        no += chunk.children[i].chunkSize();\n      }\n    }\n\n    return no + cur.first;\n  }\n\n  function _lineAtHeight(chunk, h) {\n    var n = chunk.first;\n\n    outer: do {\n      for (var i = 0, e = chunk.children.length; i < e; ++i) {\n        var child = chunk.children[i],\n            ch = child.height;\n\n        if (h < ch) {\n          chunk = child;\n          continue outer;\n        }\n\n        h -= ch;\n        n += child.chunkSize();\n      }\n\n      return n;\n    } while (!chunk.lines);\n\n    for (var i = 0, e = chunk.lines.length; i < e; ++i) {\n      var line = chunk.lines[i],\n          lh = line.height;\n      if (h < lh) break;\n      h -= lh;\n    }\n\n    return n + i;\n  }\n\n  function heightAtLine(cm, lineObj) {\n    lineObj = visualLine(cm.doc, lineObj);\n    var h = 0,\n        chunk = lineObj.parent;\n\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) break;else h += line.height;\n    }\n\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i = 0; i < p.children.length; ++i) {\n        var cur = p.children[i];\n        if (cur == chunk) break;else h += cur.height;\n      }\n    }\n\n    return h;\n  }\n\n  function getOrder(line) {\n    var order = line.order;\n    if (order == null) order = line.order = bidiOrdering(line.text);\n    return order;\n  } // HISTORY\n\n\n  function makeHistory(startGen) {\n    return {\n      // Arrays of history events. Doing something adds an event to\n      // done and clears undo. Undoing moves events from done to\n      // undone, redoing moves them in the other direction.\n      done: [],\n      undone: [],\n      undoDepth: Infinity,\n      // Used to track when changes can be merged into a single undo\n      // event\n      lastTime: 0,\n      lastOp: null,\n      lastOrigin: null,\n      // Used by the isClean() method\n      generation: startGen || 1,\n      maxGeneration: startGen || 1\n    };\n  }\n\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id],\n        n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n      if (line.markedSpans) (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans;\n      ++n;\n    });\n  }\n\n  function historyChangeFromChange(doc, change) {\n    var histChange = {\n      from: change.from,\n      to: changeEnd(change),\n      text: getBetween(doc, change.from, change.to)\n    };\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function (doc) {\n      attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    }, true);\n    return histChange;\n  }\n\n  function addToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date(),\n        cur = lst(hist.done);\n\n    if (cur && (hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == \"+\" && doc.cm && hist.lastTime > time - doc.cm.options.historyEventDelay || change.origin.charAt(0) == \"*\"))) {\n      // Merge this change into the last event\n      var last = lst(cur.changes);\n\n      if (posEq(change.from, change.to) && posEq(change.from, last.to)) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n\n      cur.anchorAfter = selAfter.anchor;\n      cur.headAfter = selAfter.head;\n    } else {\n      // Can not be merged, start a new event.\n      cur = {\n        changes: [historyChangeFromChange(doc, change)],\n        generation: hist.generation,\n        anchorBefore: doc.sel.anchor,\n        headBefore: doc.sel.head,\n        anchorAfter: selAfter.anchor,\n        headAfter: selAfter.head\n      };\n      hist.done.push(cur);\n      hist.generation = ++hist.maxGeneration;\n\n      while (hist.done.length > hist.undoDepth) {\n        hist.done.shift();\n      }\n    }\n\n    hist.lastTime = time;\n    hist.lastOp = opId;\n    hist.lastOrigin = change.origin;\n  }\n\n  function removeClearedSpans(spans) {\n    if (!spans) return null;\n\n    for (var i = 0, out; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) {\n        if (!out) out = spans.slice(0, i);\n      } else if (out) out.push(spans[i]);\n    }\n\n    return !out ? spans : out.length ? out : null;\n  }\n\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n    if (!found) return null;\n\n    for (var i = 0, nw = []; i < change.text.length; ++i) {\n      nw.push(removeClearedSpans(found[i]));\n    }\n\n    return nw;\n  } // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n\n\n  function copyHistoryArray(events, newGroup) {\n    for (var i = 0, copy = []; i < events.length; ++i) {\n      var event = events[i],\n          changes = event.changes,\n          newChanges = [];\n      copy.push({\n        changes: newChanges,\n        anchorBefore: event.anchorBefore,\n        headBefore: event.headBefore,\n        anchorAfter: event.anchorAfter,\n        headAfter: event.headAfter\n      });\n\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j],\n            m;\n        newChanges.push({\n          from: change.from,\n          to: change.to,\n          text: change.text\n        });\n        if (newGroup) for (var prop in change) {\n          if (m = prop.match(/^spans_(\\d+)$/)) {\n            if (indexOf(newGroup, Number(m[1])) > -1) {\n              lst(newChanges)[prop] = change[prop];\n              delete change[prop];\n            }\n          }\n        }\n      }\n    }\n\n    return copy;\n  } // Rebasing/resetting history to deal with externally-sourced changes\n\n\n  function rebaseHistSel(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  } // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n\n\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i],\n          ok = true;\n\n      for (var j = 0; j < sub.changes.length; ++j) {\n        var cur = sub.changes[j];\n\n        if (!sub.copied) {\n          cur.from = copyPos(cur.from);\n          cur.to = copyPos(cur.to);\n        }\n\n        if (to < cur.from.line) {\n          cur.from.line += diff;\n          cur.to.line += diff;\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break;\n        }\n      }\n\n      if (!sub.copied) {\n        sub.anchorBefore = copyPos(sub.anchorBefore);\n        sub.headBefore = copyPos(sub.headBefore);\n        sub.anchorAfter = copyPos(sub.anchorAfter);\n        sub.readAfter = copyPos(sub.headAfter);\n        sub.copied = true;\n      }\n\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      } else {\n        rebaseHistSel(sub.anchorBefore);\n        rebaseHistSel(sub.headBefore);\n        rebaseHistSel(sub.anchorAfter);\n        rebaseHistSel(sub.headAfter);\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line,\n        to = change.to.line,\n        diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  } // EVENT OPERATORS\n\n\n  function stopMethod() {\n    e_stop(this);\n  } // Ensure an event has a stop method.\n\n\n  function addStop(event) {\n    if (!event.stop) event.stop = stopMethod;\n    return event;\n  }\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n  }\n\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) e.stopPropagation();else e.cancelBubble = true;\n  }\n\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n  }\n\n  function e_stop(e) {\n    e_preventDefault(e);\n    e_stopPropagation(e);\n  }\n\n  CodeMirror.e_stop = e_stop;\n  CodeMirror.e_preventDefault = e_preventDefault;\n  CodeMirror.e_stopPropagation = e_stopPropagation;\n\n  function e_target(e) {\n    return e.target || e.srcElement;\n  }\n\n  function e_button(e) {\n    var b = e.which;\n\n    if (b == null) {\n      if (e.button & 1) b = 1;else if (e.button & 2) b = 3;else if (e.button & 4) b = 2;\n    }\n\n    if (mac && e.ctrlKey && b == 1) b = 3;\n    return b;\n  } // EVENT HANDLING\n\n\n  function _on(emitter, type, f) {\n    if (emitter.addEventListener) emitter.addEventListener(type, f, false);else if (emitter.attachEvent) emitter.attachEvent(\"on\" + type, f);else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      var arr = map[type] || (map[type] = []);\n      arr.push(f);\n    }\n  }\n\n  function _off(emitter, type, f) {\n    if (emitter.removeEventListener) emitter.removeEventListener(type, f, false);else if (emitter.detachEvent) emitter.detachEvent(\"on\" + type, f);else {\n      var arr = emitter._handlers && emitter._handlers[type];\n      if (!arr) return;\n\n      for (var i = 0; i < arr.length; ++i) {\n        if (arr[i] == f) {\n          arr.splice(i, 1);\n          break;\n        }\n      }\n    }\n  }\n\n  function signal(emitter, type\n  /*, values...*/\n  ) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    if (!arr) return;\n    var args = Array.prototype.slice.call(arguments, 2);\n\n    for (var i = 0; i < arr.length; ++i) {\n      arr[i].apply(null, args);\n    }\n  }\n\n  var delayedCallbacks,\n      delayedCallbackDepth = 0;\n\n  function signalLater(emitter, type\n  /*, values...*/\n  ) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    if (!arr) return;\n    var args = Array.prototype.slice.call(arguments, 2);\n\n    if (!delayedCallbacks) {\n      ++delayedCallbackDepth;\n      delayedCallbacks = [];\n      setTimeout(fireDelayed, 0);\n    }\n\n    function bnd(f) {\n      return function () {\n        f.apply(null, args);\n      };\n    }\n\n    ;\n\n    for (var i = 0; i < arr.length; ++i) {\n      delayedCallbacks.push(bnd(arr[i]));\n    }\n  }\n\n  function signalDOMEvent(cm, e) {\n    signal(cm, e.type, cm, e);\n    return e_defaultPrevented(e);\n  }\n\n  function fireDelayed() {\n    --delayedCallbackDepth;\n    var delayed = delayedCallbacks;\n    delayedCallbacks = null;\n\n    for (var i = 0; i < delayed.length; ++i) {\n      delayed[i]();\n    }\n  }\n\n  function hasHandler(emitter, type) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    return arr && arr.length > 0;\n  }\n\n  CodeMirror.on = _on;\n  CodeMirror.off = _off;\n  CodeMirror.signal = signal; // MISC UTILITIES\n  // Number of pixels added to scroller and sizer to hide scrollbar\n\n  var scrollerCutOff = 30; // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n\n  var Pass = CodeMirror.Pass = {\n    toString: function toString() {\n      return \"CodeMirror.Pass\";\n    }\n  };\n\n  function Delayed() {\n    this.id = null;\n  }\n\n  Delayed.prototype = {\n    set: function set(ms, f) {\n      clearTimeout(this.id);\n      this.id = setTimeout(f, ms);\n    }\n  }; // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n\n  function countColumn(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) end = string.length;\n    }\n\n    for (var i = startIndex || 0, n = startValue || 0; i < end; ++i) {\n      if (string.charAt(i) == \"\\t\") n += tabSize - n % tabSize;else ++n;\n    }\n\n    return n;\n  }\n\n  CodeMirror.countColumn = countColumn;\n  var spaceStrs = [\"\"];\n\n  function spaceStr(n) {\n    while (spaceStrs.length <= n) {\n      spaceStrs.push(lst(spaceStrs) + \" \");\n    }\n\n    return spaceStrs[n];\n  }\n\n  function lst(arr) {\n    return arr[arr.length - 1];\n  }\n\n  function selectInput(node) {\n    if (ios) {\n      // Mobile Safari apparently has a bug where select() is broken.\n      node.selectionStart = 0;\n      node.selectionEnd = node.value.length;\n    } else {\n      // Suppress mysterious IE10 errors\n      try {\n        node.select();\n      } catch (_e) {}\n    }\n  }\n\n  function indexOf(collection, elt) {\n    if (collection.indexOf) return collection.indexOf(elt);\n\n    for (var i = 0, e = collection.length; i < e; ++i) {\n      if (collection[i] == elt) return i;\n    }\n\n    return -1;\n  }\n\n  function createObj(base, props) {\n    function Obj() {}\n\n    Obj.prototype = base;\n    var inst = new Obj();\n    if (props) copyObj(props, inst);\n    return inst;\n  }\n\n  function copyObj(obj, target) {\n    if (!target) target = {};\n\n    for (var prop in obj) {\n      if (obj.hasOwnProperty(prop)) target[prop] = obj[prop];\n    }\n\n    return target;\n  }\n\n  function emptyArray(size) {\n    for (var a = [], i = 0; i < size; ++i) {\n      a.push(undefined);\n    }\n\n    return a;\n  }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function () {\n      return f.apply(null, args);\n    };\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n\n  function isWordChar(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) {\n      if (obj.hasOwnProperty(n) && obj[n]) return false;\n    }\n\n    return true;\n  }\n\n  var isExtendingChar = /[\\u0300-\\u036F\\u0483-\\u0487\\u0488-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1-\\u05C2\\u05C4-\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7-\\u06E8\\u06EA-\\u06ED\\uA66F\\uA670-\\uA672\\uA674-\\uA67D\\uA69F\\udc00-\\udfff]/; // DOM UTILITIES\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) e.className = className;\n    if (style) e.style.cssText = style;\n    if (typeof content == \"string\") setTextContent(e, content);else if (content) for (var i = 0; i < content.length; ++i) {\n      e.appendChild(content[i]);\n    }\n    return e;\n  }\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count) {\n      e.removeChild(e.firstChild);\n    }\n\n    return e;\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e);\n  }\n\n  function setTextContent(e, str) {\n    if (ie_lt9) {\n      e.innerHTML = \"\";\n      e.appendChild(document.createTextNode(str));\n    } else e.textContent = str;\n  }\n\n  function getRect(node) {\n    return node.getBoundingClientRect();\n  }\n\n  CodeMirror.replaceGetRect = function (f) {\n    getRect = f;\n  }; // FEATURE DETECTION\n  // Detect drag-and-drop\n\n\n  var dragAndDrop = function () {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie_lt9) return false;\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div;\n  }(); // For a reason I have yet to figure out, some browsers disallow\n  // word wrapping between certain characters *only* if a new inline\n  // element is started between them. This makes it hard to reliably\n  // measure the position of things, since that requires inserting an\n  // extra span. This terribly fragile set of tests matches the\n  // character combinations that suffer from this phenomenon on the\n  // various browsers.\n\n\n  function spanAffectsWrapping() {\n    return false;\n  }\n\n  if (gecko) // Only for \"$'\"\n    spanAffectsWrapping = function spanAffectsWrapping(str, i) {\n      return str.charCodeAt(i - 1) == 36 && str.charCodeAt(i) == 39;\n    };else if (safari && !/Version\\/([6-9]|\\d\\d)\\b/.test(navigator.userAgent)) spanAffectsWrapping = function spanAffectsWrapping(str, i) {\n    return /\\-[^ \\-?]|\\?[^ !\\'\\\"\\),.\\-\\/:;\\?\\]\\}]/.test(str.slice(i - 1, i + 1));\n  };else if (webkit) spanAffectsWrapping = function spanAffectsWrapping(str, i) {\n    if (i > 1 && str.charCodeAt(i - 1) == 45 && /\\w/.test(str.charAt(i - 2)) && /[^\\-?\\.]/.test(str.charAt(i))) return true;\n    return /[~!#%&*)=+}\\]|\\\"\\.>,:;][({[<]|-[^\\-?\\.\\u2010-\\u201f\\u2026]|\\?[\\w~`@#$%\\^&*(_=+{[|><]|…[\\w~`@#$%\\^&*(_=+{[><]/.test(str.slice(i - 1, i + 1));\n  };\n  var knownScrollbarWidth;\n\n  function scrollbarWidth(measure) {\n    if (knownScrollbarWidth != null) return knownScrollbarWidth;\n    var test = elt(\"div\", null, null, \"width: 50px; height: 50px; overflow-x: scroll\");\n    removeChildrenAndAdd(measure, test);\n    if (test.offsetWidth) knownScrollbarWidth = test.offsetHeight - test.clientHeight;\n    return knownScrollbarWidth || 0;\n  }\n\n  var zwspSupported;\n\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200B\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n      if (measure.firstChild.offsetHeight != 0) zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_lt8;\n    }\n\n    if (zwspSupported) return elt(\"span\", \"\\u200B\");else return elt(\"span\", \"\\xA0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n  } // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n\n\n  var splitLines = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\n    var pos = 0,\n        result = [],\n        l = string.length;\n\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) nl = string.length;\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n\n    return result;\n  } : function (string) {\n    return string.split(/\\r\\n?|\\n/);\n  };\n  CodeMirror.splitLines = splitLines;\n  var hasSelection = window.getSelection ? function (te) {\n    try {\n      return te.selectionStart != te.selectionEnd;\n    } catch (e) {\n      return false;\n    }\n  } : function (te) {\n    try {\n      var range = te.ownerDocument.selection.createRange();\n    } catch (e) {}\n\n    if (!range || range.parentElement() != te) return false;\n    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n  };\n\n  var hasCopyEvent = function () {\n    var e = elt(\"div\");\n    if (\"oncopy\" in e) return true;\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == 'function';\n  }(); // KEY NAMING\n\n\n  var keyNames = {\n    3: \"Enter\",\n    8: \"Backspace\",\n    9: \"Tab\",\n    13: \"Enter\",\n    16: \"Shift\",\n    17: \"Ctrl\",\n    18: \"Alt\",\n    19: \"Pause\",\n    20: \"CapsLock\",\n    27: \"Esc\",\n    32: \"Space\",\n    33: \"PageUp\",\n    34: \"PageDown\",\n    35: \"End\",\n    36: \"Home\",\n    37: \"Left\",\n    38: \"Up\",\n    39: \"Right\",\n    40: \"Down\",\n    44: \"PrintScrn\",\n    45: \"Insert\",\n    46: \"Delete\",\n    59: \";\",\n    91: \"Mod\",\n    92: \"Mod\",\n    93: \"Mod\",\n    109: \"-\",\n    107: \"=\",\n    127: \"Delete\",\n    186: \";\",\n    187: \"=\",\n    188: \",\",\n    189: \"-\",\n    190: \".\",\n    191: \"/\",\n    192: \"`\",\n    219: \"[\",\n    220: \"\\\\\",\n    221: \"]\",\n    222: \"'\",\n    63276: \"PageUp\",\n    63277: \"PageDown\",\n    63275: \"End\",\n    63273: \"Home\",\n    63234: \"Left\",\n    63232: \"Up\",\n    63235: \"Right\",\n    63233: \"Down\",\n    63302: \"Insert\",\n    63272: \"Delete\"\n  };\n  CodeMirror.keyNames = keyNames;\n\n  (function () {\n    // Number keys\n    for (var i = 0; i < 10; i++) {\n      keyNames[i + 48] = String(i);\n    } // Alphabetic keys\n\n\n    for (var i = 65; i <= 90; i++) {\n      keyNames[i] = String.fromCharCode(i);\n    } // Function keys\n\n\n    for (var i = 1; i <= 12; i++) {\n      keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i;\n    }\n  })(); // BIDI HELPERS\n\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) return f(from, to, \"ltr\");\n\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\n    }\n  }\n\n  function bidiLeft(part) {\n    return part.level % 2 ? part.to : part.from;\n  }\n\n  function bidiRight(part) {\n    return part.level % 2 ? part.from : part.to;\n  }\n\n  function lineLeft(line) {\n    var order = getOrder(line);\n    return order ? bidiLeft(order[0]) : 0;\n  }\n\n  function lineRight(line) {\n    var order = getOrder(line);\n    if (!order) return line.text.length;\n    return bidiRight(lst(order));\n  }\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(cm.doc, line);\n    if (visual != line) lineN = lineNo(visual);\n    var order = getOrder(visual);\n    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\n    return Pos(lineN, ch);\n  }\n\n  function lineEnd(cm, lineN) {\n    var merged, line;\n\n    while (merged = collapsedSpanAtEnd(line = getLine(cm.doc, lineN))) {\n      lineN = merged.find().to.line;\n    }\n\n    var order = getOrder(line);\n    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\n    return Pos(lineN, ch);\n  }\n\n  function compareBidiLevel(order, a, b) {\n    var linedir = order[0].level;\n    if (a == linedir) return true;\n    if (b == linedir) return false;\n    return a < b;\n  }\n\n  var bidiOther;\n\n  function getBidiPartAt(order, pos) {\n    for (var i = 0, found; i < order.length; ++i) {\n      var cur = order[i];\n\n      if (cur.from < pos && cur.to > pos) {\n        bidiOther = null;\n        return i;\n      }\n\n      if (cur.from == pos || cur.to == pos) {\n        if (found == null) {\n          found = i;\n        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\n          bidiOther = found;\n          return i;\n        } else {\n          bidiOther = i;\n          return found;\n        }\n      }\n    }\n\n    bidiOther = null;\n    return found;\n  }\n\n  function moveInLine(line, pos, dir, byUnit) {\n    if (!byUnit) return pos + dir;\n\n    do {\n      pos += dir;\n    } while (pos > 0 && isExtendingChar.test(line.text.charAt(pos)));\n\n    return pos;\n  } // This is somewhat involved. It is needed in order to move\n  // 'visually' through bi-directional text -- i.e., pressing left\n  // should make the cursor go left, even when in RTL text. The\n  // tricky part is the 'jumps', where RTL and LTR text touch each\n  // other. This often requires the cursor offset to move more than\n  // one unit, in order to visually move one unit.\n\n\n  function moveVisually(line, start, dir, byUnit) {\n    var bidi = getOrder(line);\n    if (!bidi) return moveLogically(line, start, dir, byUnit);\n    var pos = getBidiPartAt(bidi, start),\n        part = bidi[pos];\n    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\n\n    for (;;) {\n      if (target > part.from && target < part.to) return target;\n\n      if (target == part.from || target == part.to) {\n        if (getBidiPartAt(bidi, target) == pos) return target;\n        part = bidi[pos += dir];\n        return dir > 0 == part.level % 2 ? part.to : part.from;\n      } else {\n        part = bidi[pos += dir];\n        if (!part) return null;\n        if (dir > 0 == part.level % 2) target = moveInLine(line, part.to, -1, byUnit);else target = moveInLine(line, part.from, 1, byUnit);\n      }\n    }\n  }\n\n  function moveLogically(line, start, dir, byUnit) {\n    var target = start + dir;\n    if (byUnit) while (target > 0 && isExtendingChar.test(line.text.charAt(target))) {\n      target += dir;\n    }\n    return target < 0 || target > line.text.length ? null : target;\n  } // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n\n\n  var bidiOrdering = function () {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL\"; // Character types for codepoints 0x600 to 0x6ff\n\n    var arabicTypes = \"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr\";\n\n    function charType(code) {\n      if (code <= 0xff) return lowTypes.charAt(code);else if (0x590 <= code && code <= 0x5f4) return \"R\";else if (0x600 <= code && code <= 0x6ff) return arabicTypes.charAt(code - 0x600);else if (0x700 <= code && code <= 0x8ac) return \"r\";else return \"L\";\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/,\n        isStrong = /[LRr]/,\n        countsAsLeft = /[Lb1n]/,\n        countsAsNum = /[1n]/; // Browsers seem to always treat the boundaries of block elements as being L.\n\n    var outerType = \"L\";\n    return function (str) {\n      if (!bidiRE.test(str)) return false;\n      var len = str.length,\n          types = [];\n\n      for (var i = 0, type; i < len; ++i) {\n        types.push(type = charType(str.charCodeAt(i)));\n      } // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n\n\n      for (var i = 0, prev = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"m\") types[i] = prev;else prev = type;\n      } // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n\n\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"1\" && cur == \"r\") types[i] = \"n\";else if (isStrong.test(type)) {\n          cur = type;\n          if (type == \"r\") types[i] = \"R\";\n        }\n      } // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n\n\n      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\n        var type = types[i];\n        if (type == \"+\" && prev == \"1\" && types[i + 1] == \"1\") types[i] = \"1\";else if (type == \",\" && prev == types[i + 1] && (prev == \"1\" || prev == \"n\")) types[i] = prev;\n        prev = type;\n      } // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n\n\n      for (var i = 0; i < len; ++i) {\n        var type = types[i];\n        if (type == \",\") types[i] = \"N\";else if (type == \"%\") {\n          for (var end = i + 1; end < len && types[end] == \"%\"; ++end) {}\n\n          var replace = i && types[i - 1] == \"!\" || end < len - 1 && types[end] == \"1\" ? \"1\" : \"N\";\n\n          for (var j = i; j < end; ++j) {\n            types[j] = replace;\n          }\n\n          i = end - 1;\n        }\n      } // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n\n\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (cur == \"L\" && type == \"1\") types[i] = \"L\";else if (isStrong.test(type)) cur = type;\n      } // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n\n\n      for (var i = 0; i < len; ++i) {\n        if (isNeutral.test(types[i])) {\n          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\n\n          var before = (i ? types[i - 1] : outerType) == \"L\";\n          var after = (end < len - 1 ? types[end] : outerType) == \"L\";\n          var replace = before || after ? \"L\" : \"R\";\n\n          for (var j = i; j < end; ++j) {\n            types[j] = replace;\n          }\n\n          i = end - 1;\n        }\n      } // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n\n\n      var order = [],\n          m;\n\n      for (var i = 0; i < len;) {\n        if (countsAsLeft.test(types[i])) {\n          var start = i;\n\n          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\n\n          order.push({\n            from: start,\n            to: i,\n            level: 0\n          });\n        } else {\n          var pos = i,\n              at = order.length;\n\n          for (++i; i < len && types[i] != \"L\"; ++i) {}\n\n          for (var j = pos; j < i;) {\n            if (countsAsNum.test(types[j])) {\n              if (pos < j) order.splice(at, 0, {\n                from: pos,\n                to: j,\n                level: 1\n              });\n              var nstart = j;\n\n              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\n\n              order.splice(at, 0, {\n                from: nstart,\n                to: j,\n                level: 2\n              });\n              pos = j;\n            } else ++j;\n          }\n\n          if (pos < i) order.splice(at, 0, {\n            from: pos,\n            to: i,\n            level: 1\n          });\n        }\n      }\n\n      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n        order[0].from = m[0].length;\n        order.unshift({\n          from: 0,\n          to: m[0].length,\n          level: 0\n        });\n      }\n\n      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n        lst(order).to -= m[0].length;\n        order.push({\n          from: len - m[0].length,\n          to: len,\n          level: 0\n        });\n      }\n\n      if (order[0].level != lst(order).level) order.push({\n        from: len,\n        to: len,\n        level: order[0].level\n      });\n      return order;\n    };\n  }(); // THE END\n\n\n  CodeMirror.version = \"3.14.0\";\n  return CodeMirror;\n}();\n\n//# sourceURL=webpack:///./lib/codemirror/lib/codemirror.js?");

/***/ }),

/***/ "./lib/codemirror/mode/javascript/javascript.js":
/*!******************************************************!*\
  !*** ./lib/codemirror/mode/javascript/javascript.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// TODO actually recognize syntax of TypeScript constructs\nCodeMirror.defineMode(\"javascript\", function (config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonMode = parserConfig.json;\n  var isTS = parserConfig.typescript; // Tokenizer\n\n  var keywords = function () {\n    function kw(type) {\n      return {\n        type: type,\n        style: \"keyword\"\n      };\n    }\n\n    var A = kw(\"keyword a\"),\n        B = kw(\"keyword b\"),\n        C = kw(\"keyword c\");\n    var operator = kw(\"operator\"),\n        atom = {\n      type: \"atom\",\n      style: \"atom\"\n    };\n    var jsKeywords = {\n      \"if\": kw(\"if\"),\n      \"while\": A,\n      \"with\": A,\n      \"else\": B,\n      \"do\": B,\n      \"try\": B,\n      \"finally\": B,\n      \"return\": C,\n      \"break\": C,\n      \"continue\": C,\n      \"new\": C,\n      \"delete\": C,\n      \"throw\": C,\n      \"var\": kw(\"var\"),\n      \"const\": kw(\"var\"),\n      \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"),\n      \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"),\n      \"switch\": kw(\"switch\"),\n      \"case\": kw(\"case\"),\n      \"default\": kw(\"default\"),\n      \"in\": operator,\n      \"typeof\": operator,\n      \"instanceof\": operator,\n      \"true\": atom,\n      \"false\": atom,\n      \"null\": atom,\n      \"undefined\": atom,\n      \"NaN\": atom,\n      \"Infinity\": atom,\n      \"this\": kw(\"this\")\n    }; // Extend the 'normal' keywords with the TypeScript language extensions\n\n    if (isTS) {\n      var type = {\n        type: \"variable\",\n        style: \"variable-3\"\n      };\n      var tsKeywords = {\n        // object-like things\n        \"interface\": kw(\"interface\"),\n        \"class\": kw(\"class\"),\n        \"extends\": kw(\"extends\"),\n        \"constructor\": kw(\"constructor\"),\n        // scope modifiers\n        \"public\": kw(\"public\"),\n        \"private\": kw(\"private\"),\n        \"protected\": kw(\"protected\"),\n        \"static\": kw(\"static\"),\n        \"super\": kw(\"super\"),\n        // types\n        \"string\": type,\n        \"number\": type,\n        \"bool\": type,\n        \"any\": type\n      };\n\n      for (var attr in tsKeywords) {\n        jsKeywords[attr] = tsKeywords[attr];\n      }\n    }\n\n    return jsKeywords;\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^]/;\n\n  function chain(stream, state, f) {\n    state.tokenize = f;\n    return f(stream, state);\n  }\n\n  function nextUntilUnescaped(stream, end) {\n    var escaped = false,\n        next;\n\n    while ((next = stream.next()) != null) {\n      if (next == end && !escaped) return false;\n      escaped = !escaped && next == \"\\\\\";\n    }\n\n    return escaped;\n  } // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n\n\n  var type, content;\n\n  function ret(tp, style, cont) {\n    type = tp;\n    content = cont;\n    return style;\n  }\n\n  function jsTokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") return chain(stream, state, jsTokenString(ch));else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) return ret(ch);else if (ch == \"0\" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        return chain(stream, state, jsTokenComment);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (state.lastType == \"operator\" || state.lastType == \"keyword c\" || /^[\\[{}\\(,;:]$/.test(state.lastType)) {\n        nextUntilUnescaped(stream, \"/\");\n        stream.eatWhile(/[gimy]/); // 'y' is \"sticky\" option in Mozilla\n\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eatWhile(isOperatorChar);\n        return ret(\"operator\", null, stream.current());\n      }\n    } else if (ch == \"#\") {\n      stream.skipToEnd();\n      return ret(\"error\", \"error\");\n    } else if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", null, stream.current());\n    } else {\n      stream.eatWhile(/[\\w\\$_]/);\n      var word = stream.current(),\n          known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return known && state.lastType != \".\" ? ret(known.type, known.style, word) : ret(\"variable\", \"variable\", word);\n    }\n  }\n\n  function jsTokenString(quote) {\n    return function (stream, state) {\n      if (!nextUntilUnescaped(stream, quote)) state.tokenize = jsTokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function jsTokenComment(stream, state) {\n    var maybeEnd = false,\n        ch;\n\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = jsTokenBase;\n        break;\n      }\n\n      maybeEnd = ch == \"*\";\n    }\n\n    return ret(\"comment\", \"comment\");\n  } // Parser\n\n\n  var atomicTypes = {\n    \"atom\": true,\n    \"number\": true,\n    \"variable\": true,\n    \"string\": true,\n    \"regexp\": true,\n    \"this\": true\n  };\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next) {\n      if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc; // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n\n    cx.state = state;\n    cx.stream = stream;\n    cx.marked = null, cx.cc = cc;\n    if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = true;\n\n    while (true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n\n      if (combinator(type, content)) {\n        while (cc.length && cc[cc.length - 1].lex) {\n          cc.pop()();\n        }\n\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  } // Combinator utils\n\n\n  var cx = {\n    state: null,\n    column: null,\n    marked: null,\n    cc: null\n  };\n\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) {\n      cx.cc.push(arguments[i]);\n    }\n  }\n\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n\n  function register(varname) {\n    function inList(list) {\n      for (var v = list; v; v = v.next) {\n        if (v.name == varname) return true;\n      }\n\n      return false;\n    }\n\n    var state = cx.state;\n\n    if (state.context) {\n      cx.marked = \"def\";\n      if (inList(state.localVars)) return;\n      state.localVars = {\n        name: varname,\n        next: state.localVars\n      };\n    } else {\n      if (inList(state.globalVars)) return;\n      state.globalVars = {\n        name: varname,\n        next: state.globalVars\n      };\n    }\n  } // Combinators\n\n\n  var defaultVars = {\n    name: \"this\",\n    next: {\n      name: \"arguments\"\n    }\n  };\n\n  function pushcontext() {\n    cx.state.context = {\n      prev: cx.state.context,\n      vars: cx.state.localVars\n    };\n    cx.state.localVars = defaultVars;\n  }\n\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n\n  function pushlex(type, info) {\n    var result = function result() {\n      var state = cx.state,\n          indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n\n    result.lex = true;\n    return result;\n  }\n\n  function poplex() {\n    var state = cx.state;\n\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\") state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n\n  poplex.lex = true;\n\n  function expect(wanted) {\n    return function (type) {\n      if (type == wanted) return cont();else if (wanted == \";\") return pass();else return cont(arguments.callee);\n    };\n  }\n\n  function statement(type) {\n    if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"{\") return cont(pushlex(\"}\"), block, poplex);\n    if (type == \";\") return cont();\n    if (type == \"if\") return cont(pushlex(\"form\"), expression, statement, poplex, maybeelse(cx.state.indented));\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"), poplex, statement, poplex);\n    if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n    if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"), block, poplex, poplex);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"), statement, poplex, popcontext);\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n\n  function expression(type) {\n    return expressionInner(type, false);\n  }\n\n  function expressionNoComma(type) {\n    return expressionInner(type, true);\n  }\n\n  function expressionInner(type, noComma) {\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"keyword c\") return cont(noComma ? maybeexpressionNoComma : maybeexpression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(expressionNoComma, \"]\"), poplex, maybeop);\n    if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeop);\n    return cont();\n  }\n\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeexpressionNoComma(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expressionNoComma);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(expression);\n    return maybeoperatorNoComma(type, value, maybeoperatorComma);\n  }\n\n  function maybeoperatorNoComma(type, value, me) {\n    if (!me) me = maybeoperatorNoComma;\n\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value)) return cont(me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expression);\n      return cont(expression);\n    }\n\n    if (type == \";\") return;\n    if (type == \"(\") return cont(pushlex(\")\", \"call\"), commasep(expressionNoComma, \")\"), poplex, me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, me);\n  }\n\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n\n  function property(type) {\n    if (type == \"variable\") {\n      cx.marked = \"property\";\n      return cont();\n    }\n  }\n\n  function objprop(type, value) {\n    if (type == \"variable\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = type + \" property\";\n    }\n\n    if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expressionNoComma);\n  }\n\n  function getterSetter(type) {\n    if (type == \":\") return cont(expression);\n    if (type != \"variable\") return cont(expect(\":\"), expression);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n\n  function commasep(what, end) {\n    function proceed(type) {\n      if (type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(what, proceed);\n      }\n\n      if (type == end) return cont();\n      return cont(expect(end));\n    }\n\n    return function (type) {\n      if (type == end) return cont();else return pass(what, proceed);\n    };\n  }\n\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n\n  function maybetype(type) {\n    if (type == \":\") return cont(typedef);\n    return pass();\n  }\n\n  function typedef(type) {\n    if (type == \"variable\") {\n      cx.marked = \"variable-3\";\n      return cont();\n    }\n\n    return pass();\n  }\n\n  function vardef1(type, value) {\n    if (type == \"variable\") {\n      register(value);\n      return isTS ? cont(maybetype, vardef2) : cont(vardef2);\n    }\n\n    return pass();\n  }\n\n  function vardef2(type, value) {\n    if (value == \"=\") return cont(expressionNoComma, vardef2);\n    if (type == \",\") return cont(vardef1);\n  }\n\n  function maybeelse(indent) {\n    return function (type, value) {\n      if (type == \"keyword b\" && value == \"else\") {\n        cx.state.lexical = new JSLexical(indent, 0, \"form\", null, cx.state.lexical);\n        return cont(statement, poplex);\n      }\n\n      return pass();\n    };\n  }\n\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef1, expect(\";\"), forspec2);\n    if (type == \";\") return cont(forspec2);\n    if (type == \"variable\") return cont(formaybein);\n    return pass(expression, expect(\";\"), forspec2);\n  }\n\n  function formaybein(_type, value) {\n    if (value == \"in\") return cont(expression);\n    return cont(maybeoperatorComma, forspec2);\n  }\n\n  function forspec2(type, value) {\n    if (type == \";\") return cont(forspec3);\n    if (value == \"in\") return cont(expression);\n    return pass(expression, expect(\";\"), forspec3);\n  }\n\n  function forspec3(type) {\n    if (type != \")\") cont(expression);\n  }\n\n  function functiondef(type, value) {\n    if (type == \"variable\") {\n      register(value);\n      return cont(functiondef);\n    }\n\n    if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, statement, popcontext);\n  }\n\n  function funarg(type, value) {\n    if (type == \"variable\") {\n      register(value);\n      return isTS ? cont(maybetype) : cont();\n    }\n  } // Interface\n\n\n  return {\n    startState: function startState(basecolumn) {\n      return {\n        tokenize: jsTokenBase,\n        lastType: null,\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        globalVars: parserConfig.globalVars,\n        context: parserConfig.localVars && {\n          vars: parserConfig.localVars\n        },\n        indented: 0\n      };\n    },\n    token: function token(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = false;\n        state.indented = stream.indentation();\n      }\n\n      if (state.tokenize != jsTokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n    indent: function indent(state, textAfter) {\n      if (state.tokenize == jsTokenComment) return CodeMirror.Pass;\n      if (state.tokenize != jsTokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0),\n          lexical = state.lexical;\n      if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\") lexical = lexical.prev;\n      var type = lexical.type,\n          closing = firstChar == type;\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? 4 : 0);else if (type == \"form\" && firstChar == \"{\") return lexical.indented;else if (type == \"form\") return lexical.indented + indentUnit;else if (type == \"stat\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? statementIndent || indentUnit : 0);else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false) return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);else if (lexical.align) return lexical.column + (closing ? 0 : 1);else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n    electricChars: \":{}\",\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    lineComment: jsonMode ? null : \"//\",\n    jsonMode: jsonMode\n  };\n});\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", {\n  name: \"javascript\",\n  json: true\n});\nCodeMirror.defineMIME(\"application/x-json\", {\n  name: \"javascript\",\n  json: true\n});\nCodeMirror.defineMIME(\"text/typescript\", {\n  name: \"javascript\",\n  typescript: true\n});\nCodeMirror.defineMIME(\"application/typescript\", {\n  name: \"javascript\",\n  typescript: true\n});\n\n//# sourceURL=webpack:///./lib/codemirror/mode/javascript/javascript.js?");

/***/ }),

/***/ "./lib/d3-compat.js":
/*!**************************!*\
  !*** ./lib/d3-compat.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function () {\n  // get a reference to the d3.selection prototype,\n  // and keep a reference to the old d3.selection.on\n  var d3_selectionPrototype = d3.selection.prototype,\n      d3_on = d3_selectionPrototype.on; // our shims are organized by event:\n  // \"desired-event\": [\"shimmed-event\", wrapperFunction]\n\n  var shims = {\n    \"mouseenter\": [\"mouseover\", relatedTarget],\n    \"mouseleave\": [\"mouseout\", relatedTarget]\n  }; // rewrite the d3.selection.on function to shim the events with wrapped\n  // callbacks\n\n  d3_selectionPrototype.on = function (evt, callback, useCapture) {\n    var bits = evt.split(\".\"),\n        type = bits.shift(),\n        shim = shims[type];\n\n    if (shim) {\n      evt = bits.length ? [shim[0], bits].join(\".\") : shim[0];\n\n      if (typeof callback === \"function\") {\n        callback = shim[1](callback);\n      }\n\n      return d3_on.call(this, evt, callback, useCapture);\n    } else {\n      return d3_on.apply(this, arguments);\n    }\n  };\n\n  function relatedTarget(callback) {\n    return function () {\n      var related = d3.event.relatedTarget;\n\n      if (this === related || childOf(this, related)) {\n        return undefined;\n      }\n\n      return callback.apply(this, arguments);\n    };\n  }\n\n  function childOf(p, c) {\n    if (p === c) return false;\n\n    while (c && c !== p) {\n      c = c.parentNode;\n    }\n\n    return c === p;\n  }\n})();\n\n//# sourceURL=webpack:///./lib/d3-compat.js?");

/***/ }),

/***/ "./lib/d3.keybinding.js":
/*!******************************!*\
  !*** ./lib/d3.keybinding.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\r\n * This code is licensed under the MIT license.\r\n *\r\n * Copyright © 2013, iD authors.\r\n *\r\n * Portions copyright © 2011, Keith Cirkel\r\n * See https://github.com/keithamus/jwerty\r\n *\r\n */\nd3.keybinding = function (namespace) {\n  var bindings = [];\n\n  function matches(binding, event) {\n    for (var p in binding.event) {\n      if (event[p] != binding.event[p]) return false;\n    }\n\n    return !binding.capture === (event.eventPhase !== Event.CAPTURING_PHASE);\n  }\n\n  function capture() {\n    for (var i = 0; i < bindings.length; i++) {\n      var binding = bindings[i];\n\n      if (matches(binding, d3.event)) {\n        binding.callback();\n      }\n    }\n  }\n\n  function bubble() {\n    var tagName = d3.select(d3.event.target).node().tagName;\n\n    if (tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'TEXTAREA') {\n      return;\n    }\n\n    capture();\n  }\n\n  function keybinding(selection) {\n    selection = selection || d3.select(document);\n    selection.on('keydown.capture' + namespace, capture, true);\n    selection.on('keydown.bubble' + namespace, bubble, false);\n    return keybinding;\n  }\n\n  keybinding.off = function (selection) {\n    selection = selection || d3.select(document);\n    selection.on('keydown.capture' + namespace, null);\n    selection.on('keydown.bubble' + namespace, null);\n    return keybinding;\n  };\n\n  keybinding.on = function (code, callback, capture) {\n    var binding = {\n      event: {\n        keyCode: 0,\n        shiftKey: false,\n        ctrlKey: false,\n        altKey: false,\n        metaKey: false\n      },\n      capture: capture,\n      callback: callback\n    };\n    code = code.toLowerCase().match(/(?:(?:[^+⇧⌃⌥⌘])+|[⇧⌃⌥⌘]|\\+\\+|^\\+$)/g);\n\n    for (var i = 0; i < code.length; i++) {\n      // Normalise matching errors\n      if (code[i] === '++') code[i] = '+';\n\n      if (code[i] in d3.keybinding.modifierCodes) {\n        binding.event[d3.keybinding.modifierProperties[d3.keybinding.modifierCodes[code[i]]]] = true;\n      } else if (code[i] in d3.keybinding.keyCodes) {\n        binding.event.keyCode = d3.keybinding.keyCodes[code[i]];\n      }\n    }\n\n    bindings.push(binding);\n    return keybinding;\n  };\n\n  return keybinding;\n};\n\n(function () {\n  d3.keybinding.modifierCodes = {\n    // Shift key, ⇧\n    '⇧': 16,\n    shift: 16,\n    // CTRL key, on Mac: ⌃\n    '⌃': 17,\n    ctrl: 17,\n    // ALT key, on Mac: ⌥ (Alt)\n    '⌥': 18,\n    alt: 18,\n    option: 18,\n    // META, on Mac: ⌘ (CMD), on Windows (Win), on Linux (Super)\n    '⌘': 91,\n    meta: 91,\n    cmd: 91,\n    'super': 91,\n    win: 91\n  };\n  d3.keybinding.modifierProperties = {\n    16: 'shiftKey',\n    17: 'ctrlKey',\n    18: 'altKey',\n    91: 'metaKey'\n  };\n  d3.keybinding.keyCodes = {\n    // Backspace key, on Mac: ⌫ (Backspace)\n    '⌫': 8,\n    backspace: 8,\n    // Tab Key, on Mac: ⇥ (Tab), on Windows ⇥⇥\n    '⇥': 9,\n    '⇆': 9,\n    tab: 9,\n    // Return key, ↩\n    '↩': 13,\n    'return': 13,\n    enter: 13,\n    '⌅': 13,\n    // Pause/Break key\n    'pause': 19,\n    'pause-break': 19,\n    // Caps Lock key, ⇪\n    '⇪': 20,\n    caps: 20,\n    'caps-lock': 20,\n    // Escape key, on Mac: ⎋, on Windows: Esc\n    '⎋': 27,\n    escape: 27,\n    esc: 27,\n    // Space key\n    space: 32,\n    // Page-Up key, or pgup, on Mac: ↖\n    '↖': 33,\n    pgup: 33,\n    'page-up': 33,\n    // Page-Down key, or pgdown, on Mac: ↘\n    '↘': 34,\n    pgdown: 34,\n    'page-down': 34,\n    // END key, on Mac: ⇟\n    '⇟': 35,\n    end: 35,\n    // HOME key, on Mac: ⇞\n    '⇞': 36,\n    home: 36,\n    // Insert key, or ins\n    ins: 45,\n    insert: 45,\n    // Delete key, on Mac: ⌦ (Delete)\n    '⌦': 46,\n    del: 46,\n    'delete': 46,\n    // Left Arrow Key, or ←\n    '←': 37,\n    left: 37,\n    'arrow-left': 37,\n    // Up Arrow Key, or ↑\n    '↑': 38,\n    up: 38,\n    'arrow-up': 38,\n    // Right Arrow Key, or →\n    '→': 39,\n    right: 39,\n    'arrow-right': 39,\n    // Up Arrow Key, or ↓\n    '↓': 40,\n    down: 40,\n    'arrow-down': 40,\n    // odities, printing characters that come out wrong:\n    // Num-Multiply, or *\n    '*': 106,\n    star: 106,\n    asterisk: 106,\n    multiply: 106,\n    // Num-Plus or +\n    '+': 107,\n    'plus': 107,\n    // Num-Subtract, or -\n    '-': 109,\n    subtract: 109,\n    // Semicolon\n    ';': 186,\n    semicolon: 186,\n    // = or equals\n    '=': 187,\n    'equals': 187,\n    // Comma, or ,\n    ',': 188,\n    comma: 188,\n    'dash': 189,\n    //???\n    // Period, or ., or full-stop\n    '.': 190,\n    period: 190,\n    'full-stop': 190,\n    // Slash, or /, or forward-slash\n    '/': 191,\n    slash: 191,\n    'forward-slash': 191,\n    // Tick, or `, or back-quote\n    '`': 192,\n    tick: 192,\n    'back-quote': 192,\n    // Open bracket, or [\n    '[': 219,\n    'open-bracket': 219,\n    // Back slash, or \\\n    '\\\\': 220,\n    'back-slash': 220,\n    // Close backet, or ]\n    ']': 221,\n    'close-bracket': 221,\n    // Apostrophe, or Quote, or '\n    '\\'': 222,\n    quote: 222,\n    apostrophe: 222\n  }; // NUMPAD 0-9\n\n  var i = 95,\n      n = 0;\n\n  while (++i < 106) {\n    d3.keybinding.keyCodes['num-' + n] = i;\n    ++n;\n  } // 0-9\n\n\n  i = 47;\n  n = 0;\n\n  while (++i < 58) {\n    d3.keybinding.keyCodes[n] = i;\n    ++n;\n  } // F1-F25\n\n\n  i = 111;\n  n = 1;\n\n  while (++i < 136) {\n    d3.keybinding.keyCodes['f' + n] = i;\n    ++n;\n  } // a-z\n\n\n  i = 64;\n\n  while (++i < 91) {\n    d3.keybinding.keyCodes[String.fromCharCode(i).toLowerCase()] = i;\n  }\n})();\n\n//# sourceURL=webpack:///./lib/d3.keybinding.js?");

/***/ }),

/***/ "./lib/d3.trigger.js":
/*!***************************!*\
  !*** ./lib/d3.trigger.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("d3.selection.prototype.trigger = function (type) {\n  this.each(function () {\n    var evt = document.createEvent('HTMLEvents');\n    evt.initEvent(type, true, true);\n    this.dispatchEvent(evt);\n  });\n};\n\n//# sourceURL=webpack:///./lib/d3.trigger.js?");

/***/ }),

/***/ "./lib/drag/leaflet.drag.js":
/*!**********************************!*\
  !*** ./lib/drag/leaflet.drag.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n  Drag feature functionality for Leaflet.draw\r\n\t(c) Alexander Milevski\r\n\r\n\thttps://github.com/w8r/Leaflet.draw.drag\r\n\thttps://github.com/w8r/\r\n*/\n\n\nif (L.Browser.svg) {\n  L.Path.include({\n    _resetTransform: function _resetTransform() {\n      this._container.setAttributeNS(null, \"transform\", \"\");\n    },\n    _applyTransform: function _applyTransform(t) {\n      this._container.setAttributeNS(null, \"transform\", \"matrix(\" + t.join(\" \") + \")\");\n    }\n  });\n} else {\n  L.Path.include({\n    _resetTransform: function _resetTransform() {\n      if (this._skew) {\n        this._skew.on = false;\n\n        this._container.removeChild(this._skew);\n\n        this._skew = null;\n      }\n    },\n    _applyTransform: function _applyTransform(t) {\n      var e = this._skew;\n\n      if (!e) {\n        e = this._createElement(\"skew\");\n\n        this._container.appendChild(e);\n\n        e.style.behavior = \"url(#default#VML)\";\n        this._skew = e;\n      }\n\n      var i = t[0].toFixed(8) + \" \" + t[1].toFixed(8) + \" \" + t[2].toFixed(8) + \" \" + t[3].toFixed(8) + \" 0 0\";\n      var r = Math.floor(t[4]).toFixed() + \", \" + Math.floor(t[5]).toFixed() + \"\";\n      var a = this._container.style;\n      var s = parseFloat(a.left);\n      var o = parseFloat(a.top);\n      var n = parseFloat(a.width);\n      var h = parseFloat(a.height);\n      if (isNaN(s)) s = 0;\n      if (isNaN(o)) o = 0;\n      if (isNaN(n) || !n) n = 1;\n      if (isNaN(h) || !h) h = 1;\n\n      var _ = (-s / n - .5).toFixed(8) + \" \" + (-o / h - .5).toFixed(8);\n\n      e.on = \"f\";\n      e.matrix = i;\n      e.origin = _;\n      e.offset = r;\n      e.on = true;\n    }\n  });\n}\n\nL.Path.include({\n  _onMouseClick: function _onMouseClick(t) {\n    if (this.dragging && this.dragging.moved() || this._map.dragging && this._map.dragging.moved()) {\n      return;\n    }\n\n    this._fireMouseEvent(t);\n  }\n});\n\"use strict\";\n\nL.Handler.PathDrag = L.Handler.extend({\n  statics: {\n    DRAGGABLE_CLS: \"leaflet-path-draggable\"\n  },\n  initialize: function initialize(t) {\n    this._path = t;\n    this._matrix = null;\n    this._startPoint = null;\n    this._dragStartPoint = null;\n    this._dragInProgress = false;\n    this._dragMoved = false;\n  },\n  addHooks: function addHooks() {\n    var t = L.Handler.PathDrag.DRAGGABLE_CLS;\n    var e = this._path._path;\n\n    this._path.on(\"mousedown\", this._onDragStart, this);\n\n    this._path.options.className = (this._path.options.className || \"\") + \" \" + t;\n\n    if (!L.Path.CANVAS && e) {\n      L.DomUtil.addClass(e, t);\n    }\n  },\n  removeHooks: function removeHooks() {\n    var t = L.Handler.PathDrag.DRAGGABLE_CLS;\n    var e = this._path._path;\n\n    this._path.off(\"mousedown\", this._onDragStart, this);\n\n    this._path.options.className = (this._path.options.className || \"\").replace(t, \"\");\n\n    if (!L.Path.CANVAS && e) {\n      L.DomUtil.removeClass(e, t);\n    }\n\n    this._dragMoved = false;\n  },\n  moved: function moved() {\n    return this._dragMoved;\n  },\n  inProgress: function inProgress() {\n    return this._dragInProgress;\n  },\n  _onDragStart: function _onDragStart(t) {\n    this._dragInProgress = true;\n    this._startPoint = t.containerPoint.clone();\n    this._dragStartPoint = t.containerPoint.clone();\n    this._matrix = [1, 0, 0, 1, 0, 0];\n\n    if (this._path._point) {\n      this._point = this._path._point.clone();\n    }\n\n    this._path._map.on(\"mousemove\", this._onDrag, this).on(\"mouseup\", this._onDragEnd, this);\n\n    this._dragMoved = false;\n  },\n  _onDrag: function _onDrag(t) {\n    var e = t.containerPoint.x;\n    var i = t.containerPoint.y;\n    var r = this._matrix;\n    var a = this._path;\n    var s = this._startPoint;\n    var o = e - s.x;\n    var n = i - s.y;\n\n    if (!this._dragMoved && (o || n)) {\n      this._dragMoved = true;\n      a.fire(\"dragstart\");\n\n      if (a._popup) {\n        a._popup._close();\n\n        a.off(\"click\", a._openPopup, a);\n      }\n    }\n\n    r[4] += o;\n    r[5] += n;\n    s.x = e;\n    s.y = i;\n\n    a._applyTransform(r);\n\n    if (a._point) {\n      a._point.x = this._point.x + r[4];\n      a._point.y = this._point.y + r[5];\n    }\n\n    a.fire(\"drag\");\n    L.DomEvent.stop(t.originalEvent);\n  },\n  _onDragEnd: function _onDragEnd(t) {\n    L.DomEvent.stop(t);\n\n    L.DomEvent._fakeStop({\n      type: \"click\"\n    });\n\n    this._dragInProgress = false;\n\n    this._path._resetTransform();\n\n    this._transformPoints(this._matrix);\n\n    this._path._map.off(\"mousemove\", this._onDrag, this).off(\"mouseup\", this._onDragEnd, this);\n\n    this._path.fire(\"dragend\", {\n      distance: Math.sqrt(L.LineUtil._sqDist(this._dragStartPoint, t.containerPoint))\n    });\n\n    if (this._path._popup) {\n      L.Util.requestAnimFrame(function () {\n        this._path.on(\"click\", this._path._openPopup, this._path);\n      }, this);\n    }\n\n    this._matrix = null;\n    this._startPoint = null;\n    this._point = null;\n    this._dragStartPoint = null;\n  },\n  _transformPoint: function _transformPoint(t, e) {\n    var i = this._path;\n    var r = L.point(e[4], e[5]);\n    var a = i._map.options.crs;\n    var s = a.transformation;\n    var o = a.scale(i._map.getZoom());\n    var n = a.projection;\n    var h = s.untransform(r, o).subtract(s.untransform(L.point(0, 0), o));\n    return n.unproject(n.project(t)._add(h));\n  },\n  _transformPoints: function _transformPoints(t) {\n    var e = this._path;\n    var i, r, a;\n    var s = L.point(t[4], t[5]);\n    var o = e._map.options.crs;\n    var n = o.transformation;\n    var h = o.scale(e._map.getZoom());\n    var _ = o.projection;\n    var g = n.untransform(s, h).subtract(n.untransform(L.point(0, 0), h));\n\n    if (e._point) {\n      e._latlng = _.unproject(_.project(e._latlng)._add(g));\n      e._point = this._point._add(s);\n    } else if (e._originalPoints) {\n      for (i = 0, r = e._originalPoints.length; i < r; i++) {\n        a = e._latlngs[i];\n        e._latlngs[i] = _.unproject(_.project(a)._add(g));\n\n        e._originalPoints[i]._add(s);\n      }\n    }\n\n    if (e._holes) {\n      for (i = 0, r = e._holes.length; i < r; i++) {\n        for (var p = 0, d = e._holes[i].length; p < d; p++) {\n          a = e._holes[i][p];\n          e._holes[i][p] = _.unproject(_.project(a)._add(g));\n\n          e._holePoints[i][p]._add(s);\n        }\n      }\n    }\n\n    e._updatePath();\n  }\n});\nL.Path.addInitHook(function () {\n  if (this.options.draggable) {\n    if (this.dragging) {\n      this.dragging.enable();\n    } else {\n      this.dragging = new L.Handler.PathDrag(this);\n      this.dragging.enable();\n    }\n  } else if (this.dragging) {\n    this.dragging.disable();\n  }\n});\nL.Circle.prototype._getLatLng = L.Circle.prototype.getLatLng;\n\nL.Circle.prototype.getLatLng = function () {\n  if (this.dragging && this.dragging.inProgress()) {\n    return this.dragging._transformPoint(this._latlng, this.dragging._matrix);\n  } else {\n    return this._getLatLng();\n  }\n};\n\nL.Polyline.prototype._getLatLngs = L.Polyline.prototype.getLatLngs;\n\nL.Polyline.prototype.getLatLngs = function () {\n  if (this.dragging && this.dragging.inProgress()) {\n    var t = this.dragging._matrix;\n\n    var e = this._getLatLngs();\n\n    for (var i = 0, r = e.length; i < r; i++) {\n      e[i] = this.dragging._transformPoint(e[i], t);\n    }\n\n    return e;\n  } else {\n    return this._getLatLngs();\n  }\n};\n\n(function () {\n  L.FeatureGroup.EVENTS += \" dragstart\";\n\n  function t(t, e, i) {\n    for (var r = 0, a = t.length; r < a; r++) {\n      var s = t[r];\n      s.prototype[\"_\" + e] = s.prototype[e];\n      s.prototype[e] = i;\n    }\n  }\n\n  function e(t) {\n    if (this.hasLayer(t)) {\n      return this;\n    }\n\n    t.on(\"drag\", this._onDrag, this).on(\"dragend\", this._onDragEnd, this);\n    return this._addLayer.call(this, t);\n  }\n\n  function i(t) {\n    if (!this.hasLayer(t)) {\n      return this;\n    }\n\n    t.off(\"drag\", this._onDrag, this).off(\"dragend\", this._onDragEnd, this);\n    return this._removeLayer.call(this, t);\n  }\n\n  t([L.MultiPolygon, L.MultiPolyline], \"addLayer\", e);\n  t([L.MultiPolygon, L.MultiPolyline], \"removeLayer\", i);\n  var r = {\n    _onDrag: function _onDrag(t) {\n      var e = t.target;\n      this.eachLayer(function (t) {\n        if (t !== e) {\n          t._applyTransform(e.dragging._matrix);\n        }\n      });\n\n      this._propagateEvent(t);\n    },\n    _onDragEnd: function _onDragEnd(t) {\n      var e = t.target;\n      this.eachLayer(function (t) {\n        if (t !== e) {\n          t._resetTransform();\n\n          t.dragging._transformPoints(e.dragging._matrix);\n        }\n      });\n\n      this._propagateEvent(t);\n    }\n  };\n  L.MultiPolygon.include(r);\n  L.MultiPolyline.include(r);\n})();\n\nL.Polygon.include(L.Polygon.prototype.getCenter ? {} : {\n  getCenter: function getCenter() {\n    var t, e, i, r, a, s, o, n, h;\n    var _ = this._originalPoints;\n    o = n = h = 0;\n\n    for (t = 0, i = _.length, e = i - 1; t < i; e = t++) {\n      r = _[t];\n      a = _[e];\n      s = r.y * a.x - a.y * r.x;\n      n += (r.x + a.x) * s;\n      h += (r.y + a.y) * s;\n      o += s * 3;\n    }\n\n    return this._map.layerPointToLatLng([n / o, h / o]);\n  }\n});\n\"use strict\";\n\nL.EditToolbar.Edit.MOVE_MARKERS = false;\nL.EditToolbar.Edit.include({\n  initialize: function initialize(t, e) {\n    L.EditToolbar.Edit.MOVE_MARKERS = !!e.selectedPathOptions.moveMarkers;\n\n    this._initialize(t, e);\n  },\n  _initialize: L.EditToolbar.Edit.prototype.initialize\n});\nL.Edit.SimpleShape.include({\n  _updateMoveMarker: function _updateMoveMarker() {\n    if (this._moveMarker) {\n      this._moveMarker.setLatLng(this._getShapeCenter());\n    }\n  },\n  _getShapeCenter: function _getShapeCenter() {\n    return this._shape.getBounds().getCenter();\n  },\n  _createMoveMarker: function _createMoveMarker() {\n    if (L.EditToolbar.Edit.MOVE_MARKERS) {\n      this._moveMarker = this._createMarker(this._getShapeCenter(), this.options.moveIcon);\n    }\n  }\n});\nL.Edit.SimpleShape.mergeOptions({\n  moveMarker: false\n});\nL.Edit.Circle.include({\n  addHooks: function addHooks() {\n    if (this._shape._map) {\n      this._map = this._shape._map;\n\n      if (!this._markerGroup) {\n        this._enableDragging();\n\n        this._initMarkers();\n      }\n\n      this._shape._map.addLayer(this._markerGroup);\n    }\n  },\n  removeHooks: function removeHooks() {\n    if (this._shape._map) {\n      for (var t = 0, e = this._resizeMarkers.length; t < e; t++) {\n        this._unbindMarker(this._resizeMarkers[t]);\n      }\n\n      this._disableDragging();\n\n      this._resizeMarkers = null;\n\n      this._map.removeLayer(this._markerGroup);\n\n      delete this._markerGroup;\n    }\n\n    this._map = null;\n  },\n  _createMoveMarker: L.Edit.SimpleShape.prototype._createMoveMarker,\n  _resize: function _resize(t) {\n    var e = this._shape.getLatLng();\n\n    var i = e.distanceTo(t);\n\n    this._shape.setRadius(i);\n\n    this._updateMoveMarker();\n\n    this._map.fire(\"draw:editresize\", {\n      layer: this._shape\n    });\n  },\n  _enableDragging: function _enableDragging() {\n    if (!this._shape.dragging) {\n      this._shape.dragging = new L.Handler.PathDrag(this._shape);\n    }\n\n    this._shape.dragging.enable();\n\n    this._shape.on(\"dragstart\", this._onStartDragFeature, this).on(\"dragend\", this._onStopDragFeature, this);\n  },\n  _disableDragging: function _disableDragging() {\n    this._shape.dragging.disable();\n\n    this._shape.off(\"dragstart\", this._onStartDragFeature, this).off(\"dragend\", this._onStopDragFeature, this);\n  },\n  _onStartDragFeature: function _onStartDragFeature() {\n    this._shape._map.removeLayer(this._markerGroup);\n\n    this._shape.fire(\"editstart\");\n  },\n  _onStopDragFeature: function _onStopDragFeature() {\n    var t = this._shape.getLatLng();\n\n    this._resizeMarkers[0].setLatLng(this._getResizeMarkerPoint(t));\n\n    this._shape._map.addLayer(this._markerGroup);\n\n    this._updateMoveMarker();\n\n    this._fireEdit();\n  }\n});\nL.Edit.Rectangle.include({\n  addHooks: function addHooks() {\n    if (this._shape._map) {\n      if (!this._markerGroup) {\n        this._enableDragging();\n\n        this._initMarkers();\n      }\n\n      this._shape._map.addLayer(this._markerGroup);\n    }\n  },\n  removeHooks: function removeHooks() {\n    if (this._shape._map) {\n      this._shape._map.removeLayer(this._markerGroup);\n\n      this._disableDragging();\n\n      delete this._markerGroup;\n      delete this._markers;\n    }\n  },\n  _resize: function _resize(t) {\n    this._shape.setBounds(L.latLngBounds(t, this._oppositeCorner));\n\n    this._updateMoveMarker();\n\n    this._map.fire(\"draw:editresize\", {\n      layer: this._shape\n    });\n  },\n  _onMarkerDragEnd: function _onMarkerDragEnd(t) {\n    this._toggleCornerMarkers(1);\n\n    this._repositionCornerMarkers();\n\n    L.Edit.SimpleShape.prototype._onMarkerDragEnd.call(this, t);\n  },\n  _enableDragging: function _enableDragging() {\n    if (!this._shape.dragging) {\n      this._shape.dragging = new L.Handler.PathDrag(this._shape);\n    }\n\n    this._shape.dragging.enable();\n\n    this._shape.on(\"dragstart\", this._onStartDragFeature, this).on(\"dragend\", this._onStopDragFeature, this);\n  },\n  _disableDragging: function _disableDragging() {\n    this._shape.dragging.disable();\n\n    this._shape.off(\"dragstart\", this._onStartDragFeature, this).off(\"dragend\", this._onStopDragFeature, this);\n  },\n  _onStartDragFeature: function _onStartDragFeature() {\n    this._shape._map.removeLayer(this._markerGroup);\n\n    this._shape.fire(\"editstart\");\n  },\n  _onStopDragFeature: function _onStopDragFeature() {\n    var t = this._shape;\n\n    for (var e = 0, i = t._latlngs.length; e < i; e++) {\n      var r = this._resizeMarkers[e];\n      r.setLatLng(t._latlngs[e]);\n      r._origLatLng = t._latlngs[e];\n\n      if (r._middleLeft) {\n        r._middleLeft.setLatLng(this._getMiddleLatLng(r._prev, r));\n      }\n\n      if (r._middleRight) {\n        r._middleRight.setLatLng(this._getMiddleLatLng(r, r._next));\n      }\n    }\n\n    this._shape._map.addLayer(this._markerGroup);\n\n    this._updateMoveMarker();\n\n    this._repositionCornerMarkers();\n\n    this._fireEdit();\n  }\n});\nL.Edit.Poly.include({\n  __createMarker: L.Edit.Poly.prototype._createMarker,\n  __removeMarker: L.Edit.Poly.prototype._removeMarker,\n  addHooks: function addHooks() {\n    if (this._poly._map) {\n      if (!this._markerGroup) {\n        this._enableDragging();\n\n        this._initMarkers();\n\n        this._createMoveMarker();\n      }\n\n      this._poly._map.addLayer(this._markerGroup);\n    }\n  },\n  _createMoveMarker: function _createMoveMarker() {\n    if (L.EditToolbar.Edit.MOVE_MARKERS && this._poly instanceof L.Polygon) {\n      this._moveMarker = new L.Marker(this._getShapeCenter(), {\n        icon: this.options.moveIcon\n      });\n\n      this._moveMarker.on(\"mousedown\", this._delegateToShape, this);\n\n      this._markerGroup.addLayer(this._moveMarker);\n    }\n  },\n  _delegateToShape: function _delegateToShape(t) {\n    var e = this._shape || this._poly;\n    var i = t.target;\n    e.fire(\"mousedown\", L.Util.extend(t, {\n      containerPoint: L.DomUtil.getPosition(i._icon).add(e._map._getMapPanePos())\n    }));\n  },\n  _getShapeCenter: function _getShapeCenter() {\n    return this._poly.getCenter();\n  },\n  removeHooks: function removeHooks() {\n    if (this._poly._map) {\n      this._poly._map.removeLayer(this._markerGroup);\n\n      this._disableDragging();\n\n      delete this._markerGroup;\n      delete this._markers;\n    }\n  },\n  _enableDragging: function _enableDragging() {\n    if (!this._poly.dragging) {\n      this._poly.dragging = new L.Handler.PathDrag(this._poly);\n    }\n\n    this._poly.dragging.enable();\n\n    this._poly.on(\"dragstart\", this._onStartDragFeature, this).on(\"dragend\", this._onStopDragFeature, this);\n  },\n  _disableDragging: function _disableDragging() {\n    this._poly.dragging.disable();\n\n    this._poly.off(\"dragstart\", this._onStartDragFeature, this).off(\"dragend\", this._onStopDragFeature, this);\n  },\n  _onStartDragFeature: function _onStartDragFeature(t) {\n    this._poly._map.removeLayer(this._markerGroup);\n\n    this._poly.fire(\"editstart\");\n  },\n  _onStopDragFeature: function _onStopDragFeature(t) {\n    var e = this._poly;\n\n    for (var i = 0, r = e._latlngs.length; i < r; i++) {\n      var a = this._markers[i];\n      a.setLatLng(e._latlngs[i]);\n      a._origLatLng = e._latlngs[i];\n\n      if (a._middleLeft) {\n        a._middleLeft.setLatLng(this._getMiddleLatLng(a._prev, a));\n      }\n\n      if (a._middleRight) {\n        a._middleRight.setLatLng(this._getMiddleLatLng(a, a._next));\n      }\n    }\n\n    this._poly._map.addLayer(this._markerGroup);\n\n    L.Edit.SimpleShape.prototype._updateMoveMarker.call(this);\n\n    this._fireEdit();\n  },\n  _updateMoveMarker: L.Edit.SimpleShape.prototype._updateMoveMarker,\n  _createMarker: function _createMarker(t, e) {\n    var i = this.__createMarker(t, e);\n\n    i.on(\"dragstart\", this._hideMoveMarker, this).on(\"dragend\", this._showUpdateMoveMarker, this);\n    return i;\n  },\n  _removeMarker: function _removeMarker(t) {\n    this.__removeMarker(t);\n\n    t.off(\"dragstart\", this._hideMoveMarker, this).off(\"dragend\", this._showUpdateMoveMarker, this);\n  },\n  _hideMoveMarker: function _hideMoveMarker() {\n    if (this._moveMarker) {\n      this._markerGroup.removeLayer(this._moveMarker);\n    }\n  },\n  _showUpdateMoveMarker: function _showUpdateMoveMarker() {\n    if (this._moveMarker) {\n      this._markerGroup.addLayer(this._moveMarker);\n\n      this._updateMoveMarker();\n    }\n  }\n});\nL.Edit.Poly.prototype.options.moveIcon = new L.DivIcon({\n  iconSize: new L.Point(8, 8),\n  className: \"leaflet-div-icon leaflet-editing-icon leaflet-edit-move\"\n});\nL.Edit.Poly.mergeOptions({\n  moveMarker: false\n});\n\n//# sourceURL=webpack:///./lib/drag/leaflet.drag.js?");

/***/ }),

/***/ "./lib/draw/leaflet.draw-src.js":
/*!**************************************!*\
  !*** ./lib/draw/leaflet.draw-src.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\r\n\tLeaflet.draw, a plugin that adds drawing and editing tools to Leaflet powered maps.\r\n\t(c) 2012-2013, Jacob Toye, Smartrak\r\n\r\n\thttps://github.com/Leaflet/Leaflet.draw\r\n\thttp://leafletjs.com\r\n\thttps://github.com/jacobtoye\r\n*/\n(function (window, document, undefined) {\n  /*\r\n  * Leaflet.draw assumes that you have already included the Leaflet library.\r\n  */\n  L.drawVersion = '0.2.3';\n  L.drawLocal = {\n    draw: {\n      toolbar: {\n        actions: {\n          title: 'Cancel drawing',\n          text: 'Cancel'\n        },\n        undo: {\n          title: 'Delete last point drawn',\n          text: 'Delete last point'\n        },\n        buttons: {\n          polyline: 'Draw a polyline',\n          polygon: 'Draw a polygon',\n          rectangle: 'Draw a rectangle',\n          circle: 'Draw a circle',\n          marker: 'Draw a marker'\n        }\n      },\n      handlers: {\n        circle: {\n          tooltip: {\n            start: 'Click and drag to draw circle.'\n          }\n        },\n        marker: {\n          tooltip: {\n            start: 'Click map to place marker.'\n          }\n        },\n        polygon: {\n          tooltip: {\n            start: 'Click to start drawing shape.',\n            cont: 'Click to continue drawing shape.',\n            end: 'Click first point to close this shape.'\n          }\n        },\n        polyline: {\n          error: '<strong>Error:</strong> shape edges cannot cross!',\n          tooltip: {\n            start: 'Click to start drawing line.',\n            cont: 'Click to continue drawing line.',\n            end: 'Click last point to finish line.'\n          }\n        },\n        rectangle: {\n          tooltip: {\n            start: 'Click and drag to draw rectangle.'\n          }\n        },\n        simpleshape: {\n          tooltip: {\n            end: 'Release mouse to finish drawing.'\n          }\n        }\n      }\n    },\n    edit: {\n      toolbar: {\n        actions: {\n          save: {\n            title: 'Save changes.',\n            text: 'Save'\n          },\n          cancel: {\n            title: 'Cancel editing, discards all changes.',\n            text: 'Cancel'\n          }\n        },\n        buttons: {\n          edit: 'Edit layers.',\n          editDisabled: 'No layers to edit.',\n          remove: 'Delete layers.',\n          removeDisabled: 'No layers to delete.'\n        }\n      },\n      handlers: {\n        edit: {\n          tooltip: {\n            text: 'Drag handles, or marker to edit feature.',\n            subtext: 'Click cancel to undo changes.'\n          }\n        },\n        remove: {\n          tooltip: {\n            text: 'Click on a feature to remove'\n          }\n        }\n      }\n    }\n  };\n  L.Draw = {};\n  L.Draw.Feature = L.Handler.extend({\n    includes: L.Mixin.Events,\n    initialize: function initialize(map, options) {\n      this._map = map;\n      this._container = map._container;\n      this._overlayPane = map._panes.overlayPane;\n      this._popupPane = map._panes.popupPane; // Merge default shapeOptions options with custom shapeOptions\n\n      if (options && options.shapeOptions) {\n        options.shapeOptions = L.Util.extend({}, this.options.shapeOptions, options.shapeOptions);\n      }\n\n      L.setOptions(this, options);\n    },\n    enable: function enable() {\n      if (this._enabled) {\n        return;\n      }\n\n      this.fire('enabled', {\n        handler: this.type\n      });\n\n      this._map.fire('draw:drawstart', {\n        layerType: this.type\n      });\n\n      L.Handler.prototype.enable.call(this);\n    },\n    disable: function disable() {\n      if (!this._enabled) {\n        return;\n      }\n\n      L.Handler.prototype.disable.call(this);\n\n      this._map.fire('draw:drawstop', {\n        layerType: this.type\n      });\n\n      this.fire('disabled', {\n        handler: this.type\n      });\n    },\n    addHooks: function addHooks() {\n      var map = this._map;\n\n      if (map) {\n        L.DomUtil.disableTextSelection();\n        map.getContainer().focus();\n        this._tooltip = new L.Tooltip(this._map);\n        L.DomEvent.on(this._container, 'keyup', this._cancelDrawing, this);\n      }\n    },\n    removeHooks: function removeHooks() {\n      if (this._map) {\n        L.DomUtil.enableTextSelection();\n\n        this._tooltip.dispose();\n\n        this._tooltip = null;\n        L.DomEvent.off(this._container, 'keyup', this._cancelDrawing, this);\n      }\n    },\n    setOptions: function setOptions(options) {\n      L.setOptions(this, options);\n    },\n    _fireCreatedEvent: function _fireCreatedEvent(layer) {\n      this._map.fire('draw:created', {\n        layer: layer,\n        layerType: this.type\n      });\n    },\n    // Cancel drawing when the escape key is pressed\n    _cancelDrawing: function _cancelDrawing(e) {\n      if (e.keyCode === 27) {\n        this.disable();\n      }\n    }\n  });\n  L.Draw.Polyline = L.Draw.Feature.extend({\n    statics: {\n      TYPE: 'polyline'\n    },\n    Poly: L.Polyline,\n    options: {\n      allowIntersection: true,\n      repeatMode: false,\n      drawError: {\n        color: '#b00b00',\n        timeout: 2500\n      },\n      icon: new L.DivIcon({\n        iconSize: new L.Point(8, 8),\n        className: 'leaflet-div-icon leaflet-editing-icon'\n      }),\n      guidelineDistance: 20,\n      maxGuideLineLength: 4000,\n      shapeOptions: {\n        stroke: true,\n        color: '#f06eaa',\n        weight: 4,\n        opacity: 0.5,\n        fill: false,\n        clickable: true\n      },\n      metric: true,\n      // Whether to use the metric meaurement system or imperial\n      showLength: true,\n      // Whether to display distance in the tooltip\n      zIndexOffset: 2000 // This should be > than the highest z-index any map layers\n\n    },\n    initialize: function initialize(map, options) {\n      // Need to set this here to ensure the correct message is used.\n      this.options.drawError.message = L.drawLocal.draw.handlers.polyline.error; // Merge default drawError options with custom options\n\n      if (options && options.drawError) {\n        options.drawError = L.Util.extend({}, this.options.drawError, options.drawError);\n      } // Save the type so super can fire, need to do this as cannot do this.TYPE :(\n\n\n      this.type = L.Draw.Polyline.TYPE;\n      L.Draw.Feature.prototype.initialize.call(this, map, options);\n    },\n    addHooks: function addHooks() {\n      L.Draw.Feature.prototype.addHooks.call(this);\n\n      if (this._map) {\n        this._markers = [];\n        this._markerGroup = new L.LayerGroup();\n\n        this._map.addLayer(this._markerGroup);\n\n        this._poly = new L.Polyline([], this.options.shapeOptions);\n\n        this._tooltip.updateContent(this._getTooltipText()); // Make a transparent marker that will used to catch click events. These click\n        // events will create the vertices. We need to do this so we can ensure that\n        // we can create vertices over other map layers (markers, vector layers). We\n        // also do not want to trigger any click handlers of objects we are clicking on\n        // while drawing.\n\n\n        if (!this._mouseMarker) {\n          this._mouseMarker = L.marker(this._map.getCenter(), {\n            icon: L.divIcon({\n              className: 'leaflet-mouse-marker',\n              iconAnchor: [20, 20],\n              iconSize: [40, 40]\n            }),\n            opacity: 0,\n            zIndexOffset: this.options.zIndexOffset\n          });\n        }\n\n        this._mouseMarker.on('mousedown', this._onMouseDown, this).addTo(this._map);\n\n        this._map.on('mousemove', this._onMouseMove, this).on('mouseup', this._onMouseUp, this).on('zoomend', this._onZoomEnd, this);\n      }\n    },\n    removeHooks: function removeHooks() {\n      L.Draw.Feature.prototype.removeHooks.call(this);\n\n      this._clearHideErrorTimeout();\n\n      this._cleanUpShape(); // remove markers from map\n\n\n      this._map.removeLayer(this._markerGroup);\n\n      delete this._markerGroup;\n      delete this._markers;\n\n      this._map.removeLayer(this._poly);\n\n      delete this._poly;\n\n      this._mouseMarker.off('mousedown', this._onMouseDown, this).off('mouseup', this._onMouseUp, this);\n\n      this._map.removeLayer(this._mouseMarker);\n\n      delete this._mouseMarker; // clean up DOM\n\n      this._clearGuides();\n\n      this._map.off('mousemove', this._onMouseMove, this).off('zoomend', this._onZoomEnd, this);\n    },\n    deleteLastVertex: function deleteLastVertex() {\n      if (this._markers.length <= 1) {\n        return;\n      }\n\n      var lastMarker = this._markers.pop(),\n          poly = this._poly,\n          latlng = this._poly.spliceLatLngs(poly.getLatLngs().length - 1, 1)[0];\n\n      this._markerGroup.removeLayer(lastMarker);\n\n      if (poly.getLatLngs().length < 2) {\n        this._map.removeLayer(poly);\n      }\n\n      this._vertexChanged(latlng, false);\n    },\n    addVertex: function addVertex(latlng) {\n      var markersLength = this._markers.length;\n\n      if (markersLength > 0 && !this.options.allowIntersection && this._poly.newLatLngIntersects(latlng)) {\n        this._showErrorTooltip();\n\n        return;\n      } else if (this._errorShown) {\n        this._hideErrorTooltip();\n      }\n\n      this._markers.push(this._createMarker(latlng));\n\n      this._poly.addLatLng(latlng);\n\n      if (this._poly.getLatLngs().length === 2) {\n        this._map.addLayer(this._poly);\n      }\n\n      this._vertexChanged(latlng, true);\n    },\n    _finishShape: function _finishShape() {\n      var intersects = this._poly.newLatLngIntersects(this._poly.getLatLngs()[0], true);\n\n      if (!this.options.allowIntersection && intersects || !this._shapeIsValid()) {\n        this._showErrorTooltip();\n\n        return;\n      }\n\n      this._fireCreatedEvent();\n\n      this.disable();\n\n      if (this.options.repeatMode) {\n        this.enable();\n      }\n    },\n    //Called to verify the shape is valid when the user tries to finish it\n    //Return false if the shape is not valid\n    _shapeIsValid: function _shapeIsValid() {\n      return true;\n    },\n    _onZoomEnd: function _onZoomEnd() {\n      this._updateGuide();\n    },\n    _onMouseMove: function _onMouseMove(e) {\n      var newPos = e.layerPoint,\n          latlng = e.latlng; // Save latlng\n      // should this be moved to _updateGuide() ?\n\n      this._currentLatLng = latlng;\n\n      this._updateTooltip(latlng); // Update the guide line\n\n\n      this._updateGuide(newPos); // Update the mouse marker position\n\n\n      this._mouseMarker.setLatLng(latlng);\n\n      L.DomEvent.preventDefault(e.originalEvent);\n    },\n    _vertexChanged: function _vertexChanged(latlng, added) {\n      this._updateFinishHandler();\n\n      this._updateRunningMeasure(latlng, added);\n\n      this._clearGuides();\n\n      this._updateTooltip();\n    },\n    _onMouseDown: function _onMouseDown(e) {\n      var originalEvent = e.originalEvent;\n      this._mouseDownOrigin = L.point(originalEvent.clientX, originalEvent.clientY);\n    },\n    _onMouseUp: function _onMouseUp(e) {\n      if (this._mouseDownOrigin) {\n        // We detect clicks within a certain tolerance, otherwise let it\n        // be interpreted as a drag by the map\n        var distance = L.point(e.originalEvent.clientX, e.originalEvent.clientY).distanceTo(this._mouseDownOrigin);\n\n        if (Math.abs(distance) < 9 * (window.devicePixelRatio || 1)) {\n          this.addVertex(e.latlng);\n        }\n      }\n\n      this._mouseDownOrigin = null;\n    },\n    _updateFinishHandler: function _updateFinishHandler() {\n      var markerCount = this._markers.length; // The last marker should have a click handler to close the polyline\n\n      if (markerCount > 1) {\n        this._markers[markerCount - 1].on('click', this._finishShape, this);\n      } // Remove the old marker click handler (as only the last point should close the polyline)\n\n\n      if (markerCount > 2) {\n        this._markers[markerCount - 2].off('click', this._finishShape, this);\n      }\n    },\n    _createMarker: function _createMarker(latlng) {\n      var marker = new L.Marker(latlng, {\n        icon: this.options.icon,\n        zIndexOffset: this.options.zIndexOffset * 2\n      });\n\n      this._markerGroup.addLayer(marker);\n\n      return marker;\n    },\n    _updateGuide: function _updateGuide(newPos) {\n      var markerCount = this._markers.length;\n\n      if (markerCount > 0) {\n        newPos = newPos || this._map.latLngToLayerPoint(this._currentLatLng); // draw the guide line\n\n        this._clearGuides();\n\n        this._drawGuide(this._map.latLngToLayerPoint(this._markers[markerCount - 1].getLatLng()), newPos);\n      }\n    },\n    _updateTooltip: function _updateTooltip(latLng) {\n      var text = this._getTooltipText();\n\n      if (latLng) {\n        this._tooltip.updatePosition(latLng);\n      }\n\n      if (!this._errorShown) {\n        this._tooltip.updateContent(text);\n      }\n    },\n    _drawGuide: function _drawGuide(pointA, pointB) {\n      var length = Math.floor(Math.sqrt(Math.pow(pointB.x - pointA.x, 2) + Math.pow(pointB.y - pointA.y, 2))),\n          guidelineDistance = this.options.guidelineDistance,\n          maxGuideLineLength = this.options.maxGuideLineLength,\n          // Only draw a guideline with a max length\n      i = length > maxGuideLineLength ? length - maxGuideLineLength : guidelineDistance,\n          fraction,\n          dashPoint,\n          dash; //create the guides container if we haven't yet\n\n      if (!this._guidesContainer) {\n        this._guidesContainer = L.DomUtil.create('div', 'leaflet-draw-guides', this._overlayPane);\n      } //draw a dash every GuildeLineDistance\n\n\n      for (; i < length; i += this.options.guidelineDistance) {\n        //work out fraction along line we are\n        fraction = i / length; //calculate new x,y point\n\n        dashPoint = {\n          x: Math.floor(pointA.x * (1 - fraction) + fraction * pointB.x),\n          y: Math.floor(pointA.y * (1 - fraction) + fraction * pointB.y)\n        }; //add guide dash to guide container\n\n        dash = L.DomUtil.create('div', 'leaflet-draw-guide-dash', this._guidesContainer);\n        dash.style.backgroundColor = !this._errorShown ? this.options.shapeOptions.color : this.options.drawError.color;\n        L.DomUtil.setPosition(dash, dashPoint);\n      }\n    },\n    _updateGuideColor: function _updateGuideColor(color) {\n      if (this._guidesContainer) {\n        for (var i = 0, l = this._guidesContainer.childNodes.length; i < l; i++) {\n          this._guidesContainer.childNodes[i].style.backgroundColor = color;\n        }\n      }\n    },\n    // removes all child elements (guide dashes) from the guides container\n    _clearGuides: function _clearGuides() {\n      if (this._guidesContainer) {\n        while (this._guidesContainer.firstChild) {\n          this._guidesContainer.removeChild(this._guidesContainer.firstChild);\n        }\n      }\n    },\n    _getTooltipText: function _getTooltipText() {\n      var showLength = this.options.showLength,\n          labelText,\n          distanceStr;\n\n      if (this._markers.length === 0) {\n        labelText = {\n          text: L.drawLocal.draw.handlers.polyline.tooltip.start\n        };\n      } else {\n        distanceStr = showLength ? this._getMeasurementString() : '';\n\n        if (this._markers.length === 1) {\n          labelText = {\n            text: L.drawLocal.draw.handlers.polyline.tooltip.cont,\n            subtext: distanceStr\n          };\n        } else {\n          labelText = {\n            text: L.drawLocal.draw.handlers.polyline.tooltip.end,\n            subtext: distanceStr\n          };\n        }\n      }\n\n      return labelText;\n    },\n    _updateRunningMeasure: function _updateRunningMeasure(latlng, added) {\n      var markersLength = this._markers.length,\n          previousMarkerIndex,\n          distance;\n\n      if (this._markers.length === 1) {\n        this._measurementRunningTotal = 0;\n      } else {\n        previousMarkerIndex = markersLength - (added ? 2 : 1);\n        distance = latlng.distanceTo(this._markers[previousMarkerIndex].getLatLng());\n        this._measurementRunningTotal += distance * (added ? 1 : -1);\n      }\n    },\n    _getMeasurementString: function _getMeasurementString() {\n      var currentLatLng = this._currentLatLng,\n          previousLatLng = this._markers[this._markers.length - 1].getLatLng(),\n          distance; // calculate the distance from the last fixed point to the mouse position\n\n\n      distance = this._measurementRunningTotal + currentLatLng.distanceTo(previousLatLng);\n      return L.GeometryUtil.readableDistance(distance, this.options.metric);\n    },\n    _showErrorTooltip: function _showErrorTooltip() {\n      this._errorShown = true; // Update tooltip\n\n      this._tooltip.showAsError().updateContent({\n        text: this.options.drawError.message\n      }); // Update shape\n\n\n      this._updateGuideColor(this.options.drawError.color);\n\n      this._poly.setStyle({\n        color: this.options.drawError.color\n      }); // Hide the error after 2 seconds\n\n\n      this._clearHideErrorTimeout();\n\n      this._hideErrorTimeout = setTimeout(L.Util.bind(this._hideErrorTooltip, this), this.options.drawError.timeout);\n    },\n    _hideErrorTooltip: function _hideErrorTooltip() {\n      this._errorShown = false;\n\n      this._clearHideErrorTimeout(); // Revert tooltip\n\n\n      this._tooltip.removeError().updateContent(this._getTooltipText()); // Revert shape\n\n\n      this._updateGuideColor(this.options.shapeOptions.color);\n\n      this._poly.setStyle({\n        color: this.options.shapeOptions.color\n      });\n    },\n    _clearHideErrorTimeout: function _clearHideErrorTimeout() {\n      if (this._hideErrorTimeout) {\n        clearTimeout(this._hideErrorTimeout);\n        this._hideErrorTimeout = null;\n      }\n    },\n    _cleanUpShape: function _cleanUpShape() {\n      if (this._markers.length > 1) {\n        this._markers[this._markers.length - 1].off('click', this._finishShape, this);\n      }\n    },\n    _fireCreatedEvent: function _fireCreatedEvent() {\n      var poly = new this.Poly(this._poly.getLatLngs(), this.options.shapeOptions);\n\n      L.Draw.Feature.prototype._fireCreatedEvent.call(this, poly);\n    }\n  });\n  L.Draw.Polygon = L.Draw.Polyline.extend({\n    statics: {\n      TYPE: 'polygon'\n    },\n    Poly: L.Polygon,\n    options: {\n      showArea: false,\n      shapeOptions: {\n        stroke: true,\n        color: '#f06eaa',\n        weight: 4,\n        opacity: 0.5,\n        fill: true,\n        fillColor: null,\n        //same as color by default\n        fillOpacity: 0.2,\n        clickable: true\n      }\n    },\n    initialize: function initialize(map, options) {\n      L.Draw.Polyline.prototype.initialize.call(this, map, options); // Save the type so super can fire, need to do this as cannot do this.TYPE :(\n\n      this.type = L.Draw.Polygon.TYPE;\n    },\n    _updateFinishHandler: function _updateFinishHandler() {\n      var markerCount = this._markers.length; // The first marker should have a click handler to close the polygon\n\n      if (markerCount === 1) {\n        this._markers[0].on('click', this._finishShape, this);\n      } // Add and update the double click handler\n\n\n      if (markerCount > 2) {\n        this._markers[markerCount - 1].on('dblclick', this._finishShape, this); // Only need to remove handler if has been added before\n\n\n        if (markerCount > 3) {\n          this._markers[markerCount - 2].off('dblclick', this._finishShape, this);\n        }\n      }\n    },\n    _getTooltipText: function _getTooltipText() {\n      var text, subtext;\n\n      if (this._markers.length === 0) {\n        text = L.drawLocal.draw.handlers.polygon.tooltip.start;\n      } else if (this._markers.length < 3) {\n        text = L.drawLocal.draw.handlers.polygon.tooltip.cont;\n      } else {\n        text = L.drawLocal.draw.handlers.polygon.tooltip.end;\n        subtext = this._getMeasurementString();\n      }\n\n      return {\n        text: text,\n        subtext: subtext\n      };\n    },\n    _getMeasurementString: function _getMeasurementString() {\n      var area = this._area;\n\n      if (!area) {\n        return null;\n      }\n\n      return L.GeometryUtil.readableArea(area, this.options.metric);\n    },\n    _shapeIsValid: function _shapeIsValid() {\n      return this._markers.length >= 3;\n    },\n    _vertexAdded: function _vertexAdded() {\n      // Check to see if we should show the area\n      if (this.options.allowIntersection || !this.options.showArea) {\n        return;\n      }\n\n      var latLngs = this._poly.getLatLngs();\n\n      this._area = L.GeometryUtil.geodesicArea(latLngs);\n    },\n    _cleanUpShape: function _cleanUpShape() {\n      var markerCount = this._markers.length;\n\n      if (markerCount > 0) {\n        this._markers[0].off('click', this._finishShape, this);\n\n        if (markerCount > 2) {\n          this._markers[markerCount - 1].off('dblclick', this._finishShape, this);\n        }\n      }\n    }\n  });\n  L.SimpleShape = {};\n  L.Draw.SimpleShape = L.Draw.Feature.extend({\n    options: {\n      repeatMode: false\n    },\n    initialize: function initialize(map, options) {\n      this._endLabelText = L.drawLocal.draw.handlers.simpleshape.tooltip.end;\n      L.Draw.Feature.prototype.initialize.call(this, map, options);\n    },\n    addHooks: function addHooks() {\n      L.Draw.Feature.prototype.addHooks.call(this);\n\n      if (this._map) {\n        this._mapDraggable = this._map.dragging.enabled();\n\n        if (this._mapDraggable) {\n          this._map.dragging.disable();\n        } //TODO refactor: move cursor to styles\n\n\n        this._container.style.cursor = 'crosshair';\n\n        this._tooltip.updateContent({\n          text: this._initialLabelText\n        });\n\n        this._map.on('mousedown', this._onMouseDown, this).on('mousemove', this._onMouseMove, this);\n      }\n    },\n    removeHooks: function removeHooks() {\n      L.Draw.Feature.prototype.removeHooks.call(this);\n\n      if (this._map) {\n        if (this._mapDraggable) {\n          this._map.dragging.enable();\n        } //TODO refactor: move cursor to styles\n\n\n        this._container.style.cursor = '';\n\n        this._map.off('mousedown', this._onMouseDown, this).off('mousemove', this._onMouseMove, this);\n\n        L.DomEvent.off(document, 'mouseup', this._onMouseUp, this); // If the box element doesn't exist they must not have moved the mouse, so don't need to destroy/return\n\n        if (this._shape) {\n          this._map.removeLayer(this._shape);\n\n          delete this._shape;\n        }\n      }\n\n      this._isDrawing = false;\n    },\n    _onMouseDown: function _onMouseDown(e) {\n      this._isDrawing = true;\n      this._startLatLng = e.latlng;\n      L.DomEvent.on(document, 'mouseup', this._onMouseUp, this).preventDefault(e.originalEvent);\n    },\n    _onMouseMove: function _onMouseMove(e) {\n      var latlng = e.latlng;\n\n      this._tooltip.updatePosition(latlng);\n\n      if (this._isDrawing) {\n        this._tooltip.updateContent({\n          text: this._endLabelText\n        });\n\n        this._drawShape(latlng);\n      }\n    },\n    _onMouseUp: function _onMouseUp() {\n      if (this._shape) {\n        this._fireCreatedEvent();\n      }\n\n      this.disable();\n\n      if (this.options.repeatMode) {\n        this.enable();\n      }\n    }\n  });\n  L.Draw.Rectangle = L.Draw.SimpleShape.extend({\n    statics: {\n      TYPE: 'rectangle'\n    },\n    options: {\n      shapeOptions: {\n        stroke: true,\n        color: '#f06eaa',\n        weight: 4,\n        opacity: 0.5,\n        fill: true,\n        fillColor: null,\n        //same as color by default\n        fillOpacity: 0.2,\n        clickable: true\n      }\n    },\n    initialize: function initialize(map, options) {\n      // Save the type so super can fire, need to do this as cannot do this.TYPE :(\n      this.type = L.Draw.Rectangle.TYPE;\n      this._initialLabelText = L.drawLocal.draw.handlers.rectangle.tooltip.start;\n      L.Draw.SimpleShape.prototype.initialize.call(this, map, options);\n    },\n    _drawShape: function _drawShape(latlng) {\n      if (!this._shape) {\n        this._shape = new L.Rectangle(new L.LatLngBounds(this._startLatLng, latlng), this.options.shapeOptions);\n\n        this._map.addLayer(this._shape);\n      } else {\n        this._shape.setBounds(new L.LatLngBounds(this._startLatLng, latlng));\n      }\n    },\n    _fireCreatedEvent: function _fireCreatedEvent() {\n      var rectangle = new L.Rectangle(this._shape.getBounds(), this.options.shapeOptions);\n\n      L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, rectangle);\n    }\n  });\n  L.Draw.Circle = L.Draw.SimpleShape.extend({\n    statics: {\n      TYPE: 'circle'\n    },\n    options: {\n      shapeOptions: {\n        stroke: true,\n        color: '#f06eaa',\n        weight: 4,\n        opacity: 0.5,\n        fill: true,\n        fillColor: null,\n        //same as color by default\n        fillOpacity: 0.2,\n        clickable: true\n      },\n      showRadius: true,\n      metric: true // Whether to use the metric meaurement system or imperial\n\n    },\n    initialize: function initialize(map, options) {\n      // Save the type so super can fire, need to do this as cannot do this.TYPE :(\n      this.type = L.Draw.Circle.TYPE;\n      this._initialLabelText = L.drawLocal.draw.handlers.circle.tooltip.start;\n      L.Draw.SimpleShape.prototype.initialize.call(this, map, options);\n    },\n    _drawShape: function _drawShape(latlng) {\n      if (!this._shape) {\n        this._shape = new L.Circle(this._startLatLng, this._startLatLng.distanceTo(latlng), this.options.shapeOptions);\n\n        this._map.addLayer(this._shape);\n      } else {\n        this._shape.setRadius(this._startLatLng.distanceTo(latlng));\n      }\n    },\n    _fireCreatedEvent: function _fireCreatedEvent() {\n      var circle = new L.Circle(this._startLatLng, this._shape.getRadius(), this.options.shapeOptions);\n\n      L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, circle);\n    },\n    _onMouseMove: function _onMouseMove(e) {\n      var latlng = e.latlng,\n          showRadius = this.options.showRadius,\n          useMetric = this.options.metric,\n          radius;\n\n      this._tooltip.updatePosition(latlng);\n\n      if (this._isDrawing) {\n        this._drawShape(latlng); // Get the new radius (rounded to 1 dp)\n\n\n        radius = this._shape.getRadius().toFixed(1);\n\n        this._tooltip.updateContent({\n          text: this._endLabelText,\n          subtext: showRadius ? 'Radius: ' + L.GeometryUtil.readableDistance(radius, useMetric) : ''\n        });\n      }\n    }\n  });\n  L.Draw.Marker = L.Draw.Feature.extend({\n    statics: {\n      TYPE: 'marker'\n    },\n    options: {\n      icon: new L.Icon.Default(),\n      repeatMode: false,\n      zIndexOffset: 2000 // This should be > than the highest z-index any markers\n\n    },\n    initialize: function initialize(map, options) {\n      // Save the type so super can fire, need to do this as cannot do this.TYPE :(\n      this.type = L.Draw.Marker.TYPE;\n      L.Draw.Feature.prototype.initialize.call(this, map, options);\n    },\n    addHooks: function addHooks() {\n      L.Draw.Feature.prototype.addHooks.call(this);\n\n      if (this._map) {\n        this._tooltip.updateContent({\n          text: L.drawLocal.draw.handlers.marker.tooltip.start\n        }); // Same mouseMarker as in Draw.Polyline\n\n\n        if (!this._mouseMarker) {\n          this._mouseMarker = L.marker(this._map.getCenter(), {\n            icon: L.divIcon({\n              className: 'leaflet-mouse-marker',\n              iconAnchor: [20, 20],\n              iconSize: [40, 40]\n            }),\n            opacity: 0,\n            zIndexOffset: this.options.zIndexOffset\n          });\n        }\n\n        this._mouseMarker.on('click', this._onClick, this).addTo(this._map);\n\n        this._map.on('mousemove', this._onMouseMove, this);\n      }\n    },\n    removeHooks: function removeHooks() {\n      L.Draw.Feature.prototype.removeHooks.call(this);\n\n      if (this._map) {\n        if (this._marker) {\n          this._marker.off('click', this._onClick, this);\n\n          this._map.off('click', this._onClick, this).removeLayer(this._marker);\n\n          delete this._marker;\n        }\n\n        this._mouseMarker.off('click', this._onClick, this);\n\n        this._map.removeLayer(this._mouseMarker);\n\n        delete this._mouseMarker;\n\n        this._map.off('mousemove', this._onMouseMove, this);\n      }\n    },\n    _onMouseMove: function _onMouseMove(e) {\n      var latlng = e.latlng;\n\n      this._tooltip.updatePosition(latlng);\n\n      this._mouseMarker.setLatLng(latlng);\n\n      if (!this._marker) {\n        this._marker = new L.Marker(latlng, {\n          icon: this.options.icon,\n          zIndexOffset: this.options.zIndexOffset\n        }); // Bind to both marker and map to make sure we get the click event.\n\n        this._marker.on('click', this._onClick, this);\n\n        this._map.on('click', this._onClick, this).addLayer(this._marker);\n      } else {\n        latlng = this._mouseMarker.getLatLng();\n\n        this._marker.setLatLng(latlng);\n      }\n    },\n    _onClick: function _onClick() {\n      this._fireCreatedEvent();\n\n      this.disable();\n\n      if (this.options.repeatMode) {\n        this.enable();\n      }\n    },\n    _fireCreatedEvent: function _fireCreatedEvent() {\n      var marker = new L.Marker(this._marker.getLatLng(), {\n        icon: this.options.icon\n      });\n\n      L.Draw.Feature.prototype._fireCreatedEvent.call(this, marker);\n    }\n  });\n  L.Edit = L.Edit || {};\n  /*\r\n   * L.Edit.Poly is an editing handler for polylines and polygons.\r\n   */\n\n  L.Edit.Poly = L.Handler.extend({\n    options: {\n      icon: new L.DivIcon({\n        iconSize: new L.Point(8, 8),\n        className: 'leaflet-div-icon leaflet-editing-icon'\n      })\n    },\n    initialize: function initialize(poly, options) {\n      this._poly = poly;\n      L.setOptions(this, options);\n    },\n    addHooks: function addHooks() {\n      if (this._poly._map) {\n        if (!this._markerGroup) {\n          this._initMarkers();\n        }\n\n        this._poly._map.addLayer(this._markerGroup);\n      }\n    },\n    removeHooks: function removeHooks() {\n      if (this._poly._map) {\n        this._poly._map.removeLayer(this._markerGroup);\n\n        delete this._markerGroup;\n        delete this._markers;\n      }\n    },\n    updateMarkers: function updateMarkers() {\n      this._markerGroup.clearLayers();\n\n      this._initMarkers();\n    },\n    _initMarkers: function _initMarkers() {\n      if (!this._markerGroup) {\n        this._markerGroup = new L.LayerGroup();\n      }\n\n      this._markers = [];\n      var latlngs = this._poly._latlngs,\n          i,\n          j,\n          len,\n          marker; // TODO refactor holes implementation in Polygon to support it here\n\n      for (i = 0, len = latlngs.length; i < len; i++) {\n        marker = this._createMarker(latlngs[i], i);\n        marker.on('click', this._onMarkerClick, this);\n\n        this._markers.push(marker);\n      }\n\n      var markerLeft, markerRight;\n\n      for (i = 0, j = len - 1; i < len; j = i++) {\n        if (i === 0 && !(L.Polygon && this._poly instanceof L.Polygon)) {\n          continue;\n        }\n\n        markerLeft = this._markers[j];\n        markerRight = this._markers[i];\n\n        this._createMiddleMarker(markerLeft, markerRight);\n\n        this._updatePrevNext(markerLeft, markerRight);\n      }\n    },\n    _createMarker: function _createMarker(latlng, index) {\n      var marker = new L.Marker(latlng, {\n        draggable: true,\n        icon: this.options.icon\n      });\n      marker._origLatLng = latlng;\n      marker._index = index;\n      marker.on('drag', this._onMarkerDrag, this);\n      marker.on('dragend', this._fireEdit, this);\n\n      this._markerGroup.addLayer(marker);\n\n      return marker;\n    },\n    _removeMarker: function _removeMarker(marker) {\n      var i = marker._index;\n\n      this._markerGroup.removeLayer(marker);\n\n      this._markers.splice(i, 1);\n\n      this._poly.spliceLatLngs(i, 1);\n\n      this._updateIndexes(i, -1);\n\n      marker.off('drag', this._onMarkerDrag, this).off('dragend', this._fireEdit, this).off('click', this._onMarkerClick, this);\n    },\n    _fireEdit: function _fireEdit() {\n      this._poly.edited = true;\n\n      this._poly.fire('edit');\n    },\n    _onMarkerDrag: function _onMarkerDrag(e) {\n      var marker = e.target;\n      L.extend(marker._origLatLng, marker._latlng);\n\n      if (marker._middleLeft) {\n        marker._middleLeft.setLatLng(this._getMiddleLatLng(marker._prev, marker));\n      }\n\n      if (marker._middleRight) {\n        marker._middleRight.setLatLng(this._getMiddleLatLng(marker, marker._next));\n      }\n\n      this._poly.redraw();\n    },\n    _onMarkerClick: function _onMarkerClick(e) {\n      var minPoints = L.Polygon && this._poly instanceof L.Polygon ? 4 : 3,\n          marker = e.target; // If removing this point would create an invalid polyline/polygon don't remove\n\n      if (this._poly._latlngs.length < minPoints) {\n        return;\n      } // remove the marker\n\n\n      this._removeMarker(marker); // update prev/next links of adjacent markers\n\n\n      this._updatePrevNext(marker._prev, marker._next); // remove ghost markers near the removed marker\n\n\n      if (marker._middleLeft) {\n        this._markerGroup.removeLayer(marker._middleLeft);\n      }\n\n      if (marker._middleRight) {\n        this._markerGroup.removeLayer(marker._middleRight);\n      } // create a ghost marker in place of the removed one\n\n\n      if (marker._prev && marker._next) {\n        this._createMiddleMarker(marker._prev, marker._next);\n      } else if (!marker._prev) {\n        marker._next._middleLeft = null;\n      } else if (!marker._next) {\n        marker._prev._middleRight = null;\n      }\n\n      this._fireEdit();\n    },\n    _updateIndexes: function _updateIndexes(index, delta) {\n      this._markerGroup.eachLayer(function (marker) {\n        if (marker._index > index) {\n          marker._index += delta;\n        }\n      });\n    },\n    _createMiddleMarker: function _createMiddleMarker(marker1, marker2) {\n      var latlng = this._getMiddleLatLng(marker1, marker2),\n          marker = this._createMarker(latlng),\n          onClick,\n          onDragStart,\n          _onDragEnd;\n\n      marker.setOpacity(0.6);\n      marker1._middleRight = marker2._middleLeft = marker;\n\n      onDragStart = function onDragStart() {\n        var i = marker2._index;\n        marker._index = i;\n        marker.off('click', onClick, this).on('click', this._onMarkerClick, this);\n        latlng.lat = marker.getLatLng().lat;\n        latlng.lng = marker.getLatLng().lng;\n\n        this._poly.spliceLatLngs(i, 0, latlng);\n\n        this._markers.splice(i, 0, marker);\n\n        marker.setOpacity(1);\n\n        this._updateIndexes(i, 1);\n\n        marker2._index++;\n\n        this._updatePrevNext(marker1, marker);\n\n        this._updatePrevNext(marker, marker2);\n\n        this._poly.fire('editstart');\n      };\n\n      _onDragEnd = function onDragEnd() {\n        marker.off('dragstart', onDragStart, this);\n        marker.off('dragend', _onDragEnd, this);\n\n        this._createMiddleMarker(marker1, marker);\n\n        this._createMiddleMarker(marker, marker2);\n      };\n\n      onClick = function onClick() {\n        onDragStart.call(this);\n\n        _onDragEnd.call(this);\n\n        this._fireEdit();\n      };\n\n      marker.on('click', onClick, this).on('dragstart', onDragStart, this).on('dragend', _onDragEnd, this);\n\n      this._markerGroup.addLayer(marker);\n    },\n    _updatePrevNext: function _updatePrevNext(marker1, marker2) {\n      if (marker1) {\n        marker1._next = marker2;\n      }\n\n      if (marker2) {\n        marker2._prev = marker1;\n      }\n    },\n    _getMiddleLatLng: function _getMiddleLatLng(marker1, marker2) {\n      var map = this._poly._map,\n          p1 = map.project(marker1.getLatLng()),\n          p2 = map.project(marker2.getLatLng());\n      return map.unproject(p1._add(p2)._divideBy(2));\n    }\n  });\n  L.Polyline.addInitHook(function () {\n    // Check to see if handler has already been initialized. This is to support versions of Leaflet that still have L.Handler.PolyEdit\n    if (this.editing) {\n      return;\n    }\n\n    if (L.Edit.Poly) {\n      this.editing = new L.Edit.Poly(this);\n\n      if (this.options.editable) {\n        this.editing.enable();\n      }\n    }\n\n    this.on('add', function () {\n      if (this.editing && this.editing.enabled()) {\n        this.editing.addHooks();\n      }\n    });\n    this.on('remove', function () {\n      if (this.editing && this.editing.enabled()) {\n        this.editing.removeHooks();\n      }\n    });\n  });\n  L.Edit = L.Edit || {};\n  L.Edit.SimpleShape = L.Handler.extend({\n    options: {\n      moveIcon: new L.DivIcon({\n        iconSize: new L.Point(8, 8),\n        className: 'leaflet-div-icon leaflet-editing-icon leaflet-edit-move'\n      }),\n      resizeIcon: new L.DivIcon({\n        iconSize: new L.Point(8, 8),\n        className: 'leaflet-div-icon leaflet-editing-icon leaflet-edit-resize'\n      })\n    },\n    initialize: function initialize(shape, options) {\n      this._shape = shape;\n      L.Util.setOptions(this, options);\n    },\n    addHooks: function addHooks() {\n      if (this._shape._map) {\n        this._map = this._shape._map;\n\n        if (!this._markerGroup) {\n          this._initMarkers();\n        }\n\n        this._map.addLayer(this._markerGroup);\n      }\n    },\n    removeHooks: function removeHooks() {\n      if (this._shape._map) {\n        this._unbindMarker(this._moveMarker);\n\n        for (var i = 0, l = this._resizeMarkers.length; i < l; i++) {\n          this._unbindMarker(this._resizeMarkers[i]);\n        }\n\n        this._resizeMarkers = null;\n\n        this._map.removeLayer(this._markerGroup);\n\n        delete this._markerGroup;\n      }\n\n      this._map = null;\n    },\n    updateMarkers: function updateMarkers() {\n      this._markerGroup.clearLayers();\n\n      this._initMarkers();\n    },\n    _initMarkers: function _initMarkers() {\n      if (!this._markerGroup) {\n        this._markerGroup = new L.LayerGroup();\n      } // Create center marker\n\n\n      this._createMoveMarker(); // Create edge marker\n\n\n      this._createResizeMarker();\n    },\n    _createMoveMarker: function _createMoveMarker() {// Children override\n    },\n    _createResizeMarker: function _createResizeMarker() {// Children override\n    },\n    _createMarker: function _createMarker(latlng, icon) {\n      var marker = new L.Marker(latlng, {\n        draggable: true,\n        icon: icon,\n        zIndexOffset: 10\n      });\n\n      this._bindMarker(marker);\n\n      this._markerGroup.addLayer(marker);\n\n      return marker;\n    },\n    _bindMarker: function _bindMarker(marker) {\n      marker.on('dragstart', this._onMarkerDragStart, this).on('drag', this._onMarkerDrag, this).on('dragend', this._onMarkerDragEnd, this);\n    },\n    _unbindMarker: function _unbindMarker(marker) {\n      marker.off('dragstart', this._onMarkerDragStart, this).off('drag', this._onMarkerDrag, this).off('dragend', this._onMarkerDragEnd, this);\n    },\n    _onMarkerDragStart: function _onMarkerDragStart(e) {\n      var marker = e.target;\n      marker.setOpacity(0);\n\n      this._shape.fire('editstart');\n    },\n    _fireEdit: function _fireEdit() {\n      this._shape.edited = true;\n\n      this._shape.fire('edit');\n    },\n    _onMarkerDrag: function _onMarkerDrag(e) {\n      var marker = e.target,\n          latlng = marker.getLatLng();\n\n      if (marker === this._moveMarker) {\n        this._move(latlng);\n      } else {\n        this._resize(latlng);\n      }\n\n      this._shape.redraw();\n    },\n    _onMarkerDragEnd: function _onMarkerDragEnd(e) {\n      var marker = e.target;\n      marker.setOpacity(1);\n\n      this._fireEdit();\n    },\n    _move: function _move() {// Children override\n    },\n    _resize: function _resize() {// Children override\n    }\n  });\n  L.Edit = L.Edit || {};\n  L.Edit.Rectangle = L.Edit.SimpleShape.extend({\n    _createMoveMarker: function _createMoveMarker() {\n      var bounds = this._shape.getBounds(),\n          center = bounds.getCenter();\n\n      this._moveMarker = this._createMarker(center, this.options.moveIcon);\n    },\n    _createResizeMarker: function _createResizeMarker() {\n      var corners = this._getCorners();\n\n      this._resizeMarkers = [];\n\n      for (var i = 0, l = corners.length; i < l; i++) {\n        this._resizeMarkers.push(this._createMarker(corners[i], this.options.resizeIcon)); // Monkey in the corner index as we will need to know this for dragging\n\n\n        this._resizeMarkers[i]._cornerIndex = i;\n      }\n    },\n    _onMarkerDragStart: function _onMarkerDragStart(e) {\n      L.Edit.SimpleShape.prototype._onMarkerDragStart.call(this, e); // Save a reference to the opposite point\n\n\n      var corners = this._getCorners(),\n          marker = e.target,\n          currentCornerIndex = marker._cornerIndex;\n\n      this._oppositeCorner = corners[(currentCornerIndex + 2) % 4];\n\n      this._toggleCornerMarkers(0, currentCornerIndex);\n    },\n    _onMarkerDragEnd: function _onMarkerDragEnd(e) {\n      var marker = e.target,\n          bounds,\n          center; // Reset move marker position to the center\n\n      if (marker === this._moveMarker) {\n        bounds = this._shape.getBounds();\n        center = bounds.getCenter();\n        marker.setLatLng(center);\n      }\n\n      this._toggleCornerMarkers(1);\n\n      this._repositionCornerMarkers();\n\n      L.Edit.SimpleShape.prototype._onMarkerDragEnd.call(this, e);\n    },\n    _move: function _move(newCenter) {\n      var latlngs = this._shape.getLatLngs(),\n          bounds = this._shape.getBounds(),\n          center = bounds.getCenter(),\n          offset,\n          newLatLngs = []; // Offset the latlngs to the new center\n\n\n      for (var i = 0, l = latlngs.length; i < l; i++) {\n        offset = [latlngs[i].lat - center.lat, latlngs[i].lng - center.lng];\n        newLatLngs.push([newCenter.lat + offset[0], newCenter.lng + offset[1]]);\n      }\n\n      this._shape.setLatLngs(newLatLngs); // Reposition the resize markers\n\n\n      this._repositionCornerMarkers();\n    },\n    _resize: function _resize(latlng) {\n      var bounds; // Update the shape based on the current position of this corner and the opposite point\n\n      this._shape.setBounds(L.latLngBounds(latlng, this._oppositeCorner)); // Reposition the move marker\n\n\n      bounds = this._shape.getBounds();\n\n      this._moveMarker.setLatLng(bounds.getCenter());\n    },\n    _getCorners: function _getCorners() {\n      var bounds = this._shape.getBounds(),\n          nw = bounds.getNorthWest(),\n          ne = bounds.getNorthEast(),\n          se = bounds.getSouthEast(),\n          sw = bounds.getSouthWest();\n\n      return [nw, ne, se, sw];\n    },\n    _toggleCornerMarkers: function _toggleCornerMarkers(opacity) {\n      for (var i = 0, l = this._resizeMarkers.length; i < l; i++) {\n        this._resizeMarkers[i].setOpacity(opacity);\n      }\n    },\n    _repositionCornerMarkers: function _repositionCornerMarkers() {\n      var corners = this._getCorners();\n\n      for (var i = 0, l = this._resizeMarkers.length; i < l; i++) {\n        this._resizeMarkers[i].setLatLng(corners[i]);\n      }\n    }\n  });\n  L.Rectangle.addInitHook(function () {\n    if (L.Edit.Rectangle) {\n      this.editing = new L.Edit.Rectangle(this);\n\n      if (this.options.editable) {\n        this.editing.enable();\n      }\n    }\n  });\n  L.Edit = L.Edit || {};\n  L.Edit.Circle = L.Edit.SimpleShape.extend({\n    _createMoveMarker: function _createMoveMarker() {\n      var center = this._shape.getLatLng();\n\n      this._moveMarker = this._createMarker(center, this.options.moveIcon);\n    },\n    _createResizeMarker: function _createResizeMarker() {\n      var center = this._shape.getLatLng(),\n          resizemarkerPoint = this._getResizeMarkerPoint(center);\n\n      this._resizeMarkers = [];\n\n      this._resizeMarkers.push(this._createMarker(resizemarkerPoint, this.options.resizeIcon));\n    },\n    _getResizeMarkerPoint: function _getResizeMarkerPoint(latlng) {\n      // From L.shape.getBounds()\n      var delta = this._shape._radius * Math.cos(Math.PI / 4),\n          point = this._map.project(latlng);\n\n      return this._map.unproject([point.x + delta, point.y - delta]);\n    },\n    _move: function _move(latlng) {\n      var resizemarkerPoint = this._getResizeMarkerPoint(latlng); // Move the resize marker\n\n\n      this._resizeMarkers[0].setLatLng(resizemarkerPoint); // Move the circle\n\n\n      this._shape.setLatLng(latlng);\n    },\n    _resize: function _resize(latlng) {\n      var moveLatLng = this._moveMarker.getLatLng(),\n          radius = moveLatLng.distanceTo(latlng);\n\n      this._shape.setRadius(radius);\n    }\n  });\n  L.Circle.addInitHook(function () {\n    if (L.Edit.Circle) {\n      this.editing = new L.Edit.Circle(this);\n\n      if (this.options.editable) {\n        this.editing.enable();\n      }\n    }\n\n    this.on('add', function () {\n      if (this.editing && this.editing.enabled()) {\n        this.editing.addHooks();\n      }\n    });\n    this.on('remove', function () {\n      if (this.editing && this.editing.enabled()) {\n        this.editing.removeHooks();\n      }\n    });\n  });\n  /*\r\n   * L.LatLngUtil contains different utility functions for LatLngs.\r\n   */\n\n  L.LatLngUtil = {\n    // Clones a LatLngs[], returns [][]\n    cloneLatLngs: function cloneLatLngs(latlngs) {\n      var clone = [];\n\n      for (var i = 0, l = latlngs.length; i < l; i++) {\n        clone.push(this.cloneLatLng(latlngs[i]));\n      }\n\n      return clone;\n    },\n    cloneLatLng: function cloneLatLng(latlng) {\n      return L.latLng(latlng.lat, latlng.lng);\n    }\n  };\n  L.GeometryUtil = L.extend(L.GeometryUtil || {}, {\n    // Ported from the OpenLayers implementation. See https://github.com/openlayers/openlayers/blob/master/lib/OpenLayers/Geometry/LinearRing.js#L270\n    geodesicArea: function geodesicArea(latLngs) {\n      var pointsCount = latLngs.length,\n          area = 0.0,\n          d2r = L.LatLng.DEG_TO_RAD,\n          p1,\n          p2;\n\n      if (pointsCount > 2) {\n        for (var i = 0; i < pointsCount; i++) {\n          p1 = latLngs[i];\n          p2 = latLngs[(i + 1) % pointsCount];\n          area += (p2.lng - p1.lng) * d2r * (2 + Math.sin(p1.lat * d2r) + Math.sin(p2.lat * d2r));\n        }\n\n        area = area * 6378137.0 * 6378137.0 / 2.0;\n      }\n\n      return Math.abs(area);\n    },\n    readableArea: function readableArea(area, isMetric) {\n      var areaStr;\n\n      if (isMetric) {\n        if (area >= 10000) {\n          areaStr = (area * 0.0001).toFixed(2) + ' ha';\n        } else {\n          areaStr = area.toFixed(2) + ' m&sup2;';\n        }\n      } else {\n        area *= 0.836127; // Square yards in 1 meter\n\n        if (area >= 3097600) {\n          //3097600 square yards in 1 square mile\n          areaStr = (area / 3097600).toFixed(2) + ' mi&sup2;';\n        } else if (area >= 4840) {\n          //48040 square yards in 1 acre\n          areaStr = (area / 4840).toFixed(2) + ' acres';\n        } else {\n          areaStr = Math.ceil(area) + ' yd&sup2;';\n        }\n      }\n\n      return areaStr;\n    },\n    readableDistance: function readableDistance(distance, isMetric) {\n      var distanceStr;\n\n      if (isMetric) {\n        // show metres when distance is < 1km, then show km\n        if (distance > 1000) {\n          distanceStr = (distance / 1000).toFixed(2) + ' km';\n        } else {\n          distanceStr = Math.ceil(distance) + ' m';\n        }\n      } else {\n        distance *= 1.09361;\n\n        if (distance > 1760) {\n          distanceStr = (distance / 1760).toFixed(2) + ' miles';\n        } else {\n          distanceStr = Math.ceil(distance) + ' yd';\n        }\n      }\n\n      return distanceStr;\n    }\n  });\n  L.Util.extend(L.LineUtil, {\n    // Checks to see if two line segments intersect. Does not handle degenerate cases.\n    // http://compgeom.cs.uiuc.edu/~jeffe/teaching/373/notes/x06-sweepline.pdf\n    segmentsIntersect: function segmentsIntersect(\n    /*Point*/\n    p,\n    /*Point*/\n    p1,\n    /*Point*/\n    p2,\n    /*Point*/\n    p3) {\n      return this._checkCounterclockwise(p, p2, p3) !== this._checkCounterclockwise(p1, p2, p3) && this._checkCounterclockwise(p, p1, p2) !== this._checkCounterclockwise(p, p1, p3);\n    },\n    // check to see if points are in counterclockwise order\n    _checkCounterclockwise: function _checkCounterclockwise(\n    /*Point*/\n    p,\n    /*Point*/\n    p1,\n    /*Point*/\n    p2) {\n      return (p2.y - p.y) * (p1.x - p.x) > (p1.y - p.y) * (p2.x - p.x);\n    }\n  });\n  L.Polyline.include({\n    // Check to see if this polyline has any linesegments that intersect.\n    // NOTE: does not support detecting intersection for degenerate cases.\n    intersects: function intersects() {\n      var points = this._originalPoints,\n          len = points ? points.length : 0,\n          i,\n          p,\n          p1;\n\n      if (this._tooFewPointsForIntersection()) {\n        return false;\n      }\n\n      for (i = len - 1; i >= 3; i--) {\n        p = points[i - 1];\n        p1 = points[i];\n\n        if (this._lineSegmentsIntersectsRange(p, p1, i - 2)) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    // Check for intersection if new latlng was added to this polyline.\n    // NOTE: does not support detecting intersection for degenerate cases.\n    newLatLngIntersects: function newLatLngIntersects(latlng, skipFirst) {\n      // Cannot check a polyline for intersecting lats/lngs when not added to the map\n      if (!this._map) {\n        return false;\n      }\n\n      return this.newPointIntersects(this._map.latLngToLayerPoint(latlng), skipFirst);\n    },\n    // Check for intersection if new point was added to this polyline.\n    // newPoint must be a layer point.\n    // NOTE: does not support detecting intersection for degenerate cases.\n    newPointIntersects: function newPointIntersects(newPoint, skipFirst) {\n      var points = this._originalPoints,\n          len = points ? points.length : 0,\n          lastPoint = points ? points[len - 1] : null,\n          // The previous previous line segment. Previous line segment doesn't need testing.\n      maxIndex = len - 2;\n\n      if (this._tooFewPointsForIntersection(1)) {\n        return false;\n      }\n\n      return this._lineSegmentsIntersectsRange(lastPoint, newPoint, maxIndex, skipFirst ? 1 : 0);\n    },\n    // Polylines with 2 sides can only intersect in cases where points are collinear (we don't support detecting these).\n    // Cannot have intersection when < 3 line segments (< 4 points)\n    _tooFewPointsForIntersection: function _tooFewPointsForIntersection(extraPoints) {\n      var points = this._originalPoints,\n          len = points ? points.length : 0; // Increment length by extraPoints if present\n\n      len += extraPoints || 0;\n      return !this._originalPoints || len <= 3;\n    },\n    // Checks a line segment intersections with any line segments before its predecessor.\n    // Don't need to check the predecessor as will never intersect.\n    _lineSegmentsIntersectsRange: function _lineSegmentsIntersectsRange(p, p1, maxIndex, minIndex) {\n      var points = this._originalPoints,\n          p2,\n          p3;\n      minIndex = minIndex || 0; // Check all previous line segments (beside the immediately previous) for intersections\n\n      for (var j = maxIndex; j > minIndex; j--) {\n        p2 = points[j - 1];\n        p3 = points[j];\n\n        if (L.LineUtil.segmentsIntersect(p, p1, p2, p3)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  });\n  L.Polygon.include({\n    // Checks a polygon for any intersecting line segments. Ignores holes.\n    intersects: function intersects() {\n      var polylineIntersects,\n          points = this._originalPoints,\n          len,\n          firstPoint,\n          lastPoint,\n          maxIndex;\n\n      if (this._tooFewPointsForIntersection()) {\n        return false;\n      }\n\n      polylineIntersects = L.Polyline.prototype.intersects.call(this); // If already found an intersection don't need to check for any more.\n\n      if (polylineIntersects) {\n        return true;\n      }\n\n      len = points.length;\n      firstPoint = points[0];\n      lastPoint = points[len - 1];\n      maxIndex = len - 2; // Check the line segment between last and first point. Don't need to check the first line segment (minIndex = 1)\n\n      return this._lineSegmentsIntersectsRange(lastPoint, firstPoint, maxIndex, 1);\n    }\n  });\n  L.Control.Draw = L.Control.extend({\n    options: {\n      position: 'topleft',\n      draw: {},\n      edit: false\n    },\n    initialize: function initialize(options) {\n      if (L.version < '0.7') {\n        throw new Error('Leaflet.draw 0.2.3+ requires Leaflet 0.7.0+. Download latest from https://github.com/Leaflet/Leaflet/');\n      }\n\n      L.Control.prototype.initialize.call(this, options);\n      var id, toolbar;\n      this._toolbars = {}; // Initialize toolbars\n\n      if (L.DrawToolbar && this.options.draw) {\n        toolbar = new L.DrawToolbar(this.options.draw);\n        id = L.stamp(toolbar);\n        this._toolbars[id] = toolbar; // Listen for when toolbar is enabled\n\n        this._toolbars[id].on('enable', this._toolbarEnabled, this);\n      }\n\n      if (L.EditToolbar && this.options.edit) {\n        toolbar = new L.EditToolbar(this.options.edit);\n        id = L.stamp(toolbar);\n        this._toolbars[id] = toolbar; // Listen for when toolbar is enabled\n\n        this._toolbars[id].on('enable', this._toolbarEnabled, this);\n      }\n    },\n    onAdd: function onAdd(map) {\n      var container = L.DomUtil.create('div', 'leaflet-draw'),\n          addedTopClass = false,\n          topClassName = 'leaflet-draw-toolbar-top',\n          toolbarContainer;\n\n      for (var toolbarId in this._toolbars) {\n        if (this._toolbars.hasOwnProperty(toolbarId)) {\n          toolbarContainer = this._toolbars[toolbarId].addToolbar(map);\n\n          if (toolbarContainer) {\n            // Add class to the first toolbar to remove the margin\n            if (!addedTopClass) {\n              if (!L.DomUtil.hasClass(toolbarContainer, topClassName)) {\n                L.DomUtil.addClass(toolbarContainer.childNodes[0], topClassName);\n              }\n\n              addedTopClass = true;\n            }\n\n            container.appendChild(toolbarContainer);\n          }\n        }\n      }\n\n      return container;\n    },\n    onRemove: function onRemove() {\n      for (var toolbarId in this._toolbars) {\n        if (this._toolbars.hasOwnProperty(toolbarId)) {\n          this._toolbars[toolbarId].removeToolbar();\n        }\n      }\n    },\n    setDrawingOptions: function setDrawingOptions(options) {\n      for (var toolbarId in this._toolbars) {\n        if (this._toolbars[toolbarId] instanceof L.DrawToolbar) {\n          this._toolbars[toolbarId].setOptions(options);\n        }\n      }\n    },\n    _toolbarEnabled: function _toolbarEnabled(e) {\n      var id = '' + L.stamp(e.target);\n\n      for (var toolbarId in this._toolbars) {\n        if (this._toolbars.hasOwnProperty(toolbarId) && toolbarId !== id) {\n          this._toolbars[toolbarId].disable();\n        }\n      }\n    }\n  });\n  L.Map.mergeOptions({\n    drawControlTooltips: true,\n    drawControl: false\n  });\n  L.Map.addInitHook(function () {\n    if (this.options.drawControl) {\n      this.drawControl = new L.Control.Draw();\n      this.addControl(this.drawControl);\n    }\n  });\n  L.Toolbar = L.Class.extend({\n    includes: [L.Mixin.Events],\n    initialize: function initialize(options) {\n      L.setOptions(this, options);\n      this._modes = {};\n      this._actionButtons = [];\n      this._activeMode = null;\n    },\n    enabled: function enabled() {\n      return this._activeMode !== null;\n    },\n    disable: function disable() {\n      if (!this.enabled()) {\n        return;\n      }\n\n      this._activeMode.handler.disable();\n    },\n    addToolbar: function addToolbar(map) {\n      var container = L.DomUtil.create('div', 'leaflet-draw-section'),\n          buttonIndex = 0,\n          buttonClassPrefix = this._toolbarClass || '',\n          modeHandlers = this.getModeHandlers(map),\n          i;\n      this._toolbarContainer = L.DomUtil.create('div', 'leaflet-draw-toolbar leaflet-bar');\n      this._map = map;\n\n      for (i = 0; i < modeHandlers.length; i++) {\n        if (modeHandlers[i].enabled) {\n          this._initModeHandler(modeHandlers[i].handler, this._toolbarContainer, buttonIndex++, buttonClassPrefix, modeHandlers[i].title);\n        }\n      } // if no buttons were added, do not add the toolbar\n\n\n      if (!buttonIndex) {\n        return;\n      } // Save button index of the last button, -1 as we would have ++ after the last button\n\n\n      this._lastButtonIndex = --buttonIndex; // Create empty actions part of the toolbar\n\n      this._actionsContainer = L.DomUtil.create('ul', 'leaflet-draw-actions'); // Add draw and cancel containers to the control container\n\n      container.appendChild(this._toolbarContainer);\n      container.appendChild(this._actionsContainer);\n      return container;\n    },\n    removeToolbar: function removeToolbar() {\n      // Dispose each handler\n      for (var handlerId in this._modes) {\n        if (this._modes.hasOwnProperty(handlerId)) {\n          // Unbind handler button\n          this._disposeButton(this._modes[handlerId].button, this._modes[handlerId].handler.enable, this._modes[handlerId].handler); // Make sure is disabled\n\n\n          this._modes[handlerId].handler.disable(); // Unbind handler\n\n\n          this._modes[handlerId].handler.off('enabled', this._handlerActivated, this).off('disabled', this._handlerDeactivated, this);\n        }\n      }\n\n      this._modes = {}; // Dispose the actions toolbar\n\n      for (var i = 0, l = this._actionButtons.length; i < l; i++) {\n        this._disposeButton(this._actionButtons[i].button, this._actionButtons[i].callback, this);\n      }\n\n      this._actionButtons = [];\n      this._actionsContainer = null;\n    },\n    _initModeHandler: function _initModeHandler(handler, container, buttonIndex, classNamePredix, buttonTitle) {\n      var type = handler.type;\n      this._modes[type] = {};\n      this._modes[type].handler = handler;\n      this._modes[type].button = this._createButton({\n        title: buttonTitle,\n        className: classNamePredix + '-' + type,\n        container: container,\n        callback: this._modes[type].handler.enable,\n        context: this._modes[type].handler\n      });\n      this._modes[type].buttonIndex = buttonIndex;\n\n      this._modes[type].handler.on('enabled', this._handlerActivated, this).on('disabled', this._handlerDeactivated, this);\n    },\n    _createButton: function _createButton(options) {\n      var link = L.DomUtil.create('a', options.className || '', options.container);\n      link.href = '#';\n\n      if (options.text) {\n        link.innerHTML = options.text;\n      }\n\n      if (options.title) {\n        link.title = options.title;\n      }\n\n      L.DomEvent.on(link, 'click', L.DomEvent.stopPropagation).on(link, 'mousedown', L.DomEvent.stopPropagation).on(link, 'dblclick', L.DomEvent.stopPropagation).on(link, 'click', L.DomEvent.preventDefault).on(link, 'click', options.callback, options.context);\n      return link;\n    },\n    _disposeButton: function _disposeButton(button, callback) {\n      L.DomEvent.off(button, 'click', L.DomEvent.stopPropagation).off(button, 'mousedown', L.DomEvent.stopPropagation).off(button, 'dblclick', L.DomEvent.stopPropagation).off(button, 'click', L.DomEvent.preventDefault).off(button, 'click', callback);\n    },\n    _handlerActivated: function _handlerActivated(e) {\n      // Disable active mode (if present)\n      this.disable(); // Cache new active feature\n\n      this._activeMode = this._modes[e.handler];\n      L.DomUtil.addClass(this._activeMode.button, 'leaflet-draw-toolbar-button-enabled');\n\n      this._showActionsToolbar();\n\n      this.fire('enable');\n    },\n    _handlerDeactivated: function _handlerDeactivated() {\n      this._hideActionsToolbar();\n\n      L.DomUtil.removeClass(this._activeMode.button, 'leaflet-draw-toolbar-button-enabled');\n      this._activeMode = null;\n      this.fire('disable');\n    },\n    _createActions: function _createActions(handler) {\n      var container = this._actionsContainer,\n          buttons = this.getActions(handler),\n          l = buttons.length,\n          li,\n          di,\n          dl,\n          button; // Dispose the actions toolbar (todo: dispose only not used buttons)\n\n      for (di = 0, dl = this._actionButtons.length; di < dl; di++) {\n        this._disposeButton(this._actionButtons[di].button, this._actionButtons[di].callback);\n      }\n\n      this._actionButtons = []; // Remove all old buttons\n\n      while (container.firstChild) {\n        container.removeChild(container.firstChild);\n      }\n\n      for (var i = 0; i < l; i++) {\n        if ('enabled' in buttons[i] && !buttons[i].enabled) {\n          continue;\n        }\n\n        li = L.DomUtil.create('li', '', container);\n        button = this._createButton({\n          title: buttons[i].title,\n          text: buttons[i].text,\n          container: li,\n          callback: buttons[i].callback,\n          context: buttons[i].context\n        });\n\n        this._actionButtons.push({\n          button: button,\n          callback: buttons[i].callback\n        });\n      }\n    },\n    _showActionsToolbar: function _showActionsToolbar() {\n      var buttonIndex = this._activeMode.buttonIndex,\n          lastButtonIndex = this._lastButtonIndex,\n          toolbarPosition = this._activeMode.button.offsetTop - 1; // Recreate action buttons on every click\n\n      this._createActions(this._activeMode.handler); // Correctly position the cancel button\n\n\n      this._actionsContainer.style.top = toolbarPosition + 'px';\n\n      if (buttonIndex === 0) {\n        L.DomUtil.addClass(this._toolbarContainer, 'leaflet-draw-toolbar-notop');\n        L.DomUtil.addClass(this._actionsContainer, 'leaflet-draw-actions-top');\n      }\n\n      if (buttonIndex === lastButtonIndex) {\n        L.DomUtil.addClass(this._toolbarContainer, 'leaflet-draw-toolbar-nobottom');\n        L.DomUtil.addClass(this._actionsContainer, 'leaflet-draw-actions-bottom');\n      }\n\n      this._actionsContainer.style.display = 'block';\n    },\n    _hideActionsToolbar: function _hideActionsToolbar() {\n      this._actionsContainer.style.display = 'none';\n      L.DomUtil.removeClass(this._toolbarContainer, 'leaflet-draw-toolbar-notop');\n      L.DomUtil.removeClass(this._toolbarContainer, 'leaflet-draw-toolbar-nobottom');\n      L.DomUtil.removeClass(this._actionsContainer, 'leaflet-draw-actions-top');\n      L.DomUtil.removeClass(this._actionsContainer, 'leaflet-draw-actions-bottom');\n    }\n  });\n  L.Tooltip = L.Class.extend({\n    initialize: function initialize(map) {\n      this._map = map;\n      this._popupPane = map._panes.popupPane;\n      this._container = map.options.drawControlTooltips ? L.DomUtil.create('div', 'leaflet-draw-tooltip', this._popupPane) : null;\n      this._singleLineLabel = false;\n    },\n    dispose: function dispose() {\n      if (this._container) {\n        this._popupPane.removeChild(this._container);\n\n        this._container = null;\n      }\n    },\n    updateContent: function updateContent(labelText) {\n      if (!this._container) {\n        return this;\n      }\n\n      labelText.subtext = labelText.subtext || ''; // update the vertical position (only if changed)\n\n      if (labelText.subtext.length === 0 && !this._singleLineLabel) {\n        L.DomUtil.addClass(this._container, 'leaflet-draw-tooltip-single');\n        this._singleLineLabel = true;\n      } else if (labelText.subtext.length > 0 && this._singleLineLabel) {\n        L.DomUtil.removeClass(this._container, 'leaflet-draw-tooltip-single');\n        this._singleLineLabel = false;\n      }\n\n      this._container.innerHTML = (labelText.subtext.length > 0 ? '<span class=\"leaflet-draw-tooltip-subtext\">' + labelText.subtext + '</span>' + '<br />' : '') + '<span>' + labelText.text + '</span>';\n      return this;\n    },\n    updatePosition: function updatePosition(latlng) {\n      var pos = this._map.latLngToLayerPoint(latlng),\n          tooltipContainer = this._container;\n\n      if (this._container) {\n        tooltipContainer.style.visibility = 'inherit';\n        L.DomUtil.setPosition(tooltipContainer, pos);\n      }\n\n      return this;\n    },\n    showAsError: function showAsError() {\n      if (this._container) {\n        L.DomUtil.addClass(this._container, 'leaflet-error-draw-tooltip');\n      }\n\n      return this;\n    },\n    removeError: function removeError() {\n      if (this._container) {\n        L.DomUtil.removeClass(this._container, 'leaflet-error-draw-tooltip');\n      }\n\n      return this;\n    }\n  });\n  L.DrawToolbar = L.Toolbar.extend({\n    options: {\n      polyline: {},\n      polygon: {},\n      rectangle: {},\n      circle: {},\n      marker: {}\n    },\n    initialize: function initialize(options) {\n      // Ensure that the options are merged correctly since L.extend is only shallow\n      for (var type in this.options) {\n        if (this.options.hasOwnProperty(type)) {\n          if (options[type]) {\n            options[type] = L.extend({}, this.options[type], options[type]);\n          }\n        }\n      }\n\n      this._toolbarClass = 'leaflet-draw-draw';\n      L.Toolbar.prototype.initialize.call(this, options);\n    },\n    getModeHandlers: function getModeHandlers(map) {\n      return [{\n        enabled: this.options.polyline,\n        handler: new L.Draw.Polyline(map, this.options.polyline),\n        title: L.drawLocal.draw.toolbar.buttons.polyline\n      }, {\n        enabled: this.options.polygon,\n        handler: new L.Draw.Polygon(map, this.options.polygon),\n        title: L.drawLocal.draw.toolbar.buttons.polygon\n      }, {\n        enabled: this.options.rectangle,\n        handler: new L.Draw.Rectangle(map, this.options.rectangle),\n        title: L.drawLocal.draw.toolbar.buttons.rectangle\n      }, {\n        enabled: this.options.circle,\n        handler: new L.Draw.Circle(map, this.options.circle),\n        title: L.drawLocal.draw.toolbar.buttons.circle\n      }, {\n        enabled: this.options.marker,\n        handler: new L.Draw.Marker(map, this.options.marker),\n        title: L.drawLocal.draw.toolbar.buttons.marker\n      }];\n    },\n    // Get the actions part of the toolbar\n    getActions: function getActions(handler) {\n      return [{\n        enabled: handler.deleteLastVertex,\n        title: L.drawLocal.draw.toolbar.undo.title,\n        text: L.drawLocal.draw.toolbar.undo.text,\n        callback: handler.deleteLastVertex,\n        context: handler\n      }, {\n        title: L.drawLocal.draw.toolbar.actions.title,\n        text: L.drawLocal.draw.toolbar.actions.text,\n        callback: this.disable,\n        context: this\n      }];\n    },\n    setOptions: function setOptions(options) {\n      L.setOptions(this, options);\n\n      for (var type in this._modes) {\n        if (this._modes.hasOwnProperty(type) && options.hasOwnProperty(type)) {\n          this._modes[type].handler.setOptions(options[type]);\n        }\n      }\n    }\n  });\n  /*L.Map.mergeOptions({\r\n  \teditControl: true\r\n  });*/\n\n  L.EditToolbar = L.Toolbar.extend({\n    options: {\n      edit: {\n        selectedPathOptions: {\n          color: '#fe57a1',\n\n          /* Hot pink all the things! */\n          opacity: 0.6,\n          dashArray: '10, 10',\n          fill: true,\n          fillColor: '#fe57a1',\n          fillOpacity: 0.1\n        }\n      },\n      remove: {},\n      featureGroup: null\n      /* REQUIRED! TODO: perhaps if not set then all layers on the map are selectable? */\n\n    },\n    initialize: function initialize(options) {\n      // Need to set this manually since null is an acceptable value here\n      if (options.edit) {\n        if (typeof options.edit.selectedPathOptions === 'undefined') {\n          options.edit.selectedPathOptions = this.options.edit.selectedPathOptions;\n        }\n\n        options.edit = L.extend({}, this.options.edit, options.edit);\n      }\n\n      if (options.remove) {\n        options.remove = L.extend({}, this.options.remove, options.remove);\n      }\n\n      this._toolbarClass = 'leaflet-draw-edit';\n      L.Toolbar.prototype.initialize.call(this, options);\n      this._selectedFeatureCount = 0;\n    },\n    getModeHandlers: function getModeHandlers(map) {\n      var featureGroup = this.options.featureGroup;\n      return [{\n        enabled: this.options.edit,\n        handler: new L.EditToolbar.Edit(map, {\n          featureGroup: featureGroup,\n          selectedPathOptions: this.options.edit.selectedPathOptions\n        }),\n        title: L.drawLocal.edit.toolbar.buttons.edit\n      }, {\n        enabled: this.options.remove,\n        handler: new L.EditToolbar.Delete(map, {\n          featureGroup: featureGroup\n        }),\n        title: L.drawLocal.edit.toolbar.buttons.remove\n      }];\n    },\n    getActions: function getActions() {\n      return [{\n        title: L.drawLocal.edit.toolbar.actions.save.title,\n        text: L.drawLocal.edit.toolbar.actions.save.text,\n        callback: this._save,\n        context: this\n      }, {\n        title: L.drawLocal.edit.toolbar.actions.cancel.title,\n        text: L.drawLocal.edit.toolbar.actions.cancel.text,\n        callback: this.disable,\n        context: this\n      }];\n    },\n    addToolbar: function addToolbar(map) {\n      var container = L.Toolbar.prototype.addToolbar.call(this, map);\n\n      this._checkDisabled();\n\n      this.options.featureGroup.on('layeradd layerremove', this._checkDisabled, this);\n      return container;\n    },\n    removeToolbar: function removeToolbar() {\n      this.options.featureGroup.off('layeradd layerremove', this._checkDisabled, this);\n      L.Toolbar.prototype.removeToolbar.call(this);\n    },\n    disable: function disable() {\n      if (!this.enabled()) {\n        return;\n      }\n\n      this._activeMode.handler.revertLayers();\n\n      L.Toolbar.prototype.disable.call(this);\n    },\n    _save: function _save() {\n      this._activeMode.handler.save();\n\n      this._activeMode.handler.disable();\n    },\n    _checkDisabled: function _checkDisabled() {\n      var featureGroup = this.options.featureGroup,\n          hasLayers = featureGroup.getLayers().length !== 0,\n          button;\n\n      if (this.options.edit) {\n        button = this._modes[L.EditToolbar.Edit.TYPE].button;\n\n        if (hasLayers) {\n          L.DomUtil.removeClass(button, 'leaflet-disabled');\n        } else {\n          L.DomUtil.addClass(button, 'leaflet-disabled');\n        }\n\n        button.setAttribute('title', hasLayers ? L.drawLocal.edit.toolbar.buttons.edit : L.drawLocal.edit.toolbar.buttons.editDisabled);\n      }\n\n      if (this.options.remove) {\n        button = this._modes[L.EditToolbar.Delete.TYPE].button;\n\n        if (hasLayers) {\n          L.DomUtil.removeClass(button, 'leaflet-disabled');\n        } else {\n          L.DomUtil.addClass(button, 'leaflet-disabled');\n        }\n\n        button.setAttribute('title', hasLayers ? L.drawLocal.edit.toolbar.buttons.remove : L.drawLocal.edit.toolbar.buttons.removeDisabled);\n      }\n    }\n  });\n  L.EditToolbar.Edit = L.Handler.extend({\n    statics: {\n      TYPE: 'edit'\n    },\n    includes: L.Mixin.Events,\n    initialize: function initialize(map, options) {\n      L.Handler.prototype.initialize.call(this, map); // Set options to the default unless already set\n\n      this._selectedPathOptions = options.selectedPathOptions; // Store the selectable layer group for ease of access\n\n      this._featureGroup = options.featureGroup;\n\n      if (!(this._featureGroup instanceof L.FeatureGroup)) {\n        throw new Error('options.featureGroup must be a L.FeatureGroup');\n      }\n\n      this._uneditedLayerProps = {}; // Save the type so super can fire, need to do this as cannot do this.TYPE :(\n\n      this.type = L.EditToolbar.Edit.TYPE;\n    },\n    enable: function enable() {\n      if (this._enabled || !this._hasAvailableLayers()) {\n        return;\n      }\n\n      this.fire('enabled', {\n        handler: this.type\n      }); //this disable other handlers\n\n      this._map.fire('draw:editstart', {\n        handler: this.type\n      }); //allow drawLayer to be updated before beginning edition.\n\n\n      L.Handler.prototype.enable.call(this);\n\n      this._featureGroup.on('layeradd', this._enableLayerEdit, this).on('layerremove', this._disableLayerEdit, this);\n    },\n    disable: function disable() {\n      if (!this._enabled) {\n        return;\n      }\n\n      this._featureGroup.off('layeradd', this._enableLayerEdit, this).off('layerremove', this._disableLayerEdit, this);\n\n      L.Handler.prototype.disable.call(this);\n\n      this._map.fire('draw:editstop', {\n        handler: this.type\n      });\n\n      this.fire('disabled', {\n        handler: this.type\n      });\n    },\n    addHooks: function addHooks() {\n      var map = this._map;\n\n      if (map) {\n        map.getContainer().focus();\n\n        this._featureGroup.eachLayer(this._enableLayerEdit, this);\n\n        this._tooltip = new L.Tooltip(this._map);\n\n        this._tooltip.updateContent({\n          text: L.drawLocal.edit.handlers.edit.tooltip.text,\n          subtext: L.drawLocal.edit.handlers.edit.tooltip.subtext\n        });\n\n        this._map.on('mousemove', this._onMouseMove, this);\n      }\n    },\n    removeHooks: function removeHooks() {\n      if (this._map) {\n        // Clean up selected layers.\n        this._featureGroup.eachLayer(this._disableLayerEdit, this); // Clear the backups of the original layers\n\n\n        this._uneditedLayerProps = {};\n\n        this._tooltip.dispose();\n\n        this._tooltip = null;\n\n        this._map.off('mousemove', this._onMouseMove, this);\n      }\n    },\n    revertLayers: function revertLayers() {\n      this._featureGroup.eachLayer(function (layer) {\n        this._revertLayer(layer);\n      }, this);\n    },\n    save: function save() {\n      var editedLayers = new L.LayerGroup();\n\n      this._featureGroup.eachLayer(function (layer) {\n        if (layer.edited) {\n          editedLayers.addLayer(layer);\n          layer.edited = false;\n        }\n      });\n\n      this._map.fire('draw:edited', {\n        layers: editedLayers\n      });\n    },\n    _backupLayer: function _backupLayer(layer) {\n      var id = L.Util.stamp(layer);\n\n      if (!this._uneditedLayerProps[id]) {\n        // Polyline, Polygon or Rectangle\n        if (layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Rectangle) {\n          this._uneditedLayerProps[id] = {\n            latlngs: L.LatLngUtil.cloneLatLngs(layer.getLatLngs())\n          };\n        } else if (layer instanceof L.Circle) {\n          this._uneditedLayerProps[id] = {\n            latlng: L.LatLngUtil.cloneLatLng(layer.getLatLng()),\n            radius: layer.getRadius()\n          };\n        } else if (layer instanceof L.Marker) {\n          // Marker\n          this._uneditedLayerProps[id] = {\n            latlng: L.LatLngUtil.cloneLatLng(layer.getLatLng())\n          };\n        }\n      }\n    },\n    _revertLayer: function _revertLayer(layer) {\n      var id = L.Util.stamp(layer);\n      layer.edited = false;\n\n      if (this._uneditedLayerProps.hasOwnProperty(id)) {\n        // Polyline, Polygon or Rectangle\n        if (layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Rectangle) {\n          layer.setLatLngs(this._uneditedLayerProps[id].latlngs);\n        } else if (layer instanceof L.Circle) {\n          layer.setLatLng(this._uneditedLayerProps[id].latlng);\n          layer.setRadius(this._uneditedLayerProps[id].radius);\n        } else if (layer instanceof L.Marker) {\n          // Marker\n          layer.setLatLng(this._uneditedLayerProps[id].latlng);\n        }\n      }\n    },\n    _toggleMarkerHighlight: function _toggleMarkerHighlight(marker) {\n      if (!marker._icon) {\n        return;\n      } // This is quite naughty, but I don't see another way of doing it. (short of setting a new icon)\n\n\n      var icon = marker._icon;\n      icon.style.display = 'none';\n\n      if (L.DomUtil.hasClass(icon, 'leaflet-edit-marker-selected')) {\n        L.DomUtil.removeClass(icon, 'leaflet-edit-marker-selected'); // Offset as the border will make the icon move.\n\n        this._offsetMarker(icon, -4);\n      } else {\n        L.DomUtil.addClass(icon, 'leaflet-edit-marker-selected'); // Offset as the border will make the icon move.\n\n        this._offsetMarker(icon, 4);\n      }\n\n      icon.style.display = '';\n    },\n    _offsetMarker: function _offsetMarker(icon, offset) {\n      var iconMarginTop = parseInt(icon.style.marginTop, 10) - offset,\n          iconMarginLeft = parseInt(icon.style.marginLeft, 10) - offset;\n      icon.style.marginTop = iconMarginTop + 'px';\n      icon.style.marginLeft = iconMarginLeft + 'px';\n    },\n    _enableLayerEdit: function _enableLayerEdit(e) {\n      var layer = e.layer || e.target || e,\n          isMarker = layer instanceof L.Marker,\n          pathOptions; // Don't do anything if this layer is a marker but doesn't have an icon. Markers\n      // should usually have icons. If using Leaflet.draw with Leafler.markercluster there\n      // is a chance that a marker doesn't.\n\n      if (isMarker && !layer._icon) {\n        return;\n      } // Back up this layer (if haven't before)\n\n\n      this._backupLayer(layer); // Update layer style so appears editable\n\n\n      if (this._selectedPathOptions) {\n        pathOptions = L.Util.extend({}, this._selectedPathOptions);\n\n        if (isMarker) {\n          this._toggleMarkerHighlight(layer);\n        } else {\n          layer.options.previousOptions = L.Util.extend({\n            dashArray: null\n          }, layer.options); // Make sure that Polylines are not filled\n\n          if (!(layer instanceof L.Circle) && !(layer instanceof L.Polygon) && !(layer instanceof L.Rectangle)) {\n            pathOptions.fill = false;\n          }\n\n          layer.setStyle(pathOptions);\n        }\n      }\n\n      if (isMarker) {\n        layer.dragging.enable();\n        layer.on('dragend', this._onMarkerDragEnd);\n      } else {\n        layer.editing.enable();\n      }\n    },\n    _disableLayerEdit: function _disableLayerEdit(e) {\n      var layer = e.layer || e.target || e;\n      layer.edited = false; // Reset layer styles to that of before select\n\n      if (this._selectedPathOptions) {\n        if (layer instanceof L.Marker) {\n          this._toggleMarkerHighlight(layer);\n        } else {\n          // reset the layer style to what is was before being selected\n          layer.setStyle(layer.options.previousOptions); // remove the cached options for the layer object\n\n          delete layer.options.previousOptions;\n        }\n      }\n\n      if (layer instanceof L.Marker) {\n        layer.dragging.disable();\n        layer.off('dragend', this._onMarkerDragEnd, this);\n      } else {\n        layer.editing.disable();\n      }\n    },\n    _onMarkerDragEnd: function _onMarkerDragEnd(e) {\n      var layer = e.target;\n      layer.edited = true;\n    },\n    _onMouseMove: function _onMouseMove(e) {\n      this._tooltip.updatePosition(e.latlng);\n    },\n    _hasAvailableLayers: function _hasAvailableLayers() {\n      return this._featureGroup.getLayers().length !== 0;\n    }\n  });\n  L.EditToolbar.Delete = L.Handler.extend({\n    statics: {\n      TYPE: 'remove' // not delete as delete is reserved in js\n\n    },\n    includes: L.Mixin.Events,\n    initialize: function initialize(map, options) {\n      L.Handler.prototype.initialize.call(this, map);\n      L.Util.setOptions(this, options); // Store the selectable layer group for ease of access\n\n      this._deletableLayers = this.options.featureGroup;\n\n      if (!(this._deletableLayers instanceof L.FeatureGroup)) {\n        throw new Error('options.featureGroup must be a L.FeatureGroup');\n      } // Save the type so super can fire, need to do this as cannot do this.TYPE :(\n\n\n      this.type = L.EditToolbar.Delete.TYPE;\n    },\n    enable: function enable() {\n      if (this._enabled || !this._hasAvailableLayers()) {\n        return;\n      }\n\n      this.fire('enabled', {\n        handler: this.type\n      });\n\n      this._map.fire('draw:deletestart', {\n        handler: this.type\n      });\n\n      L.Handler.prototype.enable.call(this);\n\n      this._deletableLayers.on('layeradd', this._enableLayerDelete, this).on('layerremove', this._disableLayerDelete, this);\n    },\n    disable: function disable() {\n      if (!this._enabled) {\n        return;\n      }\n\n      this._deletableLayers.off('layeradd', this._enableLayerDelete, this).off('layerremove', this._disableLayerDelete, this);\n\n      L.Handler.prototype.disable.call(this);\n\n      this._map.fire('draw:deletestop', {\n        handler: this.type\n      });\n\n      this.fire('disabled', {\n        handler: this.type\n      });\n    },\n    addHooks: function addHooks() {\n      var map = this._map;\n\n      if (map) {\n        map.getContainer().focus();\n\n        this._deletableLayers.eachLayer(this._enableLayerDelete, this);\n\n        this._deletedLayers = new L.layerGroup();\n        this._tooltip = new L.Tooltip(this._map);\n\n        this._tooltip.updateContent({\n          text: L.drawLocal.edit.handlers.remove.tooltip.text\n        });\n\n        this._map.on('mousemove', this._onMouseMove, this);\n      }\n    },\n    removeHooks: function removeHooks() {\n      if (this._map) {\n        this._deletableLayers.eachLayer(this._disableLayerDelete, this);\n\n        this._deletedLayers = null;\n\n        this._tooltip.dispose();\n\n        this._tooltip = null;\n\n        this._map.off('mousemove', this._onMouseMove, this);\n      }\n    },\n    revertLayers: function revertLayers() {\n      // Iterate of the deleted layers and add them back into the featureGroup\n      this._deletedLayers.eachLayer(function (layer) {\n        this._deletableLayers.addLayer(layer);\n      }, this);\n    },\n    save: function save() {\n      this._map.fire('draw:deleted', {\n        layers: this._deletedLayers\n      });\n    },\n    _enableLayerDelete: function _enableLayerDelete(e) {\n      var layer = e.layer || e.target || e;\n      layer.on('click', this._removeLayer, this);\n    },\n    _disableLayerDelete: function _disableLayerDelete(e) {\n      var layer = e.layer || e.target || e;\n      layer.off('click', this._removeLayer, this); // Remove from the deleted layers so we can't accidently revert if the user presses cancel\n\n      this._deletedLayers.removeLayer(layer);\n    },\n    _removeLayer: function _removeLayer(e) {\n      var layer = e.layer || e.target || e;\n\n      this._deletableLayers.removeLayer(layer);\n\n      this._deletedLayers.addLayer(layer);\n    },\n    _onMouseMove: function _onMouseMove(e) {\n      this._tooltip.updatePosition(e.latlng);\n    },\n    _hasAvailableLayers: function _hasAvailableLayers() {\n      return this._deletableLayers.getLayers().length !== 0;\n    }\n  });\n})(window, document);\n\n//# sourceURL=webpack:///./lib/draw/leaflet.draw-src.js?");

/***/ }),

/***/ "./lib/hashchange.js":
/*!***************************!*\
  !*** ./lib/hashchange.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * Hashchange Event Polyfill\r\n */\n(function () {\n  window.HashChangeEvent = function () {\n    var ret = function ret(oldURL, newURL) {\n      this.oldURL = oldURL;\n      this.newURL = newURL;\n      this.timeStamp = new Date().getTime();\n    };\n\n    ret.prototype = {\n      bubbles: false,\n      cancelable: false,\n      currentTarget: null,\n      defaultPrevented: false,\n      returnValue: true,\n      srcElement: null,\n      target: null,\n      timeStamp: null,\n      type: 'hashchange'\n    };\n    return ret;\n  }();\n\n  var fix = {\n    // Bound event listeners\n    listeners: {\n      funcs: [],\n      remove: function remove(func) {\n        var arr = [];\n\n        for (var i = 0, c = fix.listeners.funcs.length; i < c; i++) {\n          if (fix.listeners.funcs[i] !== func) {\n            arr.push(fix.listeners.funcs[i]);\n          }\n        }\n\n        fix.listeners.funcs = arr;\n      }\n    },\n    // Start the poller\n    init: function init() {\n      // Get the starting hash\n      fix.lastHash = fix.getHash();\n      fix.lastLocation = String(location); // Patch addEventListener\n\n      if (window.addEventListener) {\n        var nativeAEL = window.addEventListener;\n\n        window.addEventListener = function (evt, func) {\n          if (evt === 'hashchange') {\n            fix.listeners.funcs.push(func);\n          } else {\n            return nativeAEL.apply(window, arguments);\n          }\n        };\n      } // Patch attachEvent\n\n\n      if (window.attachEvent) {\n        var nativeAE = window.attachEvent;\n\n        window.attachEvent = function (evt, func) {\n          if (evt === 'onhashchange') {\n            fix.listeners.funcs.push(func);\n          } else {\n            return nativeAE.apply(window, arguments);\n          }\n        };\n      } // Start polling\n\n\n      fix.setTimeout();\n    },\n    // The previous hash value\n    lastHash: null,\n    lastLocation: null,\n    // The number of miliseconds between pollings\n    pollerRate: 50,\n    // Read the hash value from the URL\n    getHash: function getHash() {\n      return location.hash.slice(1);\n    },\n    // Sets the next interval for the timer\n    setTimeout: function setTimeout() {\n      window.setTimeout(fix.pollerInterval, fix.pollerRate);\n    },\n    // Creates a new hashchange event object\n    createEventObject: function createEventObject(oldURL, newURL) {\n      return new window.HashChangeEvent(oldURL, newURL);\n    },\n    // Runs on an interval testing the hash\n    pollerInterval: function pollerInterval() {\n      var hash = fix.getHash();\n\n      if (hash !== fix.lastHash) {\n        var funcs = fix.listeners.funcs.slice(0);\n\n        if (typeof window.onhashchange === 'function') {\n          funcs.push(window.onhashchange);\n        }\n\n        for (var i = 0, c = funcs.length; i < c; i++) {\n          var evt = fix.createEventObject({\n            oldURL: fix.lastLocation,\n            newURL: String(location)\n          });\n        }\n\n        fix.lastHash = fix.getHash();\n        fix.lastLocation = String(location);\n      }\n\n      fix.setTimeout();\n    }\n  };\n  fix.init();\n})();\n\n//# sourceURL=webpack:///./lib/hashchange.js?");

/***/ }),

/***/ "./lib/queue.js":
/*!**********************!*\
  !*** ./lib/queue.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// (function() {\n//   if (typeof module === \"undefined\") self.queue = queue;\n//   else module.exports = queue;\n//   queue.version = \"1.0.4\";\n//   var slice = [].slice;\n//   async function queue(parallelism) {\n//     var q,\n//         tasks = [],\n//         started = 0, // number of tasks that have been started (and perhaps finished)\n//         active = 0, // number of tasks currently being executed (started but not finished)\n//         remaining = 0, // number of tasks not yet finished\n//         popping, // inside a synchronous task callback?\n//         error = null,\n//         await = noop,\n//         all;\n//     if (!parallelism) parallelism = Infinity;\n//     function pop() {\n//       while (popping = started < tasks.length && active < parallelism) {\n//         var i = started++,\n//             t = tasks[i],\n//             a = slice.call(t, 1);\n//         a.push(callback(i));\n//         ++active;\n//         t[0].apply(null, a);\n//       }\n//     }\n//     function callback(i) {\n//       return function(e, r) {\n//         --active;\n//         if (error != null) return;\n//         if (e != null) {\n//           error = e; // ignore new tasks and squelch active callbacks\n//           started = remaining = NaN; // stop queued tasks from starting\n//           notify();\n//         } else {\n//           tasks[i] = r;\n//           if (--remaining) popping || pop();\n//           else notify();\n//         }\n//       };\n//     }\n//     function notify() {\n//       if (error != null) await(error);\n//       else if (all) await(error, tasks);\n//       else await.apply(null, [error].concat(tasks));\n//     }\n//     return q = {\n//       defer: function() {\n//         if (!error) {\n//           tasks.push(arguments);\n//           ++remaining;\n//           pop();\n//         }\n//         return q;\n//       },\n//       await: function(f) {\n//         await = f;\n//         all = false;\n//         if (!remaining) notify();\n//         return q;\n//       },\n//       awaitAll: function(f) {\n//         await = f;\n//         all = true;\n//         if (!remaining) notify();\n//         return q;\n//       }\n//     };\n//   }\n//   function noop() {}\n// })();\n\n//# sourceURL=webpack:///./lib/queue.js?");

/***/ }),

/***/ "./node_modules/_base64-js@1.5.1@base64-js/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/_base64-js@1.5.1@base64-js/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack:///./node_modules/_base64-js@1.5.1@base64-js/index.js?");

/***/ }),

/***/ "./node_modules/_buffer@4.9.2@buffer/index.js":
/*!****************************************************!*\
  !*** ./node_modules/_buffer@4.9.2@buffer/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/_base64-js@1.5.1@base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/_ieee754@1.2.1@ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/_isarray@1.0.0@isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../_webpack@4.46.0@webpack/buildin/global.js */ \"./node_modules/_webpack@4.46.0@webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/_buffer@4.9.2@buffer/index.js?");

/***/ }),

/***/ "./node_modules/_ieee754@1.2.1@ieee754/index.js":
/*!******************************************************!*\
  !*** ./node_modules/_ieee754@1.2.1@ieee754/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack:///./node_modules/_ieee754@1.2.1@ieee754/index.js?");

/***/ }),

/***/ "./node_modules/_isarray@1.0.0@isarray/index.js":
/*!******************************************************!*\
  !*** ./node_modules/_isarray@1.0.0@isarray/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack:///./node_modules/_isarray@1.0.0@isarray/index.js?");

/***/ }),

/***/ "./node_modules/_webpack@4.46.0@webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ 1:
/*!********************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** multi /dist/d3.js /lib/hashchange.js /lib/blob.js /lib/base64.js /lib/bucket.js /lib/queue.js /lib/d3.keybinding.js /lib/d3.trigger.js /lib/d3-compat.js /lib/draw/leaflet.draw-src.js /lib/drag/leaflet.drag.js /lib/codemirror/lib/codemirror.js /lib/codemirror/mode/javascript/javascript.js ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! /dist/d3.js */\"./dist/d3.js\");\n__webpack_require__(/*! /lib/hashchange.js */\"./lib/hashchange.js\");\n__webpack_require__(/*! /lib/blob.js */\"./lib/blob.js\");\n__webpack_require__(/*! /lib/base64.js */\"./lib/base64.js\");\n__webpack_require__(/*! /lib/bucket.js */\"./lib/bucket.js\");\n__webpack_require__(/*! /lib/queue.js */\"./lib/queue.js\");\n__webpack_require__(/*! /lib/d3.keybinding.js */\"./lib/d3.keybinding.js\");\n__webpack_require__(/*! /lib/d3.trigger.js */\"./lib/d3.trigger.js\");\n__webpack_require__(/*! /lib/d3-compat.js */\"./lib/d3-compat.js\");\n__webpack_require__(/*! /lib/draw/leaflet.draw-src.js */\"./lib/draw/leaflet.draw-src.js\");\n__webpack_require__(/*! /lib/drag/leaflet.drag.js */\"./lib/drag/leaflet.drag.js\");\n__webpack_require__(/*! /lib/codemirror/lib/codemirror.js */\"./lib/codemirror/lib/codemirror.js\");\nmodule.exports = __webpack_require__(/*! /lib/codemirror/mode/javascript/javascript.js */\"./lib/codemirror/mode/javascript/javascript.js\");\n\n\n//# sourceURL=webpack:///multi_/dist/d3.js_/lib/hashchange.js_/lib/blob.js_/lib/base64.js_/lib/bucket.js_/lib/queue.js_/lib/d3.keybinding.js_/lib/d3.trigger.js_/lib/d3-compat.js_/lib/draw/leaflet.draw-src.js_/lib/drag/leaflet.drag.js_/lib/codemirror/lib/codemirror.js_/lib/codemirror/mode/javascript/javascript.js?");

/***/ })

/******/ });
});